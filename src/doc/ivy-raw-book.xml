<?xml version='1.0'?>
<!DOCTYPE book PUBLIC "-//Drupal//DTD DXML V1.0//EN" "http://drupal.org/xml/dxml.dtd">
<node id="node-24">
<nodeinfo  path='ivy/doc' md5_body='c79bc14d0b09df0d46fcd6334a32e359' weight='0' depth='1' type='book' author='admin' uid='1' created='1117125735' status='1' format='4' sticky='0' promote='1'/>
<title>Ivy Documentation</title>
<teaser>
<![CDATA[Welcome to the official Ivy documentation.

<h1>What is Ivy?</h1>
Ivy is an agile dependency manager, primarily focus on managing java dependencies.
Ivy is open source and released under a very permissive <a href="./ivy/license">BSD license</a>.
Ivy has a lot of powerful <a href="./ivy/features">features</a>, the most popular and useful being its flexibily, inteegration with ant, and its strong transitive dependencies management engine.
The transitive dependencies management is a feature which let you get dependencies of your dependencies, transitively. In order to address this problematic ivy needs to find metadata about your modules, usually in an <a href="./ivy/doc/ivyfile">ivy file</a>. To find these metadata and your dependencies artifacts (usually jars), Ivy can be configured to use a lot of different <a href="./ivy/doc/configuration/resolvers">repositories</a>.]]>
</teaser>
<content>
<![CDATA[Welcome to the official Ivy documentation.

<h1>What is Ivy?</h1>
Ivy is an agile dependency manager, primarily focus on managing java dependencies.
Ivy is open source and released under a very permissive <a href="./ivy/license">BSD license</a>.
Ivy has a lot of powerful <a href="./ivy/features">features</a>, the most popular and useful being its flexibily, inteegration with ant, and its strong transitive dependencies management engine.
The transitive dependencies management is a feature which let you get dependencies of your dependencies, transitively. In order to address this problematic ivy needs to find metadata about your modules, usually in an <a href="./ivy/doc/ivyfile">ivy file</a>. To find these metadata and your dependencies artifacts (usually jars), Ivy can be configured to use a lot of different <a href="./ivy/doc/configuration/resolvers">repositories</a>.

<h1>About this doc</h1>
If you browse this documentation from your installation of ivy, you can also check the <a href="http://www.jayasoft.org/ivy/doc">online version</a> for latest updates and comments. To easily navigate to the online version, you will find a link to the corresponding online version on each page just after the title.

The online version of this documentation is updated periodically, especially when new features are added during development. So if you find something documented here not available in your version of ivy, it may be because it is available only with the latest <a href="./ivy/download">download</a>.

If you want to view the whole documentation in a single printer-friendly page, please use the <a href="./ivy/doc/print">printer-friendly link</a> at the bottom of any documentation page in the online documentation.

<h1>Other places to go</h1>
Check Ivy <a href="./ivy/features">features</a>. 
Read our <a href="./ivy/faq">FAQ</a>.
Ask for help on our <a href="./ivy/forum">forum</a>.
Report bug or feature request in our <a href="./issues">issue tracking system</a>.
Check <a href="./ivy/links">external tools and resources</a>.

<h1>Overview</h1>
This documentation is decomposed in 3 main parts:
<ul>
  <li><a href="./ivy/doc/tutorial">Tutorials</a></li> 
The tutorials is the best way to begin to play with ivy. You will easily and quickly learn the basics of Ivy.
  <li><a href="./ivy/doc/reference">Reference</a></li> 
The reference documentation gives you all the details of Ivy. 
The introduction part is particularly useful: it defines some vocabulary, explains main concepts such as dependency resolvers and patterns, and give an overview on how ivy works internally. 
It's also in the reference doc that you will find all you always dreamed to know about ivy configuration, ivy files, and ivy use (especially with ant).
  <li><a href="./ivy/doc/appendix">Appendix</a></li> 
The appendix section contains a bunch of Ivy related information which is not part of Ivy reference doc.
</ul>]]>
</content>
<node id="node-27">
<nodeinfo  path='ivy/doc/tutorial' md5_body='d062986f78ba27ee9b6c7897ec5e830f' weight='-15' depth='2' type='book' author='admin' uid='1' created='1117126070' status='1' format='1' sticky='0' promote='1'/>
<title>Tutorials</title>
<teaser>
<![CDATA[The best way to learn is to practice ! That's what the ivy tutorials will help you to do to discover some of the great ivy <a href="./ivy/features">features</a>.

But before starting the tutorials, make sure you have properly <a href="./ivy/doc/install">installed</a> ivy.

All tutorials sources can be found in any ivy distribution, in the src/example directory.

The following tutorials are available:
<ul>
<li><a href="./ivy/doc/tutorial/start">Quick Start</a></li> 
guide you through your very first steps with ivy.
<li><a href="./ivy/doc/tutorial/ivyrep">Using IvyRep</a></li> 
show you the out of the box power of ivy + ivyrep.]]>
</teaser>
<content>
<![CDATA[The best way to learn is to practice ! That's what the ivy tutorials will help you to do to discover some of the great ivy <a href="./ivy/features">features</a>.

But before starting the tutorials, make sure you have properly <a href="./ivy/doc/install">installed</a> ivy.

All tutorials sources can be found in any ivy distribution, in the src/example directory.

The following tutorials are available:
<ul>
<li><a href="./ivy/doc/tutorial/start">Quick Start</a></li> 
guide you through your very first steps with ivy.
<li><a href="./ivy/doc/tutorial/ivyrep">Using IvyRep</a></li> 
show you the out of the box power of ivy + ivyrep.
<li><a href="./ivy/doc/tutorial/defaultconf">Configuring default resolver</a></li> 
give you a better understanding of the default configuration and show you how to customize it to your needs.
<li><a href="./ivy/doc/tutorial/multiple">Multiple Resolvers</a></li> 
teach you how to configure Ivy to find its dependencies in multiple places.
<li><a href="./ivy/doc/tutorial/dual">Dual Resolver</a></li> 
help you configure ivy to find ivy files in one place and artifacts in another.
<li><a href="./ivy/doc/tutorial/multi-project">Project Dependencies</a></li> 
makes you touch the interest of using ivy in multi project environment.
<li><a href="./ivy/doc/tutorial/conf">Using Ivy Configurations</a></li> 
show how to use configurations in ivy file to define set of artifacts.
<li><a href="./ivy/doc/tutorial/build-repository">Building a repository</a></li> 
show how to build your own enterprise repository.
</ul>]]>
</content>
<node id="node-28">
<nodeinfo  path='ivy/doc/tutorial/start' md5_body='3af01a51cb370a431c54b8b2794ad2fd' weight='-15' depth='3' type='book' author='admin' uid='1' created='1117126157' status='1' format='4' sticky='0' promote='1'/>
<title>Quick Start</title>
<teaser>
<![CDATA[In this example, we will see the easiest way to use ivy. No configuration or other complicated files to write, only the list of libraries the project will use.

<em>You'll find this tutorial sources in the ivy distribution in the src/example/hello-ivy directory.</em>

<h1>The ivy.xml file</h1>
This file is used to describe, the dependencies of the project on other libraries.
Here is the sample : 
<code type="xml">
<ivy-module version="1.0">
    <info organisation="jayasoft" module="hello-ivy" />
    <dependencies>
        <dependency org="apache" name="commons-lang" rev="2.0" />
    </dependencies>]]>
</teaser>
<content>
<![CDATA[In this example, we will see the easiest way to use ivy. No configuration or other complicated files to write, only the list of libraries the project will use.

<em>You'll find this tutorial sources in the ivy distribution in the src/example/hello-ivy directory.</em>

<h1>The ivy.xml file</h1>
This file is used to describe, the dependencies of the project on other libraries.
Here is the sample : 
<code type="xml">
<ivy-module version="1.0">
    <info organisation="jayasoft" module="hello-ivy" />
    <dependencies>
        <dependency org="apache" name="commons-lang" rev="2.0" />
    </dependencies>
</ivy-module>
</code>

<h1>The build.xml file</h1>
The build file corresponding to use it, contains only:
<code type="xml">
<project xmlns:ivy="antlib:fr.jayasoft.ivy.ant" name="hello-ivy" default="run">
    
    ...
    
    <!-- ================================= 
          target: resolve              
         ================================= -->
    <target name="resolve" description="--> retrieve dependencies with ivy">
        <ivy:retrieve />
    </target>
</project>
</code>
<h1>Running the project</h1>
To run the sample, open a dos (or shell) window, and go under the hello-ivy example directory.
Then, on the command prompt, just run ant :
<div class="shell"><pre>
I:\hello-ivy>ant
Buildfile: build.xml

resolve:
:: Ivy 1.0-rc3 - 20050421161206 :: http://ivy.jayasoft.org/ ::
no configuration file found, using default...
:: resolving dependencies :: jayasoft/hello-ivy-working@xmen
        confs: [default]
downloading http://www.ibiblio.org/maven/commons-lang/jars/commons-lang-2.0.jar(2.0) ...
..................................... (165kB)
        [SUCCESSFUL ] apache/commons-lang-2.0/commons-lang.jar[jar] (4688ms)
:: resolution report ::
        ---------------------------------------------------------------------
        |                  |            modules            ||   artifacts   |
        |       conf       | number| search|dwnlded|evicted|| number|dwnlded|
        ---------------------------------------------------------------------
        |      default     |   1   |   1   |   0   |   0   ||   1   |   1   |
        ---------------------------------------------------------------------
:: retrieving :: jayasoft/hello-ivy
        confs: [default]
        1 artifacts copied, 0 already retrieved

run:
    [mkdir] Created dir: I:\hello-ivy\build
    [javac] Compiling 1 source file to I:\hello-ivy\build
     [java] standard message : hello ivy !
     [java] capitalized by org.apache.commons.lang.WordUtils : Hello Ivy !

BUILD SUCCESSFUL
Total time: 8 seconds</pre></div>
<h1>What happened ?</h1>
Without any configuration, other than it's default configuration, ivy retrieve files from the maven ibiblio libraries repository. That's what happened here. 
The resolve task has downloaded the commons-lang.jar file from ibiblio, then copied it to the ivy cache and then dispatch it in the default library directory of the project : the lib dir.
Some will say that the task was long to achieve. Yeah, it's true it was, but it has downloaded from the web the needed file. Let's try to run it again:
<div class="shell"><pre>I:\hello-ivy>ant
Buildfile: build.xml

resolve:
:: resolving dependencies :: jayasoft/hello-ivy-null :: [default]
:: resolution report ::
        [default] jayasoft/hello-ivy-working@rahan: 1 artifacts (0 downloaded)
:: retrieving :: jayasoft/hello-ivy :: [default]

run:
     [java] standard message : hello ivy !
     [java] capitalized by org.apache.commons.lang.WordUtils : Hello Ivy !

BUILD SUCCESSFUL
Total time: 1 second</pre></div>
Great ! the cache was used, no download was needed and the build was instantaneous.

If you want to check the content of the cache, by default it is put in your user home in a .ivy/cache directory.

And now, if you want to generate a report detailing all the dependencies of your module, you can call the report target, and check the generated file in the build directory. You should obtain something looking like <a href="./misc/ivy/samples/jayasoft-ivyrep-example-default.html">this</a>.

You are now ready to go to the next tutorials to go one step beyond using ivy transitive dependencies management.]]>
</content>
</node>
<node id="node-36">
<nodeinfo  path='ivy/doc/tutorial/ivyrep' md5_body='5d52e45f551ef76caa10dd1bc6fdb434' weight='-12' depth='3' type='book' author='admin' uid='1' created='1117212279' status='1' format='3' sticky='0' promote='1'/>
<title>Using IvyRep</title>
<teaser>
<![CDATA[In this example, we will see the easiest way to use ivy and benefit from its transitive dependencies feature. 
No configuration or other complicated files to write, only the list of libraries the project will use.

<h1>The ivy.xml file</h1>
This file is used to describe, the dependencies of the project on other libraries.
Here is the sample : 
<div class="ivy-file">

<!-- converted by xmlverbatim.xsl 1.1, (c) O. Becker -->
<div class="xmlverb-default">&lt;<span class="xmlverb-element-name">ivy-module</span> <span class="xmlverb-attr-name">version</span>="<span class="xmlverb-attr-content">1.0</span>"&gt;<span class="xmlverb-text">]]>
</teaser>
<content>
<![CDATA[In this example, we will see the easiest way to use ivy and benefit from its transitive dependencies feature. 
No configuration or other complicated files to write, only the list of libraries the project will use.

<h1>The ivy.xml file</h1>
This file is used to describe, the dependencies of the project on other libraries.
Here is the sample : 
<div class="ivy-file">

<!-- converted by xmlverbatim.xsl 1.1, (c) O. Becker -->
<div class="xmlverb-default">&lt;<span class="xmlverb-element-name">ivy-module</span> <span class="xmlverb-attr-name">version</span>="<span class="xmlverb-attr-content">1.0</span>"&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">info</span> <span class="xmlverb-attr-name">organisation</span>="<span class="xmlverb-attr-content">jayasoft</span>" <span class="xmlverb-attr-name">module</span>="<span class="xmlverb-attr-content">hello-ivy</span>" /&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">dependencies</span>&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">dependency</span> <span class="xmlverb-attr-name">org</span>="<span class="xmlverb-attr-content">apache</span>" <span class="xmlverb-attr-name">name</span>="<span class="xmlverb-attr-content">commons-lang</span>" <span class="xmlverb-attr-name">rev</span>="<span class="xmlverb-attr-content">2.0</span>" /&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">dependency</span> <span class="xmlverb-attr-name">org</span>="<span class="xmlverb-attr-content">apache</span>" <span class="xmlverb-attr-name">name</span>="<span class="xmlverb-attr-content">commons-cli</span>" <span class="xmlverb-attr-name">rev</span>="<span class="xmlverb-attr-content">1.0</span>" /&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;/<span class="xmlverb-element-name">dependencies</span>&gt;<span class="xmlverb-text"><br>
</span>&lt;/<span class="xmlverb-element-name">ivy-module</span>&gt;<br></div>
</div>
The build file corresponding to use it, contains only :
<div class="build-file">
<!-- converted by xmlverbatim.xsl 1.1, (c) O. Becker -->
<div class="xmlverb-default">&lt;<span class="xmlverb-element-name">project</span><span class="xmlverb-ns-name"> xmlns:ivy</span>="<span class="xmlverb-ns-uri">antlib:fr.jayasoft.ivy.ant</span>" <span class="xmlverb-attr-name">name</span>="<span class="xmlverb-attr-content">hello-ivy</span>" <span class="xmlverb-attr-name">default</span>="<span class="xmlverb-attr-content">run</span>"&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;!--<span class="xmlverb-comment">&nbsp;=================================&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target:&nbsp;resolve&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=================================&nbsp;</span>--&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">target</span> <span class="xmlverb-attr-name">name</span>="<span class="xmlverb-attr-content">resolve</span>" <span class="xmlverb-attr-name">description</span>="<span class="xmlverb-attr-content">--&gt; retreive dependencies with ivy</span>"&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-nsprefix">ivy</span>:<span class="xmlverb-element-name">retrieve</span> /&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;/<span class="xmlverb-element-name">target</span>&gt;<span class="xmlverb-text"><br>
</span>&lt;/<span class="xmlverb-element-name">project</span>&gt;<br>
</div></div>
<h1>Running the project</h1>
To run the sample, open a shell window, and go under the ivyrep example directory.
Then, on the command prompt, just run ant :
<div class="shell"><pre>
I:\ivyrep>ant
Buildfile: build.xml

resolve:
:: Ivy 1.0-rc3 - 20050421161206 :: http://ivy.jayasoft.org/ ::
no configuration file found, using default...
:: resolving dependencies :: jayasoft/ivyrep-example-working@xmen
        confs: [default]
downloading http://www.ibiblio.org/maven/commons-cli/jars/commons-cli-1.0.jar(1.0) ...
...... (31kB)
        [SUCCESSFUL ] apache/commons-cli-1.0/commons-cli.jar[jar] (1437ms)
downloading http://www.ibiblio.org/maven/commons-lang/jars/commons-lang-2.0.jar(2.0) ...
..................................... (165kB)
        [SUCCESSFUL ] apache/commons-lang-2.0/commons-lang.jar[jar] (5640ms)
downloading http://www.ibiblio.org/maven/commons-logging/jars/commons-logging-1.0.jar(1.0) ...
..... (21kB)
        [SUCCESSFUL ] apache/commons-logging-1.0/commons-logging.jar[jar] (1250ms)
:: resolution report ::
        :: evicted modules:
        apache/commons-lang-1.0 by [apache/commons-lang-2.0] in [default]
        ---------------------------------------------------------------------
        |                  |            modules            ||   artifacts   |
        |       conf       | number| search|dwnlded|evicted|| number|dwnlded|
        ---------------------------------------------------------------------
        |      default     |   4   |   3   |   2   |   1   ||   3   |   3   |
        ---------------------------------------------------------------------
:: retrieving :: jayasoft/ivyrep-example
        confs: [default]
        3 artifacts copied, 0 already retrieved

run:
    [mkdir] Created dir: I:\ivyrep\build
    [javac] Compiling 1 source file to I:\ivyrep\build
     [java] standard message : hello ivy !
     [java] capitalized by org.apache.commons.lang.WordUtils : Hello Ivy !

BUILD SUCCESSFUL
Total time: 16 seconds</pre></div>
<h1>What happened ?</h1>
Without any configuration, other than it's default configuration, ivy uses the ivyrep resolver. This resolver looks for ivy files on <a href="./ivy/ivyrep">ivyrep</a>,
and for artifacts on ibiblio. That's what happened here. <br/><br/>
The resolve task has found an <a href="http://ivyrep.jayasoft.org/apache/commons-cli/ivy-1.0.xml">ivy file on ivyrep for commons-cli 1.0</a>.
This ivy file indicates that commons-cli 1.0 depends on commons-lang 1.0 and commons-logging 1.0.<br/><br/>
The resolve task detects the conflict between the revision 2.0 of commons-lang that is asked in the ivy above, and
the revision 1.0 required in commons-cli. With no particular conflict manager, the 2.0 is selected, and the 1.0 is evicted.
The 1.0 being evicted, it is not downloaded at all.<br/><br/>
The resolve task has then downloaded the commons-cli 1.0, commons-logging 1.0 and commons-lang.jar 2.0 files from ibiblioand put them to the ivy cache. <br/>
Then the retrieve task has copied them in the default library directory of the project : the lib dir.<br>
Some will say that the task was long to achieve. Yes, it's true it was, but it has downloaded from the internet the needed files. Let's try to run it again :
<div class="shell"><pre>
I:\ivyrep>ant
Buildfile: build.xml

resolve:
:: Ivy 1.0-rc3 - 20050421161206 :: http://ivy.jayasoft.org/ ::
no configuration file found, using default...
:: resolving dependencies :: jayasoft/ivyrep-example-working@xmen
        confs: [default]
:: resolution report ::
        :: evicted modules:
        apache/commons-lang-1.0 by [apache/commons-lang-2.0] in [default]
        ---------------------------------------------------------------------
        |                  |            modules            ||   artifacts   |
        |       conf       | number| search|dwnlded|evicted|| number|dwnlded|
        ---------------------------------------------------------------------
        |      default     |   4   |   0   |   0   |   1   ||   3   |   0   |
        ---------------------------------------------------------------------
:: retrieving :: jayasoft/ivyrep-example
        confs: [default]
        0 artifacts copied, 3 already retrieved

run:
     [java] standard message : hello ivy !
     [java] capitalized by org.apache.commons.lang.WordUtils : Hello Ivy !

BUILD SUCCESSFUL
Total time: 2 seconds</pre></div>
Great ! the cache was used, no download was needed and the build was almost instantaneous.<br/><br/>
If you want to check the content of the cache, by default it is put in your user home 
in a .ivy-cache directory. Check the next tutorials to see how to configure this.<br/>
]]>
</content>
</node>
<node id="node-418">
<nodeinfo  path='ivy/doc/tutorial/defaultconf' md5_body='88233dc2a79d96548bd99bd50ed06d6a' weight='-11' depth='3' type='book' author='xavier' uid='6' created='1138106774' status='1' format='4' sticky='0' promote='0'/>
<title>Configuring default resolver</title>
<teaser>
<![CDATA[Until Ivy 1.2a, the default resolver was a simple ivyrep resolver, with only a small number of possibilities of configuration. Whenever you wanted to do something slightly more complicated than looking for ivy files on ivyrep and artifacts on ibiblio, you had to write your own ivyconf file (see other tutorials and <a href="/ivy/doc/configuration">configuration</a> reference for details about this).

Ivy 1.3 introduces a new default configuration, fully compatible pre 1.3 one, but a lot more configurable.

<h1>Concept</h1>
This default configuration mainly consists of 3 kind of repositories:]]>
</teaser>
<content>
<![CDATA[Until Ivy 1.2a, the default resolver was a simple ivyrep resolver, with only a small number of possibilities of configuration. Whenever you wanted to do something slightly more complicated than looking for ivy files on ivyrep and artifacts on ibiblio, you had to write your own ivyconf file (see other tutorials and <a href="/ivy/doc/configuration">configuration</a> reference for details about this).

Ivy 1.3 introduces a new default configuration, fully compatible pre 1.3 one, but a lot more configurable.

<h1>Concept</h1>
This default configuration mainly consists of 3 kind of repositories:
<ul>
<li>local</li> a repository which is private to the user. 
<li>shared</li> a repository which is shared between all the member of a team
<li>public</li> a public repository on which most modules can be found
</ul>

Note that if you work alone, the distinction between local and shared repository is not very important, but there are some things to know to distinguish them.

Now let's describe each of these repositories concept in more details. We will describe how they are setup physically later.
<h2>Local</h2>
The local repository is particularly useful when you want to do something without being disturb by anything else happening in the environment. This means that whenever ivy is able to locate a module in this repository it will be used, no matter of what is available in others.

For instance, if you have a module declaring a dependency on the module foo in revision latest.integration, then if a revision of foo is found in the local repository, it will be used, <em>even if a more recent revision is available in other repositories</em>. 

This may be disturbing for some of you, but imagine you have to implement a new feature on a project, and in order to achieve that you need to modify two modules: you add a new method in module foo and exploit this new method in module bar. Then if you publish the module foo to your local repository, you will be sure to get it in your bar module, even if someone else publish a new revision of foo in the shared repository (this revision not having the new method you are currently adding). 

But be careful, when you have finished your development and publish it on the shared you will have to clean your local repository to benefit from new versions published in the shared repository.

Note also that modules found in the local repository must be complete, i.e. they must provide both a module descriptor and the published artifacts. 
<h2>Shared</h2>
As its name suggest, the shared repository is aimed to be shared among a whole development team. It is a place where you can publish your team private modules for instance, and it's also a place where you can put modules not available in the public repository (sun jars, for instance), or simply not accurate (bad or incomplete module descriptors for instance).

Note that modules can be split across the shared repository and the public one: you can have the module descritor in the shared repository and the artifacts in the public one, for instance.
<h2>Public</h2>
The public repository is the place where most modules can be found, but which sometimes lack the information you need. It's usually a repository available through an internet connection only, even if this is not mandatory.
<h1>Setting up the repositories</h1>
Now that we have seen the objective of each of the three repositories, let's see how they are setup and how to configure them to fit your needs.

First, several repositories uses the same root in your filesystem. Referenced as ${ivy.default.ivy.user.dir}, this is by default the directory .ivy in your user home.

Note that several things can be done by setting ivy variable. To set them without defining your own ivyconf.xml file, you can:<ul>
<li>set an ant property before any call to ivy in your build file if you use ivy from ant</li>
<li>set an environment variable if you use ivy from the command line</li>
</ul>
For instance:
<code type="xml">
<target name="resolve">
  <property name="ivy.default.ivy.user.dir" value="/path/to/ivy/user/dir"/>
  <ivy:resolve />
</target>
</code>

Now we will show how to override default values for the different kind of repositories, note that you can find what are these default values below in the detail of the default configuration.
<h2>Local</h2>
By default, the local repository lies in ${ivy.default.ivy.user.dir}/local. This is usually a good place, but you may want to modify it however. No problem, you just have to set the following ivy variable to the directory you want to use: <code>ivy.local.default.root</code>. For instance:
<code>ivy.local.default.root=/opt/ivy/repository/local</code>.

If you already have something you would like to use as your local repository, you may also want to modify the layout of this repository. Once again, two variables are available for that:
<code>ivy.local.default.ivy.pattern</code> gives the pattern to find ivy files
<code>ivy.local.default.artifact.pattern</code> gives the pattern to find artifacts
For example:
<code>
ivy.local.default.root=/opt/ivy/repository/local
ivy.local.default.ivy.pattern=[module]/[revision]/ivy.xml
ivy.local.default.artifact.pattern=[module]/[revision]/[artifact].[ext]
</code>
<h2>Shared</h2>
By default, the shared repository lies in ${ivy.default.ivy.user.dir}/shared. This is fine if you work alone, but the shared repository is supposed to be, mmm, shared ! So changing this directory is often required, and it is usually modified to point to a shared directory. You can use <code>ivy.shared.default.root</code> variable to specify in a new directory. Moreover, you can also configure the layout with variables similar to the one for the local repository:
<code>ivy.shared.default.ivy.pattern</code> gives the pattern to find ivy files
<code>ivy.shared.default.artifact.pattern</code> gives the pattern to find artifacts
For example:
<code>
ivy.shared.default.root=/opt/ivy/repository/shared
ivy.shared.default.ivy.pattern=[organisation]/[module]/[revision]/ivy.xml
ivy.shared.default.artifact.pattern=[organisation]/[module]/[revision]/[artifact].[ext]
</code>

<h2>Public</h2>
By default, the public repository is ivyrep. To change the setting of this resolver, you can use the standard way to configure ivyrep:
<code>ivy.ivyrep.default.ivy.root</code> specify the root for ivy files
<code>ivy.ivyrep.default.ivy.pattern</code> specify the layout for ivy files
<code>ivy.ivyrep.default.artifact.root</code> specify the root for artifacts
<code>ivy.ivyrep.default.artifact.pattern</code> specify the layout for artifacts
For instance:
<code>
ivy.ivyrep.default.ivy.root=http://myserver/ivy/
ivy.ivyrep.default.artifact.root=http://myserver/ivy/
</code>

<h1>Going further</h1>
OK, so we have seen how to easily change the settings of the three main repositories. But what if I want my shared repository is on a web server ? What if the public repository is not compatible with ivyrep ? What if ... 

Everything can be changed in the default configuration, for sure, you can even do your own configuration. But you can also benefit from a part of the default configuration without writing a complete one.

But before explaining how, you will need to have a quick overview of how ivy is configured by default.

By default, ivy is configured using an ivyconf.xml which is packaged in the ivy jar. Here is this ivyconf file:
<code type="xml">
<ivyconf>
  <conf defaultResolver="default"/>
  <include url="${ivy.default.conf.dir}/ivyconf-public.xml"/>
  <include url="${ivy.default.conf.dir}/ivyconf-shared.xml"/>
  <include url="${ivy.default.conf.dir}/ivyconf-local.xml"/>
  <include url="${ivy.default.conf.dir}/ivyconf-main-chain.xml"/>
  <include url="${ivy.default.conf.dir}/ivyconf-default-chain.xml"/>
</ivyconf>
</code>
OK, so not much info here, except a lot of inclusions. These inclusions have been done on purpose so that you can easily change only one part of the ivyconf and benefit of the rest easily. For example, if you want to define your own public resolver, you will just have to configure ivy with an ivyconf like that:
<code type="xml">
<ivyconf>
  <conf defaultResolver="default"/>
  <include url="http://myserver/ivy/myivyconf-public.xml"/>
  <include url="${ivy.default.conf.dir}/ivyconf-shared.xml"/>
  <include url="${ivy.default.conf.dir}/ivyconf-local.xml"/>
  <include url="${ivy.default.conf.dir}/ivyconf-main-chain.xml"/>
  <include url="${ivy.default.conf.dir}/ivyconf-default-chain.xml"/>
</ivyconf>
</code>
Note that only the ivyconf-public inclusion has changed to include a home made public resolver. Note also that this can be used like that thanks to the fact that ${ivy.default.conf.dir} is a variable which is always set to the place where ivy default configuration files are (i.e. packaged in the jar).
To finish this example, you for sure have to write your own ivyconf file for defining your own public resolver. For instance:
<code type="xml">
<ivyconf>
  <resolvers>
    <filesystem name="public">
      <ivy pattern="/path/to/my/public/rep/[organisation]/[module]/ivy-[revision].xml" />
      <artifact pattern="/path/to/my/public/rep/[organisation]/[module]/[artifact]-[revision].[ext]" />
    </filesystem>
  </resolvers>
</ivyconf>
</code>
No the last thing you will need in order to properly take advantage of the default configuration is the content of each included ivyconf file:
<strong>ivyconf-public.xml</strong>
<code type="xml">
<ivyconf>
  <resolvers>
    <ivyrep name="public"/>
  </resolvers>
</ivyconf>
</code>
<strong>ivyconf-shared.xml</strong>
<code type="xml">
<ivyconf>
  <property name="ivy.shared.default.root"             value="${ivy.default.ivy.user.dir}/shared" override="false"/>
  <property name="ivy.shared.default.ivy.pattern"      value="[organisation]/[module]/[revision]/[type]s/[artifact].[ext]" override="false"/>
  <property name="ivy.shared.default.artifact.pattern" value="[organisation]/[module]/[revision]/[type]s/[artifact].[ext]" override="false"/>
  <resolvers>
    <filesystem name="shared">
      <ivy pattern="${ivy.shared.default.root}/${ivy.shared.default.ivy.pattern}" />
      <artifact pattern="${ivy.shared.default.root}/${ivy.shared.default.artifact.pattern}" />
    </filesystem>
  </resolvers>
</ivyconf>
</code>
<strong>ivyconf-local.xml</strong>
<code type="xml">
<ivyconf>
  <property name="ivy.local.default.root"             value="${ivy.default.ivy.user.dir}/local" override="false"/>
  <property name="ivy.local.default.ivy.pattern"      value="[organisation]/[module]/[revision]/[type]s/[artifact].[ext]" override="false"/>
  <property name="ivy.local.default.artifact.pattern" value="[organisation]/[module]/[revision]/[type]s/[artifact].[ext]" override="false"/>
  <resolvers>
    <filesystem name="local">
      <ivy pattern="${ivy.local.default.root}/${ivy.local.default.ivy.pattern}" />
      <artifact pattern="${ivy.local.default.root}/${ivy.local.default.artifact.pattern}" />
    </filesystem>
  </resolvers>
</ivyconf>
</code>
<strong>ivyconf-main-chain.xml</strong>
<code type="xml">
<ivyconf>
  <resolvers>
    <chain name="main" dual="true">
      <resolver ref="shared"/>
      <resolver ref="public"/>
    </chain>
  </resolvers>
</ivyconf>
</code>
<strong>ivyconf-default-chain.xml</strong>
<code type="xml">
<ivyconf>
  <resolvers>
    <chain name="default" returnFirst="true">
      <resolver ref="local"/>
      <resolver ref="main"/>
    </chain>
  </resolvers>
</ivyconf>
</code>

Here you are, you have enough clues to configure that the way you want... check the <a href="/ivy/doc/configuration">configuration documentation</a> to see if what you want to do is possible, and go ahead !]]>
</content>
</node>
<node id="node-37">
<nodeinfo  path='ivy/doc/tutorial/multiple' md5_body='c4a4c78f2da52e173e75d623705a4095' weight='-10' depth='3' type='book' author='admin' uid='1' created='1117212448' status='1' format='3' sticky='0' promote='1'/>
<title>Multiple Resolvers</title>
<teaser>
<![CDATA[This example is an illustration of how artefacts can be retreived by multiple resolvers.
Using multiple resolvers is very important when using continous integration. 
Indeed, in such environements, you can use multiple repositories and so multiple resolvers to retreive both released versions of projects than continous integrated versions produced for example with cruise-control.
In our example, we will just show how to use two resolvers, one on a local repository and one using ibiblio repository.

<h1>project description</h1>
<h2>the project : chained-resolvers</h2>
The project is very simple and contains only one test class : example.Hello<br/>
It depends on two libraries apache commons-lang and a little test library (sources are included in jar file). 
The test library is used by the project to uppercase a string, and commons-lang is used to capitalize the same string.

Here is the content of the project :
<ul>
  <li>build.xml : the ant build file for the project</li>
  <li>ivy.xml : the ivy project file</li>
  <li>src\example\Hello.java : the only class of the project</li>
</ul>
Take a look at it's <b>ivy.xml</b> file :
<!-- converted by xmlverbatim.xsl 1.1, (c) O. Becker -->
<div class="ivy-file"><!-- converted by xmlverbatim.xsl 1.1, (c) O. Becker -->
<div class="xmlverb-default">&lt;<span class="xmlverb-element-name">ivy-module</span> <span class="xmlverb-attr-name">version</span>="<span class="xmlverb-attr-content">1.0</span>"&gt;<span class="xmlverb-text">]]>
</teaser>
<content>
<![CDATA[This example is an illustration of how artefacts can be retreived by multiple resolvers.
Using multiple resolvers is very important when using continous integration. 
Indeed, in such environements, you can use multiple repositories and so multiple resolvers to retreive both released versions of projects than continous integrated versions produced for example with cruise-control.
In our example, we will just show how to use two resolvers, one on a local repository and one using ibiblio repository.

<h1>project description</h1>
<h2>the project : chained-resolvers</h2>
The project is very simple and contains only one test class : example.Hello<br/>
It depends on two libraries apache commons-lang and a little test library (sources are included in jar file). 
The test library is used by the project to uppercase a string, and commons-lang is used to capitalize the same string.

Here is the content of the project :
<ul>
  <li>build.xml : the ant build file for the project</li>
  <li>ivy.xml : the ivy project file</li>
  <li>src\example\Hello.java : the only class of the project</li>
</ul>
Take a look at it's <b>ivy.xml</b> file :
<!-- converted by xmlverbatim.xsl 1.1, (c) O. Becker -->
<div class="ivy-file"><!-- converted by xmlverbatim.xsl 1.1, (c) O. Becker -->
<div class="xmlverb-default">&lt;<span class="xmlverb-element-name">ivy-module</span> <span class="xmlverb-attr-name">version</span>="<span class="xmlverb-attr-content">1.0</span>"&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">info</span> <span class="xmlverb-attr-name">organisation</span>="<span class="xmlverb-attr-content">jayasoft</span>" <span class="xmlverb-attr-name">module</span>="<span class="xmlverb-attr-content">chained-resolvers</span>" /&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">dependencies</span>&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">dependency</span> <span class="xmlverb-attr-name">org</span>="<span class="xmlverb-attr-content">apache</span>" <span class="xmlverb-attr-name">name</span>="<span class="xmlverb-attr-content">commons-lang</span>" <span class="xmlverb-attr-name">rev</span>="<span class="xmlverb-attr-content">2.0</span>" /&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">dependency</span> <span class="xmlverb-attr-name">name</span>="<span class="xmlverb-attr-content">test</span>" <span class="xmlverb-attr-name">rev</span>="<span class="xmlverb-attr-content">1.0</span>" /&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;/<span class="xmlverb-element-name">dependencies</span>&gt;<span class="xmlverb-text"><br>
</span>&lt;/<span class="xmlverb-element-name">ivy-module</span>&gt;<br>
</div></div>
As we expect, the ivy file declares to be dependent on the two libraries that the project use : apache commons-lang.jar and test.jar.

<h2>the <b>ivy</b> configuration</h2>
The ivy configuration is made in the config directory it contains only one file : ivyconf.xml.

Let's analyse it.
<!-- converted by xmlverbatim.xsl 1.1, (c) O. Becker -->
<div class="xmlverb-default">&lt;<span class="xmlverb-element-name">ivyconf</span>&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">conf</span> <span class="xmlverb-attr-name">defaultResolver</span>="<span class="xmlverb-attr-content">chain-example</span>" /&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">resolvers</span>&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">chain</span> <span class="xmlverb-attr-name">name</span>="<span class="xmlverb-attr-content">chain-example</span>"&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">filesystem</span> <span class="xmlverb-attr-name">name</span>="<span class="xmlverb-attr-content">libraries</span>"&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">artifact</span> <span class="xmlverb-attr-name">pattern</span>="<span class="xmlverb-attr-content">${ivy.conf.dir}/repository/[artifact]-[revision].[type]</span>" /&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;/<span class="xmlverb-element-name">filesystem</span>&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">ibiblio</span> <span class="xmlverb-attr-name">name</span>="<span class="xmlverb-attr-content">ibiblio</span>" /&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;/<span class="xmlverb-element-name">chain</span>&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;</span>&lt;/<span class="xmlverb-element-name">resolvers</span>&gt;<span class="xmlverb-text"><br>
</span>&lt;/<span class="xmlverb-element-name">ivyconf</span>&gt;<br></div>
<h2>the <b>conf</b> tag</h2>
This tag initializes ivy with some parameters. Here only one is used, the name of the resolver to use by default.

<h2>the <b>resolvers</b> tag</h2>
Under this tag, we can find the description of the resolvers that ivy will use.
In our example, we have only one resolver, called "chain-example", which is quite special as it defines a list (a chain) of resolvers.
The resolvers put in the chain are : 
<ul>
  <li>libraries : it is a file resolver. This one is configured to look for artefacts in the "repository" sub directory of the directory that contains the ivyconf.xml file.</li>
  <li>ibiblio : this resolver is a special one. It looks in the ibiblio maven repository to retreive the libraries.</li>
</ul>

<h1>walkthrough</h1>
<div class="step">
<h2>step 1 : preparation</h2>
Open a DOS or shell window, and go to the "chained-resolvers" directory.
</div>
<div class="step">
<h2>step 2 : clean directory tree</h2>
On the prompt type : ant<br>
This will clean up the entire project directory tree and ivy cache. You can do it each time you want to clean up this example.
</div>
<div class="step">
<h2>step 3 : run the project</h2>
Goto chainedresolvers-project directory. And simply run <b>ant</b>.
<div class="shell"><pre>I:\chained-resolvers\chainedresolvers-project>ant
Buildfile: build.xml

configure:
:: Ivy 1.0-rc3 - 20050421161206 :: http://ivy.jayasoft.org/ ::

resolve:
:: resolving dependencies :: jayasoft/chained-resolvers-working@xmen
        confs: [default]
downloading http://www.ibiblio.org/maven/commons-lang/jars/commons-lang-2.0.jar(2.0) ...
.................................... (165kB)
        [SUCCESSFUL ] apache/commons-lang-2.0/commons-lang.jar[jar] (5390ms)
downloading file:/I:/chained-resolvers/config/repository/test-1.0.jar(1.0) ...
. (1kB)
        [SUCCESSFUL ] jayasoft/test-1.0/test.jar[jar] (16ms)
:: resolution report ::
        ---------------------------------------------------------------------
        |                  |            modules            ||   artifacts   |
        |       conf       | number| search|dwnlded|evicted|| number|dwnlded|
        ---------------------------------------------------------------------
        |      default     |   2   |   2   |   0   |   0   ||   2   |   2   |
        ---------------------------------------------------------------------
:: retrieving :: jayasoft/chained-resolvers
        confs: [default]
        2 artifacts copied, 0 already retrieved

run:
    [mkdir] Created dir: I:\chained-resolvers\chainedresolvers-project\build
    [javac] Compiling 1 source file to I:\chained-resolvers\chainedresolvers-project\build
     [java] standard message :example world !
     [java] capitalized by org.apache.commons.lang.WordUtils : Example World !
     [java] upperCased by test.StringUtils : EXAMPLE WORLD !

BUILD SUCCESSFUL
Total time: 9 seconds</pre></div></div>
We can see in the log of the resolve task, that the two dependencies have been retrieved (2 artifacts) and copied to the ivy cache directory (2 downloaded).
The run target succeed in using both commons-lang.jar comming from ibiblio repository and test.jar comming from the local repository.
]]>
</content>
</node>
<node id="node-38">
<nodeinfo  path='ivy/doc/tutorial/dual' md5_body='268a607f2be85e6cd2336a44a592e624' weight='-8' depth='3' type='book' author='admin' uid='1' created='1117212647' status='1' format='3' sticky='0' promote='1'/>
<title>Dual Resolver</title>
<teaser>
<![CDATA[This tutorial presents the use of the DualResolver, a feature introduced in the version 0.6 of Ivy.<br/><br/>

Dual Resolver is used when ivy files can be found in a repository while artifacts are in another. It is 
especially useful to use full power of ivy (including transitive dependencies) with the 
ibiblio repository for artifacts. The problem with the maven ibiblio repository is that it does not 
contain ivy files. Since transitive dependencies are based upon ivy files, using the ibiblio resolver does 
not permit to use transitive dependencies.<br/><br/>

The solution to this problem is to store your own repository only for ivy files, and use ibiblio
for artifacts. That's what is done in this tutorial.<br/><br/>

<h1>project description</h1>
Let's have a look at the src/example/dual directory in your ivy distribution.<br/>
It contains a build file and 3 directories:
<ul>
<li>config: contains the ivy configuration file</li>
<li>repository: a sample repository of ivy files</li>
<li>project: the project making use of ivy with dual resolver</li>
</ul>
<br/>

<h2>the dual project</h2>
The project is very simple and contains only one test class : example.Hello<br/>
It depends on two libraries: apache commons-lang and apache commons-httpclient.

Here is the content of the project :
<ul>
  <li>build.xml : the ant build file for the project</li>
  <li>ivy.xml : the ivy project file</li>
  <li>src\example\Hello.java : the only class of the project</li>
</ul>
Take a look at it's <b>ivy.xml</b> file :
<!-- converted by xmlverbatim.xsl 1.1, (c) O. Becker -->
<div class="xmlverb-default">&lt;<span class="xmlverb-element-name">ivy-module</span> <span class="xmlverb-attr-name">version</span>="<span class="xmlverb-attr-content">1.0</span>"&gt;<span class="xmlverb-text">]]>
</teaser>
<content>
<![CDATA[This tutorial presents the use of the DualResolver, a feature introduced in the version 0.6 of Ivy.<br/><br/>

Dual Resolver is used when ivy files can be found in a repository while artifacts are in another. It is 
especially useful to use full power of ivy (including transitive dependencies) with the 
ibiblio repository for artifacts. The problem with the maven ibiblio repository is that it does not 
contain ivy files. Since transitive dependencies are based upon ivy files, using the ibiblio resolver does 
not permit to use transitive dependencies.<br/><br/>

The solution to this problem is to store your own repository only for ivy files, and use ibiblio
for artifacts. That's what is done in this tutorial.<br/><br/>

<h1>project description</h1>
Let's have a look at the src/example/dual directory in your ivy distribution.<br/>
It contains a build file and 3 directories:
<ul>
<li>config: contains the ivy configuration file</li>
<li>repository: a sample repository of ivy files</li>
<li>project: the project making use of ivy with dual resolver</li>
</ul>
<br/>

<h2>the dual project</h2>
The project is very simple and contains only one test class : example.Hello<br/>
It depends on two libraries: apache commons-lang and apache commons-httpclient.

Here is the content of the project :
<ul>
  <li>build.xml : the ant build file for the project</li>
  <li>ivy.xml : the ivy project file</li>
  <li>src\example\Hello.java : the only class of the project</li>
</ul>
Take a look at it's <b>ivy.xml</b> file :
<!-- converted by xmlverbatim.xsl 1.1, (c) O. Becker -->
<div class="xmlverb-default">&lt;<span class="xmlverb-element-name">ivy-module</span> <span class="xmlverb-attr-name">version</span>="<span class="xmlverb-attr-content">1.0</span>"&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">info</span> <span class="xmlverb-attr-name">organisation</span>="<span class="xmlverb-attr-content">jayasoft</span>" <span class="xmlverb-attr-name">module</span>="<span class="xmlverb-attr-content">hello-ivy</span>" /&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">dependencies</span>&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">dependency</span> <span class="xmlverb-attr-name">org</span>="<span class="xmlverb-attr-content">apache</span>" <span class="xmlverb-attr-name">name</span>="<span class="xmlverb-attr-content">commons-httpclient</span>" <span class="xmlverb-attr-name">rev</span>="<span class="xmlverb-attr-content">2.0.2</span>" /&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">dependency</span> <span class="xmlverb-attr-name">org</span>="<span class="xmlverb-attr-content">apache</span>" <span class="xmlverb-attr-name">name</span>="<span class="xmlverb-attr-content">commons-lang</span>" <span class="xmlverb-attr-name">rev</span>="<span class="xmlverb-attr-content">2.0</span>" /&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;/<span class="xmlverb-element-name">dependencies</span>&gt;<span class="xmlverb-text"><br>
</span>&lt;/<span class="xmlverb-element-name">ivy-module</span>&gt;<br>
</div>
<br/>
As you can see, nothing special here... Indeed, it's the philosophy of ivy to keep ivy files
independent of the way dependencies are retrieved.

<h2>the <b>ivy</b> configuration</h2>
The ivy configuration is made in the config directory it contains only one file : ivyconf.xml.

Let's analyse it.
<!-- converted by xmlverbatim.xsl 1.1, (c) O. Becker -->
<div class="xmlverb-default">&lt;<span class="xmlverb-element-name">ivyconf</span>&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">conf</span> <span class="xmlverb-attr-name">defaultResolver</span>="<span class="xmlverb-attr-content">dual-example</span>" /&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">resolvers</span>&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">dual</span> <span class="xmlverb-attr-name">name</span>="<span class="xmlverb-attr-content">dual-example</span>"&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">filesystem</span> <span class="xmlverb-attr-name">name</span>="<span class="xmlverb-attr-content">ivys</span>"&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">ivy</span> <span class="xmlverb-attr-name">pattern</span>="<span class="xmlverb-attr-content">${ivy.conf.dir}/../repository/[module]-ivy-[revision].xml</span>" /&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;/<span class="xmlverb-element-name">filesystem</span>&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">ibiblio</span> <span class="xmlverb-attr-name">name</span>="<span class="xmlverb-attr-content">ibiblio</span>" /&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;/<span class="xmlverb-element-name">dual</span>&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;</span>&lt;/<span class="xmlverb-element-name">resolvers</span>&gt;<span class="xmlverb-text"><br>
</span>&lt;/<span class="xmlverb-element-name">ivyconf</span>&gt;<br>
</div>
<br/>
Here we configure one resolver, the default one, which is a dual resolver. This dual resolver
has two sub resolvers : the first is what is called the "ivy" resolver of the dual resolver, and
the second one is what is called the "artifact" resolver. It is important that the dual resolver exactly
has two sub resolvers in this given order.<br/>
The ivy resolver, here a filesystem one, is used only to find ivy files. The configuration given in this resolver
says that all ivy files are in the same directory, named like that: [module]-ivy-[revision].xml. If
we check the repository directory, we can confirm that it contains a file named commons-httpclient-ivy-2.0.2.xml.
It fulfills the given pattern and will thus be find by this resolver.<br/>
The artifact resolver is simply an ibiblio one, and will thus try to find required artifacts
in the maven ibiblio repository.<br/>

<h1>walkthrough</h1>
<div class="step">
<h2>step 1 : preparation</h2>
Open a DOS or shell window, and go to the "dual" directory.
</div>
<div class="step">
<h2>step 2 : clean up</h2>
On the prompt type : ant<br>
This will clean up the entire project directory tree (compiled classes and retrieved libs) and ivy cache. 
You can do it each time you want to clean up this example.
</div>
<div class="step">
<h2>step 3 : run the project</h2>
Goto project directory. And simply run <b>ant</b>.
<div class="shell"><pre>
I:\dual\project>ant
Buildfile: build.xml

configure:
:: Ivy 1.0-rc3 - 20050421161206 :: http://ivy.jayasoft.org/ ::

resolve:
:: resolving dependencies :: jayasoft/hello-ivy-working@xmen
        confs: [default]
downloading http://www.ibiblio.org/maven/commons-lang/jars/commons-lang-2.0.jar(2.0) ...
.....
.........
..........
...........
. (165kB)
        [SUCCESSFUL ] apache/commons-lang-2.0/commons-lang.jar[jar] (8032ms)
downloading http://www.ibiblio.org/maven/commons-httpclient/jars/commons-httpclient-2.0.2.jar(2.0.2) ...
...........
......
....
..........
............
........ (220kB)
        [SUCCESSFUL ] apache/commons-httpclient-2.0.2/commons-httpclient.jar[jar] (10031ms)
downloading http://www.ibiblio.org/maven/commons-logging/jars/commons-logging-1.0.4.jar(1.0.4) ...
......... (37kB)
        [SUCCESSFUL ] apache/commons-logging-1.0.4/commons-logging.jar[jar] (1469ms)
:: resolution report ::
        ---------------------------------------------------------------------
        |                  |            modules            ||   artifacts   |
        |       conf       | number| search|dwnlded|evicted|| number|dwnlded|
        ---------------------------------------------------------------------
        |      default     |   3   |   3   |   1   |   0   ||   3   |   3   |
        ---------------------------------------------------------------------
:: retrieving :: jayasoft/hello-ivy
        confs: [default]
        3 artifacts copied, 0 already retrieved

run:
    [mkdir] Created dir: I:\dual\project\build
    [javac] Compiling 1 source file to I:\dual\project\build
     [java] standard message : hello ivy !
     [java] capitalized by org.apache.commons.lang.WordUtils : Hello Ivy !
     [java] head status code with httpclient: 200
     [java] now check if httpclient dependency on commons-logging has been realized
     [java] found logging class in classpath: interface org.apache.commons.logging.Log

BUILD SUCCESSFUL
Total time: 24 seconds
</pre></div></div>
<br/>
As you can see, ivy not only downloaded commons-lang and commons-httpclient, but also
commons-logging. Indeed, commons-logging is a dependency of httpclient, as we can see
in the httpclient ivy file found in the repository directory:
<!-- converted by xmlverbatim.xsl 1.1, (c) O. Becker -->
<div class="xmlverb-default">&lt;<span class="xmlverb-element-name">ivy-module</span> <span class="xmlverb-attr-name">version</span>="<span class="xmlverb-attr-content">1.0</span>"&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">info</span> <span class="xmlverb-attr-name">organisation</span>="<span class="xmlverb-attr-content">apache</span>" <span class="xmlverb-attr-name">module</span>="<span class="xmlverb-attr-content">commons-httpclient</span>" <span class="xmlverb-attr-name">revision</span>="<span class="xmlverb-attr-content">2.0.2</span>" <span class="xmlverb-attr-name">status</span>="<span class="xmlverb-attr-content">release</span>" <span class="xmlverb-attr-name">publication</span>="<span class="xmlverb-attr-content">20041010174300</span>" /&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">dependencies</span>&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">dependency</span> <span class="xmlverb-attr-name">name</span>="<span class="xmlverb-attr-content">commons-logging</span>" <span class="xmlverb-attr-name">rev</span>="<span class="xmlverb-attr-content">1.0.4</span>" <span class="xmlverb-attr-name">conf</span>="<span class="xmlverb-attr-content">default</span>" /&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;/<span class="xmlverb-element-name">dependencies</span>&gt;<span class="xmlverb-text"><br>
</span>&lt;/<span class="xmlverb-element-name">ivy-module</span>&gt;<br>
</div>
<br/>
So everything worked well, ivy file has been found in the repository directory and 
artifacts have been downloaded from ibiblio. You now just have to write ivy files for the module
you often use, and they will be much easier to use... And imagine a world in which each module
delivers also an ivy file. Since it is independent of the way to retrieve dependencies, it
would made all dependencies handling much easier, wouldn't it ?

]]>
</content>
</node>
<node id="node-39">
<nodeinfo  path='ivy/doc/tutorial/multi-project' md5_body='26750e3a4019157e1c55babb9cf1cf24' weight='-5' depth='3' type='book' author='admin' uid='1' created='1117212778' status='1' format='3' sticky='0' promote='1'/>
<title>Project dependencies</title>
<teaser>
<![CDATA[This example is an illustration of dependency between two project.

The dependant project declares that it uses the standalone one.
We will illustrate two things : 
<ul>
  <li>public libraries declared by standalone project will automatically be recovered by the dependant project</li>
  <li>the dependant project will retrieve the "latest" version of the standalone project</li>
</ul>
<h1>the projects used</h1>
<h2>the project : standalone</h2>
The standalone project is very simple.
It depends on the apache library commons-lang and contains only one class : standalone.Main which provides two services :
<ul>
  <li>return the version of the project</li>
  <li>capitalize a string using org.apache.commons.lang.WordUtils.capitalizeFully</li>
</ul>
Here is the content of the project :
<ul>
  <li>build.xml : the ant build file for the project</li>
  <li>ivy.xml : the ivy project file</li>
  <li>src\standalone\Main.java : the only class of the project</li>
</ul>
Take a look at it's <b>ivy.xml</b> file :
<!-- converted by xmlverbatim.xsl 1.1, (c) O. Becker -->
<div class="ivy-file"><div class="xmlverb-default">&lt;<span class="xmlverb-element-name">ivy-module</span> <span class="xmlverb-attr-name">version</span>="<span class="xmlverb-attr-content">1.0</span>"&gt;<span class="xmlverb-text">]]>
</teaser>
<content>
<![CDATA[This example is an illustration of dependency between two project.

The dependant project declares that it uses the standalone one.
We will illustrate two things : 
<ul>
  <li>public libraries declared by standalone project will automatically be recovered by the dependant project</li>
  <li>the dependant project will retrieve the "latest" version of the standalone project</li>
</ul>
<h1>the projects used</h1>
<h2>the project : standalone</h2>
The standalone project is very simple.
It depends on the apache library commons-lang and contains only one class : standalone.Main which provides two services :
<ul>
  <li>return the version of the project</li>
  <li>capitalize a string using org.apache.commons.lang.WordUtils.capitalizeFully</li>
</ul>
Here is the content of the project :
<ul>
  <li>build.xml : the ant build file for the project</li>
  <li>ivy.xml : the ivy project file</li>
  <li>src\standalone\Main.java : the only class of the project</li>
</ul>
Take a look at it's <b>ivy.xml</b> file :
<!-- converted by xmlverbatim.xsl 1.1, (c) O. Becker -->
<div class="ivy-file"><div class="xmlverb-default">&lt;<span class="xmlverb-element-name">ivy-module</span> <span class="xmlverb-attr-name">version</span>="<span class="xmlverb-attr-content">1.0</span>"&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">info</span> <span class="xmlverb-attr-name">organisation</span>="<span class="xmlverb-attr-content">jayasoft</span>" <span class="xmlverb-attr-name">module</span>="<span class="xmlverb-attr-content">standalone</span>" /&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">dependencies</span>&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">dependency</span> <span class="xmlverb-attr-name">org</span>="<span class="xmlverb-attr-content">apache</span>" <span class="xmlverb-attr-name">name</span>="<span class="xmlverb-attr-content">commons-lang</span>" <span class="xmlverb-attr-name">rev</span>="<span class="xmlverb-attr-content">2.0</span>" /&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;/<span class="xmlverb-element-name">dependencies</span>&gt;<span class="xmlverb-text"><br>
</span>&lt;/<span class="xmlverb-element-name">ivy-module</span>&gt;<br>
</div></div>

The ivy dependency file declares only one dependency on apache commons-lang library which by default is a public dependency (see <a href="/ivy/doc/ivyfile">ivy file definition</a>).
<h2>the project : depending</h2>
The project depending is very simple too. It declares only one dependency on the latest version of the standalone project and it contains only one class depending.Main which make 2 things :
<ul>
  <li>getting the version of the standalone project throw a call to standalone.Main.getVersion()</li>
  <li>transform a string throw a call to standalone.Main.capitalizeWords(str)</li>
</ul>
Take a look at it's <b>ivy.xml</b> file :
<div class="ivy-file"><!-- converted by xmlverbatim.xsl 1.1, (c) O. Becker -->
<div class="xmlverb-default">&lt;<span class="xmlverb-element-name">ivy-module</span> <span class="xmlverb-attr-name">version</span>="<span class="xmlverb-attr-content">1.0</span>"&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">info</span> <span class="xmlverb-attr-name">organisation</span>="<span class="xmlverb-attr-content">jayasoft</span>" <span class="xmlverb-attr-name">module</span>="<span class="xmlverb-attr-content">depending</span>" /&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">dependencies</span>&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">dependency</span> <span class="xmlverb-attr-name">name</span>="<span class="xmlverb-attr-content">standalone</span>" <span class="xmlverb-attr-name">rev</span>="<span class="xmlverb-attr-content">latest.integration</span>" /&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;/<span class="xmlverb-element-name">dependencies</span>&gt;<span class="xmlverb-text"><br>
</span>&lt;/<span class="xmlverb-element-name">ivy-module</span>&gt;<br>
</div>
</div>

<h2>the <b>ivy</b> configuration</h2>
The ivy configuration is made in the config directory wich contains 2 files :
<ul>
  <li>ivyconf.properties : a property file</li>
  <li>ivyconf.xml : the file containing the ivy configuration</li>
</ul>

Let's analyse the ivyconf.xml file.
<!-- converted by xmlverbatim.xsl 1.1, (c) O. Becker -->
<div class="xmlverb-default">&lt;<span class="xmlverb-element-name">ivyconf</span>&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">properties</span> <span class="xmlverb-attr-name">file</span>="<span class="xmlverb-attr-content">${ivy.conf.dir}/ivyconf.properties</span>" /&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">conf</span> <span class="xmlverb-attr-name">defaultCache</span>="<span class="xmlverb-attr-content">${ivy.conf.dir}/ivy-cache</span>" <span class="xmlverb-attr-name">defaultResolver</span>="<span class="xmlverb-attr-content">libraries</span>" /&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">resolvers</span>&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">filesystem</span> <span class="xmlverb-attr-name">name</span>="<span class="xmlverb-attr-content">projects</span>"&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">artifact</span> <span class="xmlverb-attr-name">pattern</span>="<span class="xmlverb-attr-content">${repository.dir}/[artifact]-[revision].[ext]</span>" /&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">ivy</span> <span class="xmlverb-attr-name">pattern</span>="<span class="xmlverb-attr-content">${repository.dir}/[module]-[revision].xml</span>" /&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;/<span class="xmlverb-element-name">filesystem</span>&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">ivyrep</span> <span class="xmlverb-attr-name">name</span>="<span class="xmlverb-attr-content">libraries</span>" /&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;/<span class="xmlverb-element-name">resolvers</span>&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">modules</span>&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;<span class="xmlverb-element-name">module</span> <span class="xmlverb-attr-name">organisation</span>="<span class="xmlverb-attr-content">jayasoft</span>" <span class="xmlverb-attr-name">name</span>="<span class="xmlverb-attr-content">.*</span>" <span class="xmlverb-attr-name">resolver</span>="<span class="xmlverb-attr-content">projects</span>" /&gt;<span class="xmlverb-text"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;/<span class="xmlverb-element-name">modules</span>&gt;<span class="xmlverb-text"><br>
</span>&lt;/<span class="xmlverb-element-name">ivyconf</span>&gt;<br>
</div>
The file contains four main tags : properties, conf, resolvers and modules.
<h2>the <b>properties</b> tag</h2>
This tag only load some properties for the ivy process in the same manner as ant will do it.
<h2>the <b>conf</b> tag</h2>
This tag is in charge to initialize some parameters for ivy process.
The directory that ivy will use to cache (to store) artifacts found will be in a sub directory called ivy-cache of the directory containing the ivyconf.xml file itself.
The second parameter, tells ivy to use a resolver called "libraries" as its default resolver. As a recall, a resolver is in charge to resolve an artifact from some information like : the organisation that provides the artifact, the name of the library and the version of the library. More information can be found in the <a href="/ivy/doc/configuration">configuration documentation</a>.
<h2>the <b>resolvers</b> tag</h2>
This tag defines the resolvers to use. Here we have two resolvers defined: "projects" and "libraries".<br/>
The filesystem resolver called "projects" is able to resolve the internal dependencies wanted. <br/>
The ivyrep resolver called "libraries" is able to find dependencies on <a href="./ivy/ivyrep">ivyrep</a>.<br/>
<h2>the <b>modules</b> tag</h2>
The modules tag allows to configure which resolver should be use for which module. Here the configuration only tells to use the "projects"
resolver for all modules having for organisation "jayasoft" and any module name (.* regexp matches any module name).<br/>
For other modules (i.e. all modules not from jayasoft), since there is no special configuration, the default resolver will be used: "libraries".
<h1>walkthrough</h1>
<div class="step">
<h2>step 1 : preparation</h2>
Open a DOS or shell window, and go to the "dependance" directory.
</div>
<div class="step">
<h2>step 2 : clean directory tree</h2>
On the prompt type : ant<br>
This will clean up the entire project directory tree. You can do it each time you want to clean up this example.
</div>
<div class="step">
<h2>step 3 : publication of standalone project</h2>
Goto standalone directory  and publish the project
<div class="shell"><pre>I:\standalone>ant publish
Buildfile: build.xml

configure:
:: Ivy 1.0-rc3 - 20050421161206 :: http://ivy.jayasoft.org/ ::

resolve:
:: resolving dependencies :: jayasoft/standalone-working@xmen
        confs: [default]
downloading http://www.ibiblio.org/maven/commons-lang/jars/commons-lang-2.0.jar(2.0) ...
.................................... (165kB)
        [SUCCESSFUL ] apache/commons-lang-2.0/commons-lang.jar[jar] (6672ms)
:: resolution report ::
        ---------------------------------------------------------------------
        |                  |            modules            ||   artifacts   |
        |       conf       | number| search|dwnlded|evicted|| number|dwnlded|
        ---------------------------------------------------------------------
        |      default     |   1   |   1   |   0   |   0   ||   1   |   1   |
        ---------------------------------------------------------------------
:: retrieving :: jayasoft/standalone
        confs: [default]
        1 artifacts copied, 0 already retrieved

compile:
    [mkdir] Created dir: I:\standalone\build\classes
    [javac] Compiling 1 source file to I:\standalone\build\classes

jar:
[propertyfile] Creating new property file: I:\standalone\build\classes\version.properties
      [jar] Building jar: I:\standalone\build\standalone.jar

publish:
:: delivering :: jayasoft/standalone-working@xmen :: 1 :: release :: Wed Apr 27 08:41:47 CEST 2005
        delivering ivy file to I:\standalone/build/ivy.xml
:: publishing :: jayasoft/standalone-working@xmen
        published standalone to I:\config\repository\standalone-1.jar
        published ivy to I:\config\repository\standalone-1.xml
     [echo] project standalone released with version 1

BUILD SUCCESSFUL
Total time: 10 seconds</pre></div>
What we see here :
<ul>
</ul>
  <li>the project depends on 1 library (1 artifact)</li>
  <li>the library was not in the ivy cahe and so was downloaded (1 downloaded)</li>
  <li>the project has been released under version number 1</li>
</div>
To give more details on the publish, as you can see the call to the publish task has resulted in two main things:<br/>
- the delivery of a resolved ivy file to build/ivy.xml. This has been done because by default the publish task not only publishes
artifacts but also ivy file. So it has looked to the path where the ivy file to publish should be, using the artifactspattern: ${build.dir}/[artifact].[ext].
For an ivy file, this resolves to build/ivy.xml. Because this file does not exist, it automatically make a call to the deliver task which delivers a resolved ivy file
to this destination.<br/>
- the publication of artifact standalone and resolved ivy file to the repository. Both are mere copy of files found in the current project, more precisely in the build dir. This is
because the artifactspattern has been set to ${build.dir}/[artifact].[ext], so standalone artifact is found in build/standalone.jar and ivy file in build/ivy.xml. And because we have
asked the publish task to publish them using the "projects" resolver, these files are copied to repository\standalone-1.jar and to repository\standalone-1.xml, respecting
the artifact and ivy patterns of our configuration (see above).

<div class="step">
<h2>step 4 : running the depending project</h2>
Goto to directory depending and run ant
<div class="shell"><pre>I:\depending>ant
Buildfile: build.xml

clean:

configure:
:: Ivy 1.0-rc3 - 20050421161206 :: http://ivy.jayasoft.org/ ::

resolve:
:: resolving dependencies :: jayasoft/depending-working@xmen
        confs: [default]
        [1] jayasoft/standalone
downloading file:/I:/config/repository/standalone-1.jar(1) ...
. (1kB)
        [SUCCESSFUL ] jayasoft/standalone-1/standalone.jar[jar] (15ms)
:: resolution report ::
        ---------------------------------------------------------------------
        |                  |            modules            ||   artifacts   |
        |       conf       | number| search|dwnlded|evicted|| number|dwnlded|
        ---------------------------------------------------------------------
        |      default     |   2   |   2   |   2   |   0   ||   2   |   1   |
        ---------------------------------------------------------------------
:: retrieving :: jayasoft/depending
        confs: [default]
        2 artifacts copied, 0 already retrieved

compile:
    [mkdir] Created dir: I:\depending\build\classes
    [javac] Compiling 1 source file to I:\depending\build\classes

run:
     [java] you are using version 1 of class standalone.Main
     [java] standard message : i am depending.Main and standalone.Main will do the job for me
     [java]     [standalone.Main] capitalizing string "i am depending.Main and standalone.Main will do the job for me" 
				     using org.apache.commons.lang.WordUtils
     [java] capitalized message : I Am Depending.main And Standalone.main Will Do The Job For Me

BUILD SUCCESSFUL
Total time: 3 seconds</pre></div>
What we see here :
<ul>
  <li>the project depends on 2 libraries (2 artifacts)</li>
  <li>one of the libraries was in the cache because there was only 1 download (1 downloaded)</li>
  <li>ivy retreived the version 1 of the project standalone. The call to standalone.Main.getVersion() has returned 1. If you look in the depending/lib directory, you should see standalone-1.jar which is the artifact version 1 of the project standalone</li>
  <li>the call to standalone.Main.capitalizeWords(str) succeed, what significate that the required library were in the classpath. If you look at the lib directory, you will see that the library commons-lang-2.0.jar was retreived. This library was declared to be used by the project "standalone", so ivy get it too for the dependant project.</li>
</ul>
</div>
<div class="step">
<h2>step 5 : new version of standalone project</h2>
Like we did before in step 3, publish again the standalone project. 
This will result as a new version of the project.
<div class="shell"><pre>I:\standalone>ant publish
Buildfile: build.xml

configure:
:: Ivy 1.0-rc3 - 20050421161206 :: http://ivy.jayasoft.org/ ::

resolve:
:: resolving dependencies :: jayasoft/standalone-working@xmen
        confs: [default]
:: resolution report ::
        ---------------------------------------------------------------------
        |                  |            modules            ||   artifacts   |
        |       conf       | number| search|dwnlded|evicted|| number|dwnlded|
        ---------------------------------------------------------------------
        |      default     |   1   |   0   |   0   |   0   ||   1   |   0   |
        ---------------------------------------------------------------------
:: retrieving :: jayasoft/standalone
        confs: [default]
        0 artifacts copied, 1 already retrieved

compile:

jar:
[propertyfile] Updating property file: I:\standalone\build\classes\version.properties
      [jar] Building jar: I:\standalone\build\standalone.jar

publish:
   [delete] Deleting: I:\standalone\build\ivy.xml
:: delivering :: jayasoft/standalone-working@xmen :: 2 :: release :: Wed Apr 27 09:17:13 CEST 2005
        delivering ivy file to I:\standalone/build/ivy.xml
:: publishing :: jayasoft/standalone-working@xmen
        published standalone to I:\config\repository\standalone-2.jar
        published ivy to I:\config\repository\standalone-2.xml
     [echo] project standalone released with version 2

BUILD SUCCESSFUL
Total time: 2 seconds</pre></div>
Now if you look in your repository folder, you must find 2 version published of the standalone project.<br>
Let's look at it :
<div class="shell"><pre>I:\dependence\standalone>dir ..\config\repository /w
 Le volume dans le lecteur I s'appelle DATA
 Le numro de srie du volume est 30E5-91BA

 Rpertoire de I:\dependence\config\repository

[.]                [..]               standalone-1.jar   standalone-1.xml   standalone-2.jar   standalone-2.xml
               4 fichier(s)            3 936 octets
               2 Rp(s)   9 874 350 080 octets libres

I:\dependence\standalone></pre></div>
</div>
Ok now our repository contains two versions of the project <b>standalone</b>, other projects can refer to both versions.
<div class="step">
<h2>step 6 : depending got the new version</h2>
What do we expect about running again the depending project ? Two major things are expected : 
<ul>
  <li>retrieve the version 2 as the latest.integration version of the standalone project</li>
  <li>running the test must display version 2 of standalone project</li>
</ul>
Let's go !!!
<div class="shell"><pre>I:\depending>ant
Buildfile: build.xml

clean:
   [delete] Deleting 3 files from I:\depending
   [delete] Deleted 4 directories from I:\depending

configure:
:: Ivy 1.0-rc3 - 20050421161206 :: http://ivy.jayasoft.org/ ::

resolve:
:: resolving dependencies :: jayasoft/depending-working@xmen
        confs: [default]
        [2] jayasoft/standalone
downloading file:/I:/config/repository/standalone-2.jar(2) ...
. (1kB)
        [SUCCESSFUL ] jayasoft/standalone-2/standalone.jar[jar] (0ms)
:: resolution report ::
        ---------------------------------------------------------------------
        |                  |            modules            ||   artifacts   |
        |       conf       | number| search|dwnlded|evicted|| number|dwnlded|
        ---------------------------------------------------------------------
        |      default     |   2   |   2   |   2   |   0   ||   2   |   1   |
        ---------------------------------------------------------------------
:: retrieving :: jayasoft/depending
        confs: [default]
        2 artifacts copied, 0 already retrieved

compile:
    [mkdir] Created dir: I:\depending\build\classes
    [javac] Compiling 1 source file to I:\depending\build\classes

run:
     [java] you are using version 2 of class standalone.Main
     [java] standard message : i am depending.Main and standalone.Main will do the job for me
     [java]     [standalone.Main] capitalizing string "i am depending.Main and standalone.Main will do the job for me" 
			     using org.apache.commons.lang.WordUtils
     [java] capitalized message : I Am Depending.main And Standalone.main Will Do The Job For Me

BUILD SUCCESSFUL
Total time: 3 seconds</pre></div>
Ok we have the result expected as the run target shows that we are using the version 2 of the main class of standalone project. 
If we take a look at the resolve target results, we can see that one artifact has been downloaded to the ivy cache. 
In fact this file is the version 2 of the standalone project that was taken from the repository, you can now retrieve it in the ivy-cache directory.
</div>
]]>
</content>
</node>
<node id="node-420">
<nodeinfo  path='ivy/doc/tutorial/multiproject' md5_body='348a7763501a9d931fbd0111e2d16562' weight='-3' depth='3' type='book' author='xavier' uid='6' created='1138168095' status='1' format='4' sticky='0' promote='0'/>
<title>Using Ivy in multiple projects environment</title>
<teaser>
<![CDATA[<strong>Warning: tutorial in progress !</strong>

In the previous tutorial you have seen how to deal with dependencies between two simple projects.

This tutorial will guide you through the use of ivy in a more complete environment. All the sources of this tutorial are available in src/example/multi-project in ivy distribution (warning: the sources attached with ivy 1.3 contain an error in the common.xml file. Please use either latest build to find proper example sources or replace the common.xml file with <a href="./misc/ivy/samples/multi-project/common.xml">this one</a>).

<h1>Context</h1>]]>
</teaser>
<content>
<![CDATA[<strong>Warning: tutorial in progress !</strong>

In the previous tutorial you have seen how to deal with dependencies between two simple projects.

This tutorial will guide you through the use of ivy in a more complete environment. All the sources of this tutorial are available in src/example/multi-project in ivy distribution (warning: the sources attached with ivy 1.3 contain an error in the common.xml file. Please use either latest build to find proper example sources or replace the common.xml file with <a href="./misc/ivy/samples/multi-project/common.xml">this one</a>).

<h1>Context</h1>
Here is a 10000ft overview of the projects involved in this tutorial:
<ul>
<li>version</li> helps to identify module by a version
<li>list</li> gives a list of files in a directory (recursively)
<li>size</li> gives the total size of all files in a directory, or of a collection of files
<li>find</li> find files in a given dir or among a list of files which match a given name
<li>sizewhere</li> gives the total size of files matching a name in a directory
<li>console</li> give access to all other modules features through a simple console app
</ul>
For sure this is not aimed to demonstrate how to develop a complex app or give indication of advanced algorithm :-)

But this gives a simple understanding of how ivy can be used to develop an application divided in multitple modules.

Now, here is how these modules relate to each other:
<a href="/misc/ivy/samples/projects-dependencies-graph.jpg"><img src="/misc/ivy/samples/projects-dependencies-graph-small.jpg" alt="dependencies graph"/><br/><center><i>click to enlarge</i></center></a>

Modules in yellow are the modules described in this tutorial, and modules in blue are external dependencies (we will see how to generate this graph later in this tutorial).

As you can see, we have here a pretty interesting set of modules with dependencies between each other, each depending on the latest version of the others.

<h1>The example files</h1>
The sources for this tutorial can be found in src/example/multi-project in the ivy distribution. In this directory, you will find the following files:
<ul>
<li><a href="./misc/ivy/samples/multi-project/build.xml">build.xml</a></li>This a root build file which can be used to call targets on all modules, in the order of their dependencies (ensuring that a module is always built before any module depending on it, for instance)
<li>common
<ul>
<li><a href="./misc/ivy/samples/multi-project/common.xml">common.xml</a></li> the common build file imported by all build.xml files for each project. This build defines the targets which can be used in all projects.
<li>build.properties</li>some properties common to all projects
</ul>
</li>
<li>projects</li>
contains a directory per module, with for each
<ul>
<li>ivy.xml</li>Ivy file of the module, describing its dependencies upon other modules and / or external modules.
Example:
<code type="xml">
<ivy-module version="1.0">
    <info 
        organisation="jayasoft"
        module="find"
        status="integration"/>
    <configurations>
      <conf name="core"/>
      <conf name="standalone" extends="core"/>
    </configurations>
    <publications>
      <artifact name="find" type="jar" conf="core" />
    </publications>
    <dependencies>
      <dependency name="version" rev="latest.integration" conf="core->default" />
      <dependency name="list" rev="latest.integration" conf="core" />
      <dependency org="apache" name="commons-collections" rev="3.1" conf="core->default" />
      <dependency org="apache" name="commons-cli" rev="1.0" conf="standalone->default" />
    </dependencies>
</ivy-module>
</code>
<li>build.xml</li>The build file of the project, which consists mainly in an import of the common build file and of a module specific properties file:
<code type="xml">
<project name="find" default="compile">
	<property file="build.properties"/>
	
	<import file="${common.dir}/common.xml"/>
</project>
</code>
<li>build.properties</li>Module specific properties + properties to find the common build file
<code>
projects.dir = ${basedir}/..
wkspace.dir = ${projects.dir}/..
common.dir = ${wkspace.dir}/common
</code>
<li>src</li> the source directory with all java sources
</ul>
</ul>

Note that this doesn't demonstrate good practice for software development in general, in particular you won't find any unit test in this samples, even if we think unit testing is very important. But this isn't the aim of this tutorial.

Now that you are a bit more familiar with the structure, let's have a look at the most important part of this example: the common build file. Indeed, as you have seen all modules build files only import the common build file, and defines their dependencies in their ivy files (with which you should begin to be familiar).

So, here are some aspects of this common build file:
<h2>ivy configuration</h2>
<code type="xml">
<target name="configure">
    <!-- setup ivy default configuration with some custom info -->
    <property name="ivy.local.default.root" value="${repository.dir}/local"/>
    <property name="ivy.shared.default.root" value="${repository.dir}/shared"/>

    <!-- here is how we would have configured ivy if we had our own ivyconf file
        <ivy:configure file="${common.dir}/ivyconf.xml" />
    -->
</target>
</code>

This target configures ivy only by setting two properties: the location for the local repository and the location for the shared repository. It's the only configuration done here, since ivy 1.3 is configured by default to work in a team environment (see <a href="./ivy/tutorial/defaultconf">default configuration tutorial</a> for details about this). For sure in a real environment the shared repository location would rather be in a team shared directory (or in a more complex repository, again see the default configuration tutorial to see how to use something really different).
This target only indicates in comments how the configuration would have been done if the default configuration wasn't ok for our purpose.

<h2>resolve dependencies</h2>
<code type="xml">
<target name="resolve" depends="configure, clean-lib" description="--> retrieve dependencies with ivy">
    <mkdir dir="${lib.dir}"/> <!-- not usually necessary, ivy creates the directory IF there are dependencies -->
    <!-- this target is named resolve even if we do a retrieve: 
         in fact a resolve will be called, and then the retrieve will simply copy files in the lib directory -->
    <ivy:retrieve pattern="${lib.dir}/[artifact].[ext]" />
</target>
</code>
Here we see that we only call a retrieve task, the resolve being done automatically with default parameters (which are ok in our case). So here nothing special, we simply use ivy to retrieve dependencies in the lib directory, putting artifacts without revision in their names (it's easier to use with an ide, for instance).

<h2>publish</h2>
<code type="xml">
<target name="publish" depends="clean-build, new-version, jar" description="--> publish this project in the ivy repository">
    <property name="revision" value="${version}"/>
    <ivy:publish artifactspattern="${build.dir}/[artifact].[ext]" 
        resolver="shared"
        pubrevision="${revision}" 
        status="release"
    	/>
    <echo message="project ${ant.project.name} released with version ${revision}" />
</target>
</code>
This target let publish the module in the shared repository, with the revision found in the version property, which is set by other targets. It can be used when a module reaches a specific milestone, or whenever you want the teeam to benefit from a new version of the module.
<h2>publish-local</h2>
<code type="xml">
<target name="publish-local" depends="local-version, jar" description="--> publish this project in the local ivy repository">
    <delete file="${build.dir}/ivy.xml"/> <!-- delete last produced ivy file to be sure a new one will be generated -->
    <ivy:publish artifactspattern="${build.dir}/[artifact].[ext]" 
        resolver="local"
        pubrevision="${revision}"
        pubdate="${now}"
        status="integration"
    	/>
    <echo message="project ${ant.project.name} published locally with version ${revision}" />
</target>
</code>
This is very similar to the publish task, except that this publish the revision in the local repository, which is used only in your environment and doesn't disturb the team. When you change something in a module and want to benefit from the change in another one, you can simply call publish-local in this module, and then your next build of the other module will automatically get this local version.
<h2>clean-local</h2>
<code type="xml">
<target name="clean-local" depends="configure" description="cleans the local repository for the current module">
    <delete dir="${ivy.local.default.root}/${ant.project.name}"/>
</target>
</code>
This target is used when you don't want to use your local version of a module anymore, for example when you release a new version to the whole team.
<h2>report</h2>
<code type="xml">
<target name="report" depends="resolve" description="--> generates a report of dependencies">
    <ivy:report todir="${build.dir}"/>
</target>
</code>
Generates both an html report and a graphml report.

For example, to generate a graph like the one shown at the beginning of this tutorial, you just have to follow the instructions given <a href="http://www.jayasoft.org/ivy/doc/yed">here</a> with the graphml file you will find in <code>projects/console/build/</code> after having called report in the console project, and that's it, you have a clear overview of all your app dependencies !]]>
</content>
</node>
<node id="node-416">
<nodeinfo  path='ivy/doc/tutorial/conf' md5_body='9b70325ca68dd9e3d419c43f85cb2616' weight='0' depth='3' type='book' author='mathias' uid='4' created='1138089071' status='1' format='4' sticky='0' promote='0'/>
<title>Using Ivy Configurations</title>
<teaser>
<![CDATA[This tutorial introduces the use of configuration in ivy files. Ivy configurations is indeed a very important concept. Someone even told me one day that using Ivy without using configurations is like eating a good cheese without touching the glass of Chateau Margaux 1976 you have just aside :-)

More seriously, configurations in ivy can be better understood as views on your module, and you will see how they can be used efficiently here.

Reference documentation on configurations can be find <a href="/ivy/doc/terminology">here</a> and <a href="/ivy/doc/ivyfile/configurations">here</a>.
<h1>Introduction</h1>]]>
</teaser>
<content>
<![CDATA[This tutorial introduces the use of configuration in ivy files. Ivy configurations is indeed a very important concept. Someone even told me one day that using Ivy without using configurations is like eating a good cheese without touching the glass of Chateau Margaux 1976 you have just aside :-)

More seriously, configurations in ivy can be better understood as views on your module, and you will see how they can be used efficiently here.

Reference documentation on configurations can be find <a href="/ivy/doc/terminology">here</a> and <a href="/ivy/doc/ivyfile/configurations">here</a>.
<h1>Introduction</h1>
Source code available in src/example/configurations/multi-projects.
We have two projects :
  - a library that define an api to filter String array and two implementations of this api.
  - a very small app that use this library.
  
The library produces 3 artifacts:
  - the api jar,
  - an implementation jar with no external dependency,
  - an other implementation that needs commons-collection to perform.

The application only need api to compile and can use any of the two implementation at runtime.

<h1>The library project</h1>
The first project we defined in this tutorial is the filter-framework.
In order to have a fine grained artifacts publication definition, we defined configurations to map usage other can make of our library.
<h2>The ivy.xml file</h2>

<div class="ivy-file">
<code type="xml">
<ivy-module version="1.3">
    <info organisation="jayasoft" module="filter-framework"/>
    <configurations>
    	<conf name="api"  description="only provide filter framework API"/>
      <conf name="homemade-impl" extends="api" description="provide a home made implementation of our api"/>
      <conf name="cc-impl" extends="api" description="provide an implementation that use apache common collection framework"/>
      <conf name="test" extends="cc-impl" visibility="private" description="for testing our framework"/>
    </configurations>
    <publications>
      <artifact name="filter-api" type="jar"  conf="api" ext="jar"/>
      <artifact name="filter-hmimpl" type="jar"  conf="homemade-impl" ext="jar"/>
      <artifact name="filter-ccimpl" type="jar"  conf="cc-impl" ext="jar"/>      
    </publications>
    <dependencies>
        <dependency org="apache" name="commons-collections" rev="3.1" conf="cc-impl->default"/>
        <dependency org="junit" name="junit" rev="3.8" conf="test->default"/>
    </dependencies>
</ivy-module>
</code> 
</div>
<h2>Explanation</h2>
As you can see we defined 3 public configurations and a private one (defined junit dependency for testing).
The 2 implementations conf  <b>homemade-impl</b>,  <b>cc-impl</b> extends <b>api</b> configuration so artifacts defined in api will also be required in its extending conf.
In the publications tag we defined the artifacts we produce (here it's jars) and we affect them a configuration.
Later when others will use our library they will have a very flexible way to defined what they need.

<h2>See it in action</h2>
The library project is build using ant. Open a shell in the root directory of the project and type <b>ant</b>.
<div class="shell"><pre>
Buildfile: build.xml
clean:
resolve:
:: Ivy 20060123130642 - 20060123130642 :: http://ivy.jayasoft.org/ ::
no configuration file found, using default...
:: configuring :: url = jar:file:/C:/dev/ant/apache-ant-1.6.2/lib/ivy-20060123130642.jar!/fr/jayasoft/ivy/conf/ivyconf.xml
:: resolving dependencies :: [ jayasoft | filter-framework | working@SPIDER ]
        confs: [api, homemade-impl, cc-impl, test]
        found [ apache | commons-collections | 3.1 ] in main
        found [ junit | junit | 3.8 ] in main
downloading http://www.ibiblio.org/maven/commons-collections/jars/commons-collections-3.1.jar ................(546kB)
        [SUCCESSFUL ] [ apache | commons-collections | 3.1 ]/commons-collections.jar[jar] (34320ms)
downloading http://www.ibiblio.org/maven/junit/jars/junit-3.8.jar ........................... (118kB)
        [SUCCESSFUL ] [ junit | junit | 3.8 ]/junit.jar[jar] (8462ms)
:: resolution report ::
        ---------------------------------------------------------------------
        |                  |            modules            ||   artifacts   |
        |       conf       | number| search|dwnlded|evicted|| number|dwnlded|
        ---------------------------------------------------------------------
        |        api       |   0   |   0   |   0   |   0   ||   0   |   0   |
        |   homemade-impl  |   0   |   0   |   0   |   0   ||   0   |   0   |
        |      cc-impl     |   1   |   1   |   1   |   0   ||   1   |   1   |
        |       test       |   2   |   2   |   1   |   0   ||   2   |   2   |
        ---------------------------------------------------------------------
:: retrieving :: [ jayasoft | filter-framework ]
        confs: [api, homemade-impl, cc-impl, test]
        3 artifacts copied, 0 already retrieved

build:
    [mkdir] Created dir: D:\svn\jayasoft\projects\tools\ivy\src\example\configurations\multi-projects\filter-framework\build
    [mkdir] Created dir: D:\svn\jayasoft\projects\tools\ivy\src\example\configurations\multi-projects\filter-framework\distrib
    [javac] Compiling 4 source files to D:\svn\jayasoft\projects\tools\ivy\src\example\configurations\multi-projects\filter-framework\build
      [jar] Building jar: D:\svn\jayasoft\projects\tools\ivy\src\example\configurations\multi-projects\filter-framework\distrib\filter-api.jar
      [jar] Building jar: D:\svn\jayasoft\projects\tools\ivy\src\example\configurations\multi-projects\filter-framework\distrib\filter-hmimpl.jar
      [jar] Building jar: D:\svn\jayasoft\projects\tools\ivy\src\example\configurations\multi-projects\filter-framework\distrib\filter-ccimpl.jar

test:
    [mkdir] Created dir: D:\svn\jayasoft\projects\tools\ivy\src\example\configurations\multi-projects\filter-framework\build\test-report
    [mkdir] Created dir: D:\svn\jayasoft\projects\tools\ivy\src\example\configurations\multi-projects\filter-framework\build\test-classes
    [javac] Compiling 3 source files to D:\svn\jayasoft\projects\tools\ivy\src\example\configurations\multi-projects\filter-framework\build\test-classes
    [junit] Running filter.ccimpl.CCFilterTest
    [junit] Tests run: 5, Failures: 0, Errors: 0, Time elapsed: 0.02 sec
    [junit] Running filter.hmimpl.HMFilterTest
    [junit] Tests run: 5, Failures: 0, Errors: 0, Time elapsed: 0.01 sec

publish:
:: delivering :: [ jayasoft | filter-framework | working@SPIDER ] :: 1.3 :: release :: Tue Jan 24 10:53:41 CET 2006
        delivering ivy file to distrib/ivy.xml
:: publishing :: [ jayasoft | filter-framework | working@SPIDER ]
        published filter-api to D:\users\mm\.ivy/local/jayasoft/filter-framework/1.3/jars/filter-api.jar
        published filter-ccimpl to D:\users\mm\.ivy/local/jayasoft/filter-framework/1.3/jars/filter-ccimpl.jar
        published filter-hmimpl to D:\users\mm\.ivy/local/jayasoft/filter-framework/1.3/jars/filter-hmimpl.jar
        published ivy to D:\users\mm\.ivy/local/jayasoft/filter-framework/1.3/ivys/ivy.xml
     [echo] project filter-framework released with version 1.3

BUILD SUCCESSFUL
</div></pre>
The ant's default target is publish. 
This target use ivy to publish our library binaries in a local repository. 
As we do not specify any repository path the default one is use. ({home.dir}/.ivy/local/jayasoft/filter-framework/)
Now we are ready to use our library.

<h1>The application project</h1>

Now that we have shipped our fantastic library, we want to use it!
The tutorial comes with a sample application called myapp. You will find it in the tutorial folder.
<h2>The ivy.xml file</h2>

<div class="ivy-file">
<code type="xml">
<ivy-module version="1.3">
    <info organisation="jayasoft" module="myapp"/>
   
    <configurations>
      <conf name="build" visibility="private" description="compilation only need api jar" />
      <conf name="noexternaljar" description="use only company jar" />
      <conf name="withexternaljar" description="use company jar and third party jars" />    
    </configurations>
    
    <dependencies>
        <dependency org="jayasoft" name="filter-framework" rev="latest.integration" conf="build->api; noexternaljar->homemade-impl; withexternaljar->cc-impl"/>
    </dependencies>
</ivy-module>
</code> 
</div>
<h2>Explanation</h2>
We create 3 configurations that define the way we want to use the application.
The build configuration, (as said before) only need api to compile.
The other configuration are defined for runtime.
One configuration will only use "home-made" jars, and the second one will use external jars.

We also defined a dependency on the previous library.
In the dependency we use configuration mapping to match ours and library configurations.
You can found more information on configuration mapping <a href="/ivy/doc/ivyfile/configurations">here</a>
<ol>
  <li><b>build->api</b> : here we tell ivy that our <b>build</b> configuration depends on the api configuration of the dependcy</li>
  <li><b>noexternaljar->homemade-impl</b> : here we tell ivy that our <b>noexternaljar</b> configuration depends on the <b>homemade-impl</b> configuration of the dependcy.</li>
  <li><b>withexternaljar->cc-impl</b> : here we tell ivy that our <b>withexternaljar</b> configuration depends on the <b>cc-impl</b> configuration of the dependcy</li>
</ol>
Note that we never declares any of the dependency artifacts we need in each configuration: it's the dependency module file which declares the published artifacts and which should be used in each configuration.

In the ant buld.xml file we defined a resolve target as follow:

<code type="xml">
<target name="resolve" description="--> retreive dependencies with ivy">
	<ivy:retrieve pattern="${ivy.lib.dir}/[conf]/[artifact].[ext]"/>
</target> 
</code> 

When we call this target, Ivy will do a resolve using our ivy.xml file in the root folder and will after do retrieve putting all the artifacts in folder for each configuration. Here is how your lib directory should look like after a call to this target:
<div class="shell"><pre>
 Rpertoire de D:\ivy\src\example\configurations\multi-projects\myapp\lib

01/24/2006  11:19 AM    <REP>          build
01/24/2006  11:19 AM    <REP>          noexternaljar
01/24/2006  11:19 AM    <REP>          withexternaljar
               0 fichier(s)                0 octets

 Rpertoire de D:\ivy\src\example\configurations\multi-projects\myapp\lib\build

01/24/2006  10:53 AM             1,174 filter-api.jar
               1 fichier(s)            1,174 octets

 Rpertoire de D:\ivy\src\example\configurations\multi-projects\myapp\lib\noexternaljar

01/24/2006  10:53 AM             1,174 filter-api.jar
01/24/2006  10:53 AM             1,030 filter-hmimpl.jar
               2 fichier(s)            2,204 octets

 Rpertoire de D:\ivy\src\example\configurations\multi-projects\myapp\lib\withexternaljar
01/24/2006  10:53 AM           559,366 commons-collections.jar
01/24/2006  10:53 AM             1,174 filter-api.jar
01/24/2006  10:53 AM             1,626 filter-ccimpl.jar
               3 fichier(s)          562,166 octets
</pre></div>
As you can see for each configuration we have now a set of jars.

Let's try to launch our app.

<h2>See it in action</h2>
Use ant to run the application.
Default ant target is run-cc and will launch application using common collection jar.
<div class="shell"><pre>
Buildfile: build.xml

resolve:
:: Ivy 20060123130642 - 20060123130642 :: http://ivy.jayasoft.org/ ::
no configuration file found, using default...
:: configuring :: url = jar:file:/C:/dev/ant/apache-ant-1.6.2/lib/ivy-20060123130642.jar!/fr/jayasoft/ivy/conf/ivyconf.xml
:: resolving dependencies :: [ jayasoft | myapp | working@SPIDER ]
        confs: [build, noexternaljar, withexternaljar]
        found [ jayasoft | filter-framework | 1.3 ] in local
        [1.3] [ jayasoft | filter-framework | latest.integration ]
        found [ apache | commons-collections | 3.1 ] in default
downloading D:\users\mm\.ivy\local\jayasoft\filter-framework\1.3\jars\filter-ccimpl.jar .... (1kB)
        [SUCCESSFUL ] [ jayasoft | filter-framework | 1.3 ]/filter-ccimpl.jar[jar] (0ms)
downloading D:\users\mm\.ivy\local\jayasoft\filter-framework\1.3\jars\filter-api.jar .... (1kB)
        [SUCCESSFUL ] [ jayasoft | filter-framework | 1.3 ]/filter-api.jar[jar] (0ms)
downloading D:\users\mm\.ivy\local\jayasoft\filter-framework\1.3\jars\filter-hmimpl.jar .... (1kB)
        [SUCCESSFUL ] [ jayasoft | filter-framework | 1.3 ]/filter-hmimpl.jar[jar] (10ms)
:: resolution report ::
        ---------------------------------------------------------------------
        |                  |            modules            ||   artifacts   |
        |       conf       | number| search|dwnlded|evicted|| number|dwnlded|
        ---------------------------------------------------------------------
        |       build      |   1   |   1   |   1   |   0   ||   1   |   1   |
        |   noexternaljar  |   1   |   1   |   1   |   0   ||   2   |   2   |
        |  withexternaljar |   2   |   1   |   1   |   0   ||   3   |   2   |
        ---------------------------------------------------------------------
:: retrieving :: [ jayasoft | myapp ]
        confs: [build, noexternaljar, withexternaljar]
        6 artifacts copied, 0 already retrieved

build:
    [mkdir] Created dir: D:\svn\jayasoft\projects\tools\ivy\src\example\configurations\multi-projects\myapp\build
    [javac] Compiling 1 source file to D:\svn\jayasoft\projects\tools\ivy\src\example\configurations\multi-projects\myapp\build

run-cc:
     [java] Filtering with:class filter.ccimpl.CCFilter
     [java] Result :[two, tree]
</div></pre>
Launching application with only home made jars is straingforward.
type ant run-hm

<div class="shell"><pre>
Buildfile: build.xml

resolve:
:: Ivy 20060123130642 - 20060123130642 :: http://ivy.jayasoft.org/ ::
no configuration file found, using default...
:: configuring :: url = jar:file:/C:/dev/ant/apache-ant-1.6.2/lib/ivy-20060123130642.jar!/fr/jayasoft/ivy/conf/ivyconf.xml
:: resolving dependencies :: [ jayasoft | myapp | working@SPIDER ]
        confs: [build, noexternaljar, withexternaljar]
        found [ jayasoft | filter-framework | 1.3 ] in default
        [1.3] [ jayasoft | filter-framework | latest.integration ]
        found [ apache | commons-collections | 3.1 ] in default
:: resolution report ::
        ---------------------------------------------------------------------
        |                  |            modules            ||   artifacts   |
        |       conf       | number| search|dwnlded|evicted|| number|dwnlded|
        ---------------------------------------------------------------------
        |       build      |   1   |   1   |   0   |   0   ||   1   |   0   |
        |   noexternaljar  |   1   |   1   |   0   |   0   ||   2   |   0   |
        |  withexternaljar |   2   |   1   |   0   |   0   ||   3   |   0   |
        ---------------------------------------------------------------------
:: retrieving :: [ jayasoft | myapp ]
        confs: [build, noexternaljar, withexternaljar]
        0 artifacts copied, 6 already retrieved

build:

run-hm:
     [java] Filtering with:class filter.hmimpl.HMFilter
     [java] Result :[two, tree]

BUILD SUCCESSFUL
</pre></div>
Nice we got the same result but we can see that implementation class are different.

<h1>Conclusion</h1>
<b>You should use configuration as often as possible</b>
Configurations are very important concept in ivy. They allow you to groups artifacts set by meaning.
When you write ivy file for projects that are supposed to be reused, use configurations to allow people to get only they what they need without having to specify it by hand using artifact tag in dependency section. ]]>
</content>
</node>
<node id="node-411">
<nodeinfo  path='ivy/doc/tutorial/build-repository' md5_body='74886046c5b08dc27ba5feaedd84d2be' weight='2' depth='3' type='book' author='matthieu' uid='5' created='1138027109' status='1' format='4' sticky='0' promote='0'/>
<title>Building a repository</title>
<teaser>
<![CDATA[With the <a href="/ivy/doc/use/install">install</a> ant task you are given the possibility to copy ivy descriptors and artifacts found from a resolver and publish them into another resolver.<br/> 

This tutorial will show you how to build your own clean enterprise repository of ivy descriptors and modules artifacts.
We will first use some basic ivy configuration files to show how it works, and then we will use advanced features like <a href="/ivy/doc/configuration/namespaces">namespaces</a> to build a real enterprise repository.

<h1>The project used</h1>
The project that we will use is quite simple.]]>
</teaser>
<content>
<![CDATA[With the <a href="/ivy/doc/use/install">install</a> ant task you are given the possibility to copy ivy descriptors and artifacts found from a resolver and publish them into another resolver.<br/> 

This tutorial will show you how to build your own clean enterprise repository of ivy descriptors and modules artifacts.
We will first use some basic ivy configuration files to show how it works, and then we will use advanced features like <a href="/ivy/doc/configuration/namespaces">namespaces</a> to build a real enterprise repository.

<h1>The project used</h1>
The project that we will use is quite simple.
It is compouned of an ant build file, and some ivy conf files.

Here are the accessible target that we will use : 
<div class="shell"><pre>
Z:\ivy-repository>ant -p
Buildfile: build.xml

Main targets:

 advanced                                 --> retrieve files from public repositories (ivyrep, ibiblio, ...) using namespaces
 basic                                    --> retrieve files from well formatted ivy repositories
 basic-deps                               --> retrieve files from well formatted ivy repositories with dependencies
 clean-cache                              --> clean the cache
 clean-repo                               --> clean the destination repository
 commons-lang-1-0-ibiblio-no-namespace    --> retrieve commons-lang 1.0 from ibiblio maven using no namespaces
 commons-lang-1-0-ibiblio-with-namespace  --> retrieve commons-lang 1.0 from ibiblio maven using namespaces
 maven1                                   --> retrieve commons-lang 1.0 from maven1 repo using namespaces
 maven2                                   --> retrieve files from maven2 repo using namespaces
Default target: basic</pre></div>
<br/><br/>
The project is accessible in the <a href="/latest/ivy">sources</a> of Ivy into : IVY_HOME/src/example/build-a-ivy-repository

]]>
</content>
<node id="node-412">
<nodeinfo  path='ivy/doc/tutorial/build-repository/basic' md5_body='9ef7494cb3c70f9427df1ca3ef624520' weight='0' depth='4' type='book' author='matthieu' uid='5' created='1138028470' status='1' format='4' sticky='0' promote='0'/>
<title>Basic repository replication</title>
<teaser>
<![CDATA[!!!! UNDER CONSTRUCTION !!!!



We will study here two cases, corresponding to the two basics targets found in the previous build.xml project file.

<h1>Basic : ivyconf.xml file used</h1>
The ivy conf file that we will use is very simple here. It defines two resolvers, libraries and local-repository. The first one is used to retrieve the files that we want, the second is used to copy them. The second one will become our own repository.
<ul>
<li>ivyrep : nothing special on it, ivy files will be looked for on ivyrep and artifacts will be downloaded from 
ibilio</li>
<li>local-repository :  will store the found files</li>]]>
</teaser>
<content>
<![CDATA[!!!! UNDER CONSTRUCTION !!!!



We will study here two cases, corresponding to the two basics targets found in the previous build.xml project file.

<h1>Basic : ivyconf.xml file used</h1>
The ivy conf file that we will use is very simple here. It defines two resolvers, libraries and local-repository. The first one is used to retrieve the files that we want, the second is used to copy them. The second one will become our own repository.
<ul>
<li>ivyrep : nothing special on it, ivy files will be looked for on ivyrep and artifacts will be downloaded from 
ibilio</li>
<li>local-repository :  will store the found files</li>
</ul>

<div class="ivy-file">
<code type="xml">
<ivyconf>
    <conf   defaultCache="${ivy.cache.dir}"	
            defaultResolver="local-repository" 
            defaultConflictManager="all" />    <!-- in order to get all revisions without any eviction -->
    <resolvers>
        <ivyrep name="libraries" />
        <filesystem name="local-repository">
            <ivy pattern="${dest.repo.dir}/[organisation]/[module]/ivys/ivy-[revision].xml"/>
            <artifact pattern="${dest.repo.dir}/[organisation]/[module]/[type]s/[artifact]-[revision].[type]"/>
        </filesystem>
    </resolvers>
</ivyconf>
</code>
</div>

<h1>basic, retrieve commons-lang 1.0</h1>
Let's have a look at the <em>basic</em> target.
<code type="xml">
    <target name="basic" depends="init-basic" description="--> retrieve files from well formatted ivy repositories">
        <ivy:install organisation="apache" module="commons-lang" revision="1.0" from="${from-resolver}" to="${to-resolver}" />
    </target>
</code>
After a call to init-basic, that make the ivy initialization with the right ivyconf file, we only call the task <a href="/ivy/doc/use/install">install</a> to retrieve apache commons-lang in it's 1.0 version.
Here is the ant call output :
<div class="shell"><pre>Z:\ivy-repository>ant basic
Buildfile: build.xml

init-basic:
:: Ivy 20060123130642 - 20060123130642 :: http://ivy.jayasoft.org/ ::
:: configuring :: file = Z:\ivy-repository\ivy-conf-basic.xml

basic:
:: installing [ apache | commons-lang | 1.0 ] ::
:: resolving dependencies ::
        found [ apache | commons-lang | 1.0 ] in libraries
:: downloading artifacts to cache ::
downloading http://www.ibiblio.org/maven/commons-lang/jars/commons-lang-1.0.jar ...
............ (62kB)
        [SUCCESSFUL ] [ apache | commons-lang | 1.0 ]/commons-lang.jar[jar] (1203ms)
:: installing in local-repository ::
        published commons-lang to Z:\ivy-repository/ivy-local-repository/apache/commons-lang/jars/commons-lang-1.0.jar
        published ivy to Z:\ivy-repository/ivy-local-repository/apache/commons-lang/ivys/ivy-1.0.xml

BUILD SUCCESSFUL
Total time: 2 seconds</pre></div>
The trace tells us that the module definition was found using the "libraries" resolver and that the corresponding artifact was downloaded from ibiblio. Then both were published in the local repository.

If we take a look at our repository :
<div class="shell"><pre>Z:\ivy-repository>dir /s /B /A:-D ivy-local-repository
Z:\ivy-repository\ivy-local-repository\apache\commons-lang\ivys\ivy-1.0.xml
Z:\ivy-repository\ivy-local-repository\apache\commons-lang\jars\commons-lang-1.0.jar
Z:\ivy-repository></pre>
</div>
We can see that we have started our own repository by retrieving the commons-lang 1.0 ivy file descriptor and jar.
<h1>basic with dependencies, retrieve hibernate 2.1.8</h1>
Now let's advance a little more by trying a module that has some dependencies. Here is the target that we will call :
<code type="xml">
    <target name="basic-deps" depends="init-basic" description="--> retrieve files from well formatted ivy repositories with dependencies">
        <ivy:install organisation="hibernate" module="hibernate" revision="2.1.8" from="${from-resolver}" to="${to-resolver}" transitive="true" />
    </target>
</code>This target is very similar to the basic one, except it defines the transitivity mode to use. By writing, <em>transitive="true"</em>, we tell the task to retrieve the corresponding module and it's dependencies.

Ok let's call the target :
<div class="shell"><pre>Z:\ivy-repository>ant basic-deps
Buildfile: build.xml

init-basic:
:: Ivy 20060123130642 - 20060123130642 :: http://ivy.jayasoft.org/ ::
:: configuring :: file = Z:\ivy-repository\ivy-conf-basic.xml

basic-deps:
:: installing [ hibernate | hibernate | 2.1.8 ] ::
:: resolving dependencies ::
        found [ hibernate | hibernate | 2.1.8 ] in libraries
        found [ cglib | cglib | 2.0.2 ] in libraries
        found [ apache | commons-collections | 2.1.1 ] in libraries
        found [ apache | commons-logging | 1.0.4 ] in libraries
        found [ dom4j | dom4j | 1.4 ] in libraries
        found [ ehcache | ehcache | 0.9 ] in libraries
        found [ odmg | odmg | 3.0 ] in libraries
        found [ sun | jta | 1.0 ] in libraries
        found [ apache | xalan | 2.4.0 ] in libraries
        found [ apache | xerces | 2.4.0 ] in libraries
        found [ sun | jdbc | 2.0 ] in libraries
        found [ sun | jca | 1.0 ] in libraries
        found [ sun | jaas | 1.0 ] in libraries
        found [ c3p0 | c3p0 | 0.8.4.5 ] in libraries
        found [ apache | commons-dbcp | 1.2.1 ] in libraries
        found [ apache | commons-pool | 1.2 ] in libraries
        found [ apache | commons-collections | 2.1 ] in libraries
        found [ apache | xerces | 2.0.2 ] in libraries
        found [ proxool | proxool | 0.8.3 ] in libraries
        found [ jboss | jboss-cache | 1.1.1 ] in libraries
        found [ opensymphony | oscache | 2.0 ] in libraries
        found [ apache | commons-logging | 1.0.3 ] in libraries
        found [ swarmcache | swarmcache | 1.0RC2 ] in libraries
        found [ apache | commons-logging | 1.0.2 ] in libraries
        found [ jgroups | jgroups | 2.2 ] in libraries
:: downloading artifacts to cache ::
downloading http://www.ibiblio.org/maven/hibernate/jars/hibernate-2.1.8.jar ...
...........
............
.. (944kB)
        [SUCCESSFUL ] [ hibernate | hibernate | 2.1.8 ]/hibernate.jar[jar] (97063ms)


SOME MINUTES LATER .... ;-)


downloading http://www.ibiblio.org/maven/commons-logging/jars/commons-logging-1.0.4.jar ...
..
......
.. (37kB)
        [SUCCESSFUL ] [ apache | commons-logging | 1.0.4 ]/commons-logging.jar[jar] (24172ms)

BUILD SUCCESSFUL
Total time: 14 minutes 57 seconds
Z:\ivy-repository></pre>
</div>

We can see here that <a href="/ivy">ivy</a> has resolved hibernate 2.1.8 and 24 depending modules. If we look at the ivy file for <a href="http://ivyrep.jayasoft.org/hibernate/hibernate/ivy-2.1.8.xml">hibernate 2.1.8</a>, we can see that it defines 17 dependencies. The 7 others that ivy retrieved, were transitive ones used in direct dependent modules of hibernate.

We can notice that we have retrieve 3 differents revisions of apache commons-logging (1.0.2, 1.0.3, 1.0.4) and 2 revisions of commons-collections (1.2, 1.2.1). This is due to the fact that we use the "no conflict" <a href="/ivy/doc/configuration/conflict-managers">conflic manager</a> in the ivyconf file.
We do not want to evict any modules because we are building our own repository !

8 modules artifacts have not been downloaded cause they have not been found on ibiblio with the ivyconf as it is.
We will see how to handle this problem in the advanced tutorial.

If we look at our repository now, it starts to look to something good :

<div class="shell"><pre>Z:\ivy-repository>dir /s /B /A:-D ivy-local-repository
Z:\ivy-repository\ivy-local-repository\apache\commons-collections\ivys\ivy-2.1.1.xml
Z:\ivy-repository\ivy-local-repository\apache\commons-collections\ivys\ivy-2.1.xml
Z:\ivy-repository\ivy-local-repository\apache\commons-collections\jars\commons-collections-2.1.1.jar
Z:\ivy-repository\ivy-local-repository\apache\commons-collections\jars\commons-collections-2.1.jar
Z:\ivy-repository\ivy-local-repository\apache\commons-dbcp\ivys\ivy-1.2.1.xml
Z:\ivy-repository\ivy-local-repository\apache\commons-dbcp\jars\commons-dbcp-1.2.1.jar
Z:\ivy-repository\ivy-local-repository\apache\commons-lang\ivys\ivy-1.0.xml
Z:\ivy-repository\ivy-local-repository\apache\commons-lang\jars\commons-lang-1.0.jar
Z:\ivy-repository\ivy-local-repository\apache\commons-logging\ivys\ivy-1.0.2.xml
Z:\ivy-repository\ivy-local-repository\apache\commons-logging\ivys\ivy-1.0.3.xml
Z:\ivy-repository\ivy-local-repository\apache\commons-logging\ivys\ivy-1.0.4.xml
Z:\ivy-repository\ivy-local-repository\apache\commons-logging\jars\commons-logging-1.0.2.jar
Z:\ivy-repository\ivy-local-repository\apache\commons-logging\jars\commons-logging-1.0.3.jar
Z:\ivy-repository\ivy-local-repository\apache\commons-logging\jars\commons-logging-1.0.4.jar
Z:\ivy-repository\ivy-local-repository\apache\commons-pool\ivys\ivy-1.2.xml
Z:\ivy-repository\ivy-local-repository\apache\commons-pool\jars\commons-pool-1.2.jar
Z:\ivy-repository\ivy-local-repository\apache\xalan\ivys\ivy-2.4.0.xml
Z:\ivy-repository\ivy-local-repository\apache\xalan\jars\xalan-2.4.0.jar
Z:\ivy-repository\ivy-local-repository\apache\xerces\ivys\ivy-2.0.2.xml
Z:\ivy-repository\ivy-local-repository\apache\xerces\ivys\ivy-2.4.0.xml
Z:\ivy-repository\ivy-local-repository\apache\xerces\jars\xerces-2.0.2.jar
Z:\ivy-repository\ivy-local-repository\apache\xerces\jars\xerces-2.4.0.jar
Z:\ivy-repository\ivy-local-repository\apache\xerces\jars\xmlParserAPIs-2.0.2.jar
Z:\ivy-repository\ivy-local-repository\c3p0\c3p0\ivys\ivy-0.8.4.5.xml
Z:\ivy-repository\ivy-local-repository\c3p0\c3p0\jars\c3p0-0.8.4.5.jar
Z:\ivy-repository\ivy-local-repository\cglib\cglib\ivys\ivy-2.0.2.xml
Z:\ivy-repository\ivy-local-repository\cglib\cglib\jars\cglib-full-2.0.2.jar
Z:\ivy-repository\ivy-local-repository\dom4j\dom4j\ivys\ivy-1.4.xml
Z:\ivy-repository\ivy-local-repository\dom4j\dom4j\jars\dom4j-1.4.jar
Z:\ivy-repository\ivy-local-repository\ehcache\ehcache\ivys\ivy-0.9.xml
Z:\ivy-repository\ivy-local-repository\ehcache\ehcache\jars\ehcache-0.9.jar
Z:\ivy-repository\ivy-local-repository\hibernate\hibernate\ivys\ivy-2.1.8.xml
Z:\ivy-repository\ivy-local-repository\hibernate\hibernate\jars\hibernate-2.1.8.jar
Z:\ivy-repository\ivy-local-repository\jboss\jboss-cache\ivys\ivy-1.1.1.xml
Z:\ivy-repository\ivy-local-repository\jgroups\jgroups\ivys\ivy-2.2.xml
Z:\ivy-repository\ivy-local-repository\odmg\odmg\ivys\ivy-3.0.xml
Z:\ivy-repository\ivy-local-repository\odmg\odmg\jars\odmg-3.0.jar
Z:\ivy-repository\ivy-local-repository\opensymphony\oscache\ivys\ivy-2.0.xml
Z:\ivy-repository\ivy-local-repository\proxool\proxool\ivys\ivy-0.8.3.xml
Z:\ivy-repository\ivy-local-repository\proxool\proxool\jars\proxool-0.8.3.jar
Z:\ivy-repository\ivy-local-repository\sun\jaas\ivys\ivy-1.0.xml
Z:\ivy-repository\ivy-local-repository\sun\jca\ivys\ivy-1.0.xml
Z:\ivy-repository\ivy-local-repository\sun\jdbc\ivys\ivy-2.0.xml
Z:\ivy-repository\ivy-local-repository\sun\jta\ivys\ivy-1.0.xml
Z:\ivy-repository\ivy-local-repository\swarmcache\swarmcache\ivys\ivy-1.0RC2.xml
Z:\ivy-repository\ivy-local-repository\swarmcache\swarmcache\jars\swarmcache-1.0RC2.jar

Z:\ivy-repository></pre>
</div>
]]>
</content>
</node>
<node id="node-413">
<nodeinfo  path='ivy/doc/tutorial/build-repository/advanced1' md5_body='98a1d064b7eafa3f85ad9104a27a4d2f' weight='1' depth='4' type='book' author='matthieu' uid='5' created='1138029780' status='1' format='4' sticky='0' promote='0'/>
<title>Advanced repository - step 1</title>
<teaser>
<![CDATA[<h1>On the road to a professional repository</h1>
We will study in this section how to build a <strong>professionnal</strong> repository. What is a <strong>professionnal</strong> dependency resolver ? Our vision is to say that a good quality repository must follow clear rules about projects naming and must offer corrects, usuables, configurables and verified project descriptors. In order to achieve those goals, we think that you have to build your own repository.
We have seen in the previous example, that we could use some public repositories to begin to build our own repository. 
Nevertheless, the result is not at all the one that was excepected. Indeed there is a problem with public repositories : their partial incompatibility.]]>
</teaser>
<content>
<![CDATA[<h1>On the road to a professional repository</h1>
We will study in this section how to build a <strong>professionnal</strong> repository. What is a <strong>professionnal</strong> dependency resolver ? Our vision is to say that a good quality repository must follow clear rules about projects naming and must offer corrects, usuables, configurables and verified project descriptors. In order to achieve those goals, we think that you have to build your own repository.
We have seen in the previous example, that we could use some public repositories to begin to build our own repository. 
Nevertheless, the result is not at all the one that was excepected. Indeed there is a problem with public repositories : their partial incompatibility.
For example, in <a href="http://ivyrep.jayasoft.org">ivyrep</a> all commons-* projects belong to the apache organisation. In both ibiblio versions, it is not the case. The same problem could appear for other projects with other repositories, it is not the debate here.

To resolve some of the incompatibilities, we will use a new feature of <a href="/ivy">ivy</a> 1.3 the <a href="/ivy">namespaces</a>.

<h1>Using namespaces</h1>
In order to use namespaces, we first need to see what's happening when none are used on repositories that do not fit our needs.
Let's take commons-lang 1.0 from ibiblio with a maven2 pom.
First clean your cache and repository.
<div class="shell"><pre>Z:\ivy-repository>ant clean-cache clean-repo</pre></div>
Then call the good ant target : ant commons-lang-1-0-ibiblio-no-namespace
<div class="shell"><pre>Z:\ivy-repository>ant commons-lang-1-0-ibiblio-no-namespace
Buildfile: build.xml

init-advanced:
:: Ivy 20060125070719 - 20060125070719 :: http://ivy.jayasoft.org/ ::
:: configuring :: file = Z:\ivy-repository\ivy-conf-advanced.xml

commons-lang-1-0-ibiblio-no-namespace:
:: installing [ commons-lang | commons-lang | 1.0 ] ::
:: resolving dependencies ::
        found [ commons-lang | commons-lang | 1.0 ] in ibiblio-maven2-nonamespace
        found [ junit | junit | 3.7 ] in ibiblio-maven2-nonamespace
:: downloading artifacts to cache ::
downloading http://www.ibiblio.org/maven2/commons-lang/commons-lang/1.0/commons-lang-1.0.jar ...
.............. (62kB)
        [SUCCESSFUL ] [ commons-lang | commons-lang | 1.0 ]/commons-lang.jar[jar] (1313ms)
downloading http://www.ibiblio.org/maven2/junit/junit/3.7/junit-3.7.jar ...
.............
.............. (114kB)
        [SUCCESSFUL ] [ junit | junit | 3.7 ]/junit.jar[jar] (2360ms)
:: installing in local-repository ::
        published commons-lang to Z:\ivy-repository/ivy-local-repository/commons-lang/commons-lang/jars/commons-lang-1.0.jar
        published ivy to Z:\ivy-repository/ivy-local-repository/commons-lang/commons-lang/ivys/ivy-1.0.xml
        published junit to Z:\ivy-repository/ivy-local-repository/junit/junit/jars/junit-3.7.jar
        published ivy to Z:\ivy-repository/ivy-local-repository/junit/junit/ivys/ivy-3.7.xml
:: install resolution report ::
        ---------------------------------------------------------------------
        |                  |            modules            ||   artifacts   |
        |       conf       | number| search|dwnlded|evicted|| number|dwnlded|
        ---------------------------------------------------------------------
        |      default     |   2   |   2   |   2   |   0   ||   2   |   2   |
        ---------------------------------------------------------------------

BUILD SUCCESSFUL
Total time: 6 seconds
Z:\ivy-repository></pre></div>
If we take a look at the repository, we can see that we respect the ibiblio maven2 architecture, the organisation apache does not appear.
<div class="shell"><pre>Z:\ivy-repository>dir /s /B /A:-D ivy-local-repository
Z:\ivy-repository\ivy-local-repository\commons-lang\commons-lang\ivys\ivy-1.0.xml
Z:\ivy-repository\ivy-local-repository\commons-lang\commons-lang\jars\commons-lang-1.0.jar
Z:\ivy-repository\ivy-local-repository\junit\junit\ivys\ivy-3.7.xml
Z:\ivy-repository\ivy-local-repository\junit\junit\jars\junit-3.7.jar</pre></div>
If you take a look at the ivy descriptor for commons-lang, you will see that the organisation is still commons-lang. It could not be another thing as we did not do anything for it.
<div><code type="xml">
<ivy-module version="1.0">
	<info organisation="commons-lang"
		module="commons-lang"
		revision="1.0"
		status="integration"
		publication="20051124062021"
	/>
</code></div>

<h2>Introduction to namespaces</h2>
Let's see directly the result, we will have some explanations after.
Clean your repo and cache, and call : ant commons-lang-1-0-ibiblio-with-namespace
<div class="shell"><pre>Z:\ivy-repository>ant commons-lang-1-0-ibiblio-with-namespace
Buildfile: build.xml

init-advanced:
:: Ivy non official version :: http://ivy.jayasoft.org/ ::
:: configuring :: file = Z:\ivy-repository\ivy-conf-advanced.xml

commons-lang-1-0-ibiblio-with-namespace:
:: installing [ apache | commons-lang | 1.0 ] ::
:: resolving dependencies ::
        found [ apache | commons-lang | 1.0 ] in ibiblio-maven2
        found [ junit | junit | 3.7 ] in ibiblio-maven2
:: downloading artifacts to cache ::
downloading http://www.ibiblio.org/maven2/commons-lang/commons-lang/1.0/commons-lang-1.0.jar ...
............. (62kB)
        [SUCCESSFUL ] [ apache | commons-lang | 1.0 ]/commons-lang.jar[jar] (1094ms)
downloading http://www.ibiblio.org/maven2/junit/junit/3.7/junit-3.7.jar ...
............................ (114kB)
        [SUCCESSFUL ] [ junit | junit | 3.7 ]/junit.jar[jar] (1641ms)
:: installing in local-repository ::
        published commons-lang to Z:\ivy-repository/ivy-local-repository/apache/commons-lang/jars/commons-lang-1.0.jar
        published ivy to Z:\ivy-repository/ivy-local-repository/apache/commons-lang/ivys/ivy-1.0.xml
        published junit to Z:\ivy-repository/ivy-local-repository/junit/junit/jars/junit-3.7.jar
        published ivy to Z:\ivy-repository/ivy-local-repository/junit/junit/ivys/ivy-3.7.xml
:: install resolution report ::
        ---------------------------------------------------------------------
        |                  |            modules            ||   artifacts   |
        |       conf       | number| search|dwnlded|evicted|| number|dwnlded|
        ---------------------------------------------------------------------
        |      default     |   2   |   2   |   2   |   0   ||   2   |   2   |
        ---------------------------------------------------------------------

BUILD SUCCESSFUL
Total time: 5 seconds</pre></div>
Now if we look at our repository, it seems to look fine.
<div class="shell"><pre>Z:\ivy-repository>dir /s /B /A:-D ivy-local-repository
Z:\ivy-repository\ivy-local-repository\apache\commons-lang\ivys\ivy-1.0.xml
Z:\ivy-repository\ivy-local-repository\apache\commons-lang\jars\commons-lang-1.0.jar
Z:\ivy-repository\ivy-local-repository\junit\junit\ivys\ivy-3.7.xml
Z:\ivy-repository\ivy-local-repository\junit\junit\jars\junit-3.7.jar</pre></div>
Have a look at the ivy file to see it it looks better than before. Ok, we have now our apache organisation.
<div><code type="xml">
<ivy-module version="1.0">
	<info organisation="apache"
		module="commons-lang"
		revision="1.0"
		status="integration"
		publication="20051124062021"
	/>
</code></div>
<h2>How does this work ?</h2>
If we look at the ant target commons-lang-1-0-ibiblio-with-namespace, we can see that it uses a resolver called ibiblio-maven2. 
Let's find it... The configuration file used for this test is ivy-conf-advanced.xml. This one includes ivy-maven2-ivyconf.xml where the required resolver is defined.
Let's see it's definition :
<code type="xml"><ibiblio	name="ibiblio-maven2" 
                root="${ibiblio-maven2-root}" 
                pattern="${ibiblio-maven2-pattern}"
                m2compatible="true"
                namespace="ibiblio-maven2"
/></code>Ok, i see it, it is a ibiblio resolver for which we specify the root and the pattern. The important things here are the 2 other parameters.
<ul><li><b>m2compatible</b> is a flag telling that we allow reading POMs file and make some transformations on URLs regarding the organisation name. Indeed, maven transforms organisations like "org.apache" into "some_url/org/apache" to retrieve information on ibiblio repositories.</li>
<li><b>namespace</b> this attribute defines a domain in which same projects (meanning organsiation, module or revision) can be nammed whith differents kinds.</li></ul>

A namespace is defined by a set of rule, for ibiblio-maven2, whe have declared some rules :
<h3>rule handling imported apache maven1 projects</h3>
<code type="xml"><rule>	<!-- imported apache maven1 projects -->
	<fromsystem>
	    <src org="apache" module=".+"/>
	    
	    <dest org="$m0" module="$m0"/>
	</fromsystem>
	<tosystem>
	    <src org="commons-.+" module="commons-.+" />
	    <src org="ant.*" module="ant.*" />
	    ...
	    <src org="xmlrpc" module="xmlrpc" />

	    <dest org="apache" module="$m0"/>
	</tosystem>
</rule></code>
<div class="postit"><u>Note about regular expressions usage :</u>
In order to distinguish matching regular expressions found in organisation, module & revision the notation used prefixes the matching regular expression with the letters 'o', 'm' & 'r'.
$o0 : the whole regular expression term in the organisation attribute
$o1 : the first matching expression term that was marked in the organisation attribute
...
The same applies for modules : $m0, $m1, ...
and for revisions : $r0, $r1, ...
</div>
<ul>
<li><b>fromsystem :</b> we define here that the projects defined in the system under the organisation called "apache" are transformed into the destination namespace (whose resolver it applies) into projects whose organisation is nammed with the module name, we don't care here about the revision. For example, the project ['apache', 'commons-lang', '1.0'] in the namespace system will be translated into ['commons-lang', 'commons-lang', '1.0'] in the ibiblio-maven2 resolver namespace.</li>
<li><b>tosystem :</b> we define here the reverse mapping, ie how to translate <em>apache</em> projects from ibiblio into real apache projects in the namespace system. The rule here, is telling that all projects matching commons-.+ (see it as java regular expression) for their organisation name and module name are transformed into projects whose organisation is apache with the module name as it was found. The same kind of rule is applied for others apache projects like ant, etc. For example, ['ant','ant','1.6.2'] in ibiblio-maven2 namespace will become ['apache','ant','1.6.2'] int the system namespace.</li>
</ul>
<h3>rule handling new apache projects</h3>
<code type="xml"><rule> <!-- new apache projects -->
    <fromsystem>
        <src org="apache" />
        <dest org="org.apache"/>
    </fromsystem>
    <tosystem>
        <src org="org.apache" />
        <dest org="apache" />
    </tosystem>
</rule></code>
The mapping adds or removes the package 'org' before the organisation name to conform to maven2 choices.]]>
</content>
</node>
<node id="node-421">
<nodeinfo  path='ivy/doc/tutorial/build-repository/advanced2' md5_body='3afa793e76cfc81760d1f9d4ae208867' weight='2' depth='4' type='book' author='matthieu' uid='5' created='1138177598' status='1' format='4' sticky='0' promote='0'/>
<title>Advanced repository - step 2</title>
<teaser>
<![CDATA[<h1>Building the professional repository</h1>
Now that we have been well prepared, let's go to a real life example of building our repository.
We will now focus on a bigger example that uses different public repositories to retrieve the information.
In this tutorial we will use, in order of preference :<ul><li>our home made repository</li><li>ivyrep official</li><li>ibiblio maven2</li></ul>
<h2>the resolvers used</h2>
<code type="xml"><resolvers>
    <filesystem name="local-repository">
        <ivy pattern="${dest.repo.dir}/[organisation]/[module]/ivys/ivy-[revision].xml"/>
        <artifact pattern="${dest.repo.dir}/[organisation]/[module]/[type]s/[artifact]-[revision].[type]"/>]]>
</teaser>
<content>
<![CDATA[<h1>Building the professional repository</h1>
Now that we have been well prepared, let's go to a real life example of building our repository.
We will now focus on a bigger example that uses different public repositories to retrieve the information.
In this tutorial we will use, in order of preference :<ul><li>our home made repository</li><li>ivyrep official</li><li>ibiblio maven2</li></ul>
<h2>the resolvers used</h2>
<code type="xml"><resolvers>
    <filesystem name="local-repository">
        <ivy pattern="${dest.repo.dir}/[organisation]/[module]/ivys/ivy-[revision].xml"/>
        <artifact pattern="${dest.repo.dir}/[organisation]/[module]/[type]s/[artifact]-[revision].[type]"/>
    </filesystem>

    <chain name="libraries" returnFirst="false">
        <resolver ref="local-repository" />
        <ivyrep name="official-ivy-rep"/>
        <resolver ref="ibiblio-maven2" />
    </chain>
</resolvers>
</code>
We start the chain with our home made repository because as we can expect, we consider this repository as good ivy file repository (that's why we create it). So all files that are in this repository are considered as valid and correct and usuable.
The building process is then an iterative process. 
After each import of new projects into our repository, we check and modify the generated ivy files (or you do not as you want). The generated ivy files are those that were translated from a POM or those for which an artifact has been found without a module descriptor (ivy or pom).

<h2>Let's go</h2>
What about to test our configuration with a big project : hibernate 3.0
Just run : ant advanced

Here we go !!!!!!!!

<div class="shell"><pre>Z:\build-a-ivy-repository>ant advanced
Buildfile: build.xml

init-advanced:
:: Ivy non official version :: http://ivy.jayasoft.org/ ::
:: configuring :: file = Z:\build-a-ivy-repository\config\ivy-conf-advanced.xml

advanced:
:: installing [ hibernate | hibernate | 3.0 ] ::
:: resolving dependencies ::
        found [ hibernate | hibernate | 3.0 ] in ibiblio-maven2
        found [ apache | commons-logging | 1.0.4 ] in official-ivy-rep
        found [ apache | ant | 1.6.3 ] in ibiblio-maven2
        found [ c3p0 | c3p0 | 0.8.4.5 ] in official-ivy-rep
        found [ proxool | proxool | 0.8.3 ] in official-ivy-rep
        found [ ehcache | ehcache | 1.1 ] in official-ivy-rep
        found [ apache | xerces | 2.5.0 ] in official-ivy-rep
        found [ apache | commons-collections | 2.1.1 ] in official-ivy-rep
        found [ opensymphony | oscache | 2.1 ] in ibiblio-maven2
        found [ swarmcache | swarmcache | 1.0RC2 ] in official-ivy-rep
        found [ apache | commons-collections | 2.1 ] in official-ivy-rep
        found [ apache | commons-logging | 1.0.2 ] in official-ivy-rep
        found [ jgroups | jgroups | 2.2 ] in official-ivy-rep
        found [ jboss | jboss-cache | 1.2.2 ] in ibiblio-maven2
        found [ jboss | jboss-system | 4.0.2 ] in ibiblio-maven2
        found [ jboss | jboss-common | 4.0.2 ] in ibiblio-maven2
        found [ jboss | jboss-minimal | 4.0.2 ] in ibiblio-maven2
        found [ jboss | jboss-j2se | 200504122039 ] in ibiblio-maven2
        found [ concurrent | concurrent | 1.3.4 ] in ibiblio-maven2
        found [ jgroups | jgroups-all | 2.2.7 ] in ibiblio-maven2
        found [ cglib | cglib | 2.0.2 ] in official-ivy-rep
        found [ objectweb | asm | 1.3.4 ] in official-ivy-rep
        found [ asm | asm | 1.4.3 ] in ibiblio-maven2
        found [ javax.security | jacc | 1.0 ] in ibiblio-maven2
        found [ dom4j | dom4j | 1.6 ] in ibiblio-maven2
        found [ javax.transaction | jta | 1.0.1B ] in ibiblio-maven2
        found [ hibernate | antlr | 2.7.5H3 ] in ibiblio-maven2
        found [ odmg | odmg | 3.0 ] in official-ivy-rep
:: downloading artifacts to cache ::
downloading http://www.ibiblio.org/maven2/hibernate/hibernate/3.0/hibernate-3.0.jar ...
..................................................
.. (1565kB)
        [SUCCESSFUL ] [ hibernate | hibernate | 3.0 ]/hibernate.jar[jar] (8500ms)
downloading http://www.ibiblio.org/maven2/hibernate/antlr/2.7.5H3/antlr-2.7.5H3.jar ...

           SOME MINUTES LATER !!!!!!!!!!

downloading http://www.ibiblio.org/maven/commons-logging/jars/commons-logging-1.0.4.jar ...
........ (37kB)
        [SUCCESSFUL ] [ apache | commons-logging | 1.0.4 ]/commons-logging.jar[jar] (1110ms)
:: installing in local-repository ::
        published hibernate to Z:\build-a-ivy-repository/ivy-local-repository/hibernate/hibernate/jars/hibernate-3.0.jar
        published ivy to Z:\build-a-ivy-repository/ivy-local-repository/hibernate/hibernate/ivys/ivy-3.0.xml
        published antlr to Z:\build-a-ivy-repository/ivy-local-repository/hibernate/antlr/jars/antlr-2.7.5H3.jar
        published ivy to Z:\build-a-ivy-repository/ivy-local-repository/hibernate/antlr/ivys/ivy-2.7.5H3.xml
        published dom4j to Z:\build-a-ivy-repository/ivy-local-repository/dom4j/dom4j/jars/dom4j-1.6.jar
        published ivy to Z:\build-a-ivy-repository/ivy-local-repository/dom4j/dom4j/ivys/ivy-1.6.xml
missing artifact [ javax.security | jacc | 1.0 ]/jacc.jar[jar]: Z:\build-a-ivy-repository\cache\javax.security\jacc\jars\jacc-1.0.jar file does not exist
        published ivy to Z:\build-a-ivy-repository/ivy-local-repository/javax.security/jacc/ivys/ivy-1.0.xml
        published asm to Z:\build-a-ivy-repository/ivy-local-repository/asm/asm/jars/asm-1.4.3.jar
        published ivy to Z:\build-a-ivy-repository/ivy-local-repository/asm/asm/ivys/ivy-1.4.3.xml
        published cglib-full to Z:\build-a-ivy-repository/ivy-local-repository/cglib/cglib/jars/cglib-full-2.0.2.jar
        published cglib to Z:\build-a-ivy-repository/ivy-local-repository/cglib/cglib/jars/cglib-2.0.2.jar
        published ivy to Z:\build-a-ivy-repository/ivy-local-repository/cglib/cglib/ivys/ivy-2.0.2.xml
        published asm to Z:\build-a-ivy-repository/ivy-local-repository/objectweb/asm/jars/asm-1.3.4.jar
        published asm-util to Z:\build-a-ivy-repository/ivy-local-repository/objectweb/asm/jars/asm-util-1.3.4.jar
        published ivy to Z:\build-a-ivy-repository/ivy-local-repository/objectweb/asm/ivys/ivy-1.3.4.xml
        published jboss-cache to Z:\build-a-ivy-repository/ivy-local-repository/jboss/jboss-cache/jars/jboss-cache-1.2.2.jar
        published ivy to Z:\build-a-ivy-repository/ivy-local-repository/jboss/jboss-cache/ivys/ivy-1.2.2.xml
        published jgroups-all to Z:\build-a-ivy-repository/ivy-local-repository/jgroups/jgroups-all/jars/jgroups-all-2.2.7.jar
        published ivy to Z:\build-a-ivy-repository/ivy-local-repository/jgroups/jgroups-all/ivys/ivy-2.2.7.xml
        published concurrent to Z:\build-a-ivy-repository/ivy-local-repository/concurrent/concurrent/jars/concurrent-1.3.4.jar
        published ivy to Z:\build-a-ivy-repository/ivy-local-repository/concurrent/concurrent/ivys/ivy-1.3.4.xml
        published jboss-j2se to Z:\build-a-ivy-repository/ivy-local-repository/jboss/jboss-j2se/jars/jboss-j2se-200504122039.jar
        published ivy to Z:\build-a-ivy-repository/ivy-local-repository/jboss/jboss-j2se/ivys/ivy-200504122039.xml
        published jboss-minimal to Z:\build-a-ivy-repository/ivy-local-repository/jboss/jboss-minimal/jars/jboss-minimal-4.0.2.jar
        published ivy to Z:\build-a-ivy-repository/ivy-local-repository/jboss/jboss-minimal/ivys/ivy-4.0.2.xml
        published jboss-system to Z:\build-a-ivy-repository/ivy-local-repository/jboss/jboss-system/jars/jboss-system-4.0.2.jar
        published ivy to Z:\build-a-ivy-repository/ivy-local-repository/jboss/jboss-system/ivys/ivy-4.0.2.xml
        published swarmcache to Z:\build-a-ivy-repository/ivy-local-repository/swarmcache/swarmcache/jars/swarmcache-1.0RC2.jar
        published ivy to Z:\build-a-ivy-repository/ivy-local-repository/swarmcache/swarmcache/ivys/ivy-1.0RC2.xml
missing artifact [ jgroups | jgroups | 2.2 ]/jgroups.jar[jar]: Z:\build-a-ivy-repository\cache\jgroups\jgroups\jars\jgroups-2.2.jar file does not exist
        published ivy to Z:\build-a-ivy-repository/ivy-local-repository/jgroups/jgroups/ivys/ivy-2.2.xml
        published commons-logging to Z:\build-a-ivy-repository/ivy-local-repository/apache/commons-logging/jars/commons-logging-1.0.2.jar
        published ivy to Z:\build-a-ivy-repository/ivy-local-repository/apache/commons-logging/ivys/ivy-1.0.2.xml
        published oscache to Z:\build-a-ivy-repository/ivy-local-repository/opensymphony/oscache/jars/oscache-2.1.jar
        published ivy to Z:\build-a-ivy-repository/ivy-local-repository/opensymphony/oscache/ivys/ivy-2.1.xml
        published c3p0 to Z:\build-a-ivy-repository/ivy-local-repository/c3p0/c3p0/jars/c3p0-0.8.4.5.jar
        published ivy to Z:\build-a-ivy-repository/ivy-local-repository/c3p0/c3p0/ivys/ivy-0.8.4.5.xml
        published odmg to Z:\build-a-ivy-repository/ivy-local-repository/odmg/odmg/jars/odmg-3.0.jar
        published ivy to Z:\build-a-ivy-repository/ivy-local-repository/odmg/odmg/ivys/ivy-3.0.xml
        published proxool to Z:\build-a-ivy-repository/ivy-local-repository/proxool/proxool/jars/proxool-0.8.3.jar
        published ivy to Z:\build-a-ivy-repository/ivy-local-repository/proxool/proxool/ivys/ivy-0.8.3.xml
missing artifact [ javax.transaction | jta | 1.0.1B ]/jta.jar[jar]: Z:\build-a-ivy-repository\cache\javax.transaction\jta\jars\jta-1.0.1B.jar file does not exist
        published ivy to Z:\build-a-ivy-repository/ivy-local-repository/javax.transaction/jta/ivys/ivy-1.0.1B.xml
        published jboss-common to Z:\build-a-ivy-repository/ivy-local-repository/jboss/jboss-common/jars/jboss-common-4.0.2.jar
        published ivy to Z:\build-a-ivy-repository/ivy-local-repository/jboss/jboss-common/ivys/ivy-4.0.2.xml
        published ant to Z:\build-a-ivy-repository/ivy-local-repository/apache/ant/jars/ant-1.6.3.jar
        published ivy to Z:\build-a-ivy-repository/ivy-local-repository/apache/ant/ivys/ivy-1.6.3.xml
        published commons-collections to Z:\build-a-ivy-repository/ivy-local-repository/apache/commons-collections/jars/commons-collections-2.1.jar
        published ivy to Z:\build-a-ivy-repository/ivy-local-repository/apache/commons-collections/ivys/ivy-2.1.xml
        published ehcache to Z:\build-a-ivy-repository/ivy-local-repository/ehcache/ehcache/jars/ehcache-1.1.jar
        published ivy to Z:\build-a-ivy-repository/ivy-local-repository/ehcache/ehcache/ivys/ivy-1.1.xml
        published commons-collections to Z:\build-a-ivy-repository/ivy-local-repository/apache/commons-collections/jars/commons-collections-2.1.1.jar
        published ivy to Z:\build-a-ivy-repository/ivy-local-repository/apache/commons-collections/ivys/ivy-2.1.1.xml
        published xercesImpl to Z:\build-a-ivy-repository/ivy-local-repository/apache/xerces/jars/xercesImpl-2.5.0.jar
        published ivy to Z:\build-a-ivy-repository/ivy-local-repository/apache/xerces/ivys/ivy-2.5.0.xml
        published commons-logging to Z:\build-a-ivy-repository/ivy-local-repository/apache/commons-logging/jars/commons-logging-1.0.4.jar
        published ivy to Z:\build-a-ivy-repository/ivy-local-repository/apache/commons-logging/ivys/ivy-1.0.4.xml
:: install resolution report ::
        ---------------------------------------------------------------------
        |                  |            modules            ||   artifacts   |
        |       conf       | number| search|dwnlded|evicted|| number|dwnlded|
        ---------------------------------------------------------------------
        |      default     |   28  |   28  |   28  |   0   ||   30  |   27  |
        ---------------------------------------------------------------------

BUILD SUCCESSFUL
Total time: 2 minutes 10 seconds
Z:\build-a-ivy-repository></pre></div>

<h2>Analysing the results</h2>
OK, it seems that we have a good start point for our repository.
As you can see in the resolving part of the process :
<div class="shell"><pre>:: resolving dependencies ::
        found [ hibernate | hibernate | 3.0 ] in ibiblio-maven2
        found [ apache | commons-logging | 1.0.4 ] in official-ivy-rep
        ...
        found [ odmg | odmg | 3.0 ] in official-ivy-rep</pre></div>
some ivy files were retrieved from the <a href="http://ivyrep.jayasoft.org">ivyrep</a> the official ivy repository. That significates that for these modules, you have in your home made repository good ivy files (with meaningfull configurations, ...).

<h2>And now</h2>
Now what you need to do is to download missing artifacts, those not on ibiblio (from sun, ...) and correct the generated ivy files. 
It is important to make a review of the generated ivy files because you could then benefit from all the power of ivy by defining for those projects good configurations and some other good things.

To ease finding generated files, just take a look at the generated resolve report in your cache. You will find there the projects for which a default ivy file was generated 
<center><img src="/misc/ivy/samples/commons-lang1.0-dep-report-part.jpg" style="padding:1em;"/></center>
and you can see the resolvers that have resolved the modules. In our example, you will update the files whose project were resolved by the ibiblio-maven2 resolver.
<center><img src="/misc/ivy/samples/hibernate3.0-dep-report-part.jpg" style="padding:1em;"/></center>

]]>
</content>
</node>
</node>
<node id="node-739">
<nodeinfo  path='node/739' md5_body='88515a7b5129428743bb4b30332d5760' weight='15' depth='3' type='book' author='xavier' uid='6' created='1156221382' status='1' format='4' sticky='0' promote='0'/>
<title>More examples</title>
<teaser>
<![CDATA[If you have successfully followed and understood all the tutorials, maybe you still need to get a better picture of how to use Ivy in the real world.

Here are some links which can be interesting:

<h3><a href="http://wiki.hippo.nl/display/OS/SAnt+build+system">SAnt</a></h3>
SAnt is an experimental build system based on Ant and Ivy. It can be interesting to use as is or to get insight on an interesting approach to manage your builds.

<h3><a href="http://dehora.net/code/antant/readme.html">AntAnt</a></h3>
AntAnt is an ant project generator (generates an ant project skeleton), which uses ivy for dependency management. It can be an interesting place to look for examples of ant build files integrated with ivy.]]>
</teaser>
<content>
<![CDATA[If you have successfully followed and understood all the tutorials, maybe you still need to get a better picture of how to use Ivy in the real world.

Here are some links which can be interesting:

<h3><a href="http://wiki.hippo.nl/display/OS/SAnt+build+system">SAnt</a></h3>
SAnt is an experimental build system based on Ant and Ivy. It can be interesting to use as is or to get insight on an interesting approach to manage your builds.

<h3><a href="http://dehora.net/code/antant/readme.html">AntAnt</a></h3>
AntAnt is an ant project generator (generates an ant project skeleton), which uses ivy for dependency management. It can be an interesting place to look for examples of ant build files integrated with ivy.

<h3><a href="https://springmodules.dev.java.net/">Spring Modules</a></h3>
The spring modules project build system is based on Ant and Ivy, and it's really interesting to have a look at how a modularized project can take advantage of advanced ant and ivy features to make the build simpler.

<h3><a href="http://www.opensymphony.com/webwork/">Webwork</a></h3>
The webwork project (which should become struts action framework) uses ant+ivy for their build, and thus make their framework very easy to use in an ant+ivy build system. They have a <a href="http://wiki.opensymphony.com/display/WW/Dependencies">page documenting how to use ivy with their framework</a>, which can be an interesting reading even if you don't plan to use webwork.
]]>
</content>
</node>
</node>
<node id="node-40">
<nodeinfo  path='ivy/doc/reference' md5_body='3a0993d60556c381a52f0c3b1a630438' weight='0' depth='2' type='book' author='admin' uid='1' created='1117212912' status='1' format='4' sticky='0' promote='1'/>
<title>Reference</title>
<teaser>
<![CDATA[Welcome to Ivy reference documentation. 

If you don't know Ivy at all, give a glance at its <a href="./ivy/features">features</a>, the <a href="./ivy/faq">FAQ</a> and the <a href="./ivy/doc/tutorial">tutorials</a> before digging into this reference documentation.

<h1>Reference Overview</h1>
This documentation is decomposed in several parts:
<ul>
<li><a href="./ivy/doc/terminology">Terminology</a></li>
This part gives you the meaning of some words used all over ivy doc, such as organisation, module, configurations, ...
<li><a href="./ivy/doc/concept">Main Concepts</a></li>
This part introduces the main concepts used in Ivy: dependency resolvers, variables, patterns, and also a good introduction to a central ivy concept: module configurations.]]>
</teaser>
<content>
<![CDATA[Welcome to Ivy reference documentation. 

If you don't know Ivy at all, give a glance at its <a href="./ivy/features">features</a>, the <a href="./ivy/faq">FAQ</a> and the <a href="./ivy/doc/tutorial">tutorials</a> before digging into this reference documentation.

<h1>Reference Overview</h1>
This documentation is decomposed in several parts:
<ul>
<li><a href="./ivy/doc/terminology">Terminology</a></li>
This part gives you the meaning of some words used all over ivy doc, such as organisation, module, configurations, ...
<li><a href="./ivy/doc/concept">Main Concepts</a></li>
This part introduces the main concepts used in Ivy: dependency resolvers, variables, patterns, and also a good introduction to a central ivy concept: module configurations.
<li><a href="./ivy/doc/principle">How does it work ?</a></li>
As the title suggest, here you will have some explanations on how does ivy work internally, which can help to better understand and customize its use.
<li><a href="./ivy/doc/install"/>Installation</a></li>
This part describe how to install Ivy
<li><a href="./ivy/doc/configuration"/>Configuration</a></li>
This part is dedicated to the specification of the configuration file of Ivy (usually called ivyconf.xml). It also gives the list of built-in dependency resolvers available in ivy.
<li><a href="./ivy/doc/ivyfile"/>Ivy files</a></li>
This part is the reference of the specification of the ivy files, the files in which you describe your dependencies. If you have any question of what can be done or not in an ivy file, you will have the answer here.
<li><a href="./ivy/doc/use"/>Use</a></li>
This part describes how to use ivy: it briefly explains how to call ivy from command line, and deeply explains how to use it from ant, which is the main way to use ivy. It's in this section that all ant tasks brought by ivy are specified.
<li><a href="./ivy/doc/extend"/>Extend</a></li>
This part describes how to extend ivy, by writing your own dependency resolver, latest strategy, etc.
</ul>
]]>
</content>
<node id="node-106">
<nodeinfo  path='ivy/doc/terminology' md5_body='ab9c5bd3bc9171a3c24afbdea2fa011f' weight='-15' depth='3' type='book' author='admin' uid='1' created='1118037725' status='1' format='3' sticky='0' promote='1'/>
<title>Terminology</title>
<teaser>
<![CDATA[Here are some terms used in Ivy, with their definitions in Ivy:<br/>
<h2>Ivy file</h2>
An ivy file is an xml file which is used to describe dependencies of a module (see below). It is usually named ivy.xml.
<h2>Configuration file</h2>
Ivy configuration files are xml files used to configure ivy to indicate where the dependencies can be found. This should not be confused with a module configuration (see below).
<h2>Organisation</h2>
An organisation is either a company or a simple group of person
which produce software. Ivy handle only one level of organisation, so you cannot
describe a company hierarchy with this concept. But it is used to group sofware]]>
</teaser>
<content>
<![CDATA[Here are some terms used in Ivy, with their definitions in Ivy:<br/>
<h2>Ivy file</h2>
An ivy file is an xml file which is used to describe dependencies of a module (see below). It is usually named ivy.xml.
<h2>Configuration file</h2>
Ivy configuration files are xml files used to configure ivy to indicate where the dependencies can be found. This should not be confused with a module configuration (see below).
<h2>Organisation</h2>
An organisation is either a company or a simple group of person
which produce software. Ivy handle only one level of organisation, so you cannot
describe a company hierarchy with this concept. But it is used to group sofware
produced by a same team, just to help find and classify them.<br/>
<i>Examples: apache, ibm, jayasoft</i>
<h2>Module</h2>
A module in ivy is a piece of software that is reusable, and that 
follow a unique cycle of revision. <br/>
<i>Examples: hibernate, ant, ...</i>
<h2>Artifact</h2>
An artifact is a single file produced by a company when releasing a module. In 
the java world, common artifacts are jars. In many cases, each revision of a 
module publish only one artifact (like log4j, for instance), but some of them
publish many artifacts dependending on the use of the module (like ant, for instance).
<h2>Revision</h2>
A revision corresponds to one delivery of a module. It can either be a delivery
of a release, a milestone, a beta version, a nightly build, or even a continuous
build. All of them are considered revisions in ivy.
<h2>Configuration</h2>
A module configuration is a way to use or construct a module. Some modules may be 
used in different ways (think about hibernate which can be used inside or outside
an application server), and this way may alter the artifacts you need (in the case
of hibernate, jta.jar is needed only if it is used outside an application server).
Moreover, a module may need some other modules and artifacts only at build time,
and some others at runtime. All those differents ways to use or build a module
are called in ivy configurations. <br/><br/>

For more details on configurations and how they are used in ivy, please refer to the <a href="./ivy/doc/concept">main concepts page</a>.
<h2>Status</h2>
A module status indicates how stable a module revision can be considered. It can 
be used to consolidate the status of all the dependencies of a module, to prevent
the use of an integration revision of a dependency in the release of your module.
Currently, three status are used in ivy:
<ul>
<li>integration: revisions builded by a continuous build, a nightly build, and so on, fall in this category</li>
<li>milestone: revisions delivered to the public but not actually finished fall in this category</li>
<li>release: revision fully tested and labelled fall in this category</li>
</ul>

]]>
</content>
</node>
<node id="node-107">
<nodeinfo  path='ivy/doc/concept' md5_body='9555ee95825158fc4a382f28cd242b47' weight='-13' depth='3' type='book' author='admin' uid='1' created='1118037893' status='1' format='3' sticky='0' promote='1'/>
<title>Main Concepts</title>
<teaser>
<![CDATA[<h1>Dependency Resolver</h1>
A dependency resolver is a pluggable class in ivy which is used to:<br/>
<ul>
<li>find dependencies ivy files</li>
<li>download dependencies artifacts</li>
</ul>
The notion of artifact "downloading" is large: artifact can be on a web site, or
on the local file system of your machine. The download is thus the fact to bring
a file from a repository to ivy cache.<br/> 
<br/>
Moreover, the fact that it is the 
responsibility of the resolver to find ivy files and download artifacts help
to implement various resolving strategies.<br/>
<br/>
As you see, a dependency resolver can be thought as a class responsible of]]>
</teaser>
<content>
<![CDATA[<h1>Dependency Resolver</h1>
A dependency resolver is a pluggable class in ivy which is used to:<br/>
<ul>
<li>find dependencies ivy files</li>
<li>download dependencies artifacts</li>
</ul>
The notion of artifact "downloading" is large: artifact can be on a web site, or
on the local file system of your machine. The download is thus the fact to bring
a file from a repository to ivy cache.<br/> 
<br/>
Moreover, the fact that it is the 
responsibility of the resolver to find ivy files and download artifacts help
to implement various resolving strategies.<br/>
<br/>
As you see, a dependency resolver can be thought as a class responsible of
describing a repository.<br/><br/>
If you want to see which resolvers are available in ivy, you can go to the corresponding <a href="./ivy/doc/configuration/resolvers">configuration section</a>

<h1>Module configurations explained</h1>
Module configurations are described in the terminology page as <em>a way to use or construct a module</em>. Configurations being a central part of Ivy, they need more explanations as a concept.<br/>
<br/>
When you define a way to use or construct a module, you are able to define which artifacts are published by this module in this configuration, and you are also able to define which dependencies are needed in this configuration.<br/><br/>

Moreover, because dependencies in ivy are expressed on modules and not on artifacts, it is important to be able to define which configurations of the dependency are required in the configuration you define of your module. That's what is called <strong>configuration mapping</strong>.<br/><br/>

If you use only simple modules and do not want to worry about configurations, you don't have to worry about them. They're still there under the hood, cause ivy can't work without configuration. But most of the time if you declare nothing, ivy assumes that the artifacts of your module are published in all configurations, and that all the dependencies configurations are required in all configurations. And it works in simple cases. But whenever you want to separate things within a module, or get more control over things published and got through dependencies resolution, configuration may answer most of your needs.<br/><br/>

For details on how to declare your module configurations, how declare in which configuration your artifacts are published, and how to declare configuration mapping, please refer to <a href="./ivy/doc/ivyfile">ivy file documentation</a>.

<h1>Variables</h1>
During configuration, ivy allows to define what are called ivy variables. Ivy variables can be seen as ant properties,
and are used in a very similar way. In particular, you use a properties tag in the configuration file to load
a properties file containing ivy variables and their values.<br/><br/>

But the main differences between ant properties and ivy variables are that ivy variables can be overriden, whereas ant 
properties can't, and that they are defined in separate environment.<br/><br/>

In fact all ant properties are imported into ivy variables when the configuration is done (if you call ivy from ant). 
This means that if you define an ant property after the call to configure, it will not be available
as an ivy variable.<br/>
On the other hand, ivy variables are NOT exported to ant, thus if you define ivy variables in ivy, do not try to use
them as ant properties.<br/><br/>

To use ivy variables, you just have to follow that same syntax as for ant properties:<br/>
${<i>variablename</i>}<br/>
where <i>variablename</i> is the name of the variable.<br/><br/>

Finally, it's also important to be aware of the time of substitution of variables. This substitution is done as soon as possible. This means that when ivy encounter a reference to a variable, it tries to substitute it if such a variable is defined. Consequently, <strong>any later modification of the variable will not alter the value already substituted</strong>.
<br/><br/>
Moreover, in an ant environment, a bunch of variables are going to be set by default via the ant property file loading mechanism (in fact they are first loaded as ant properties and then imported as ivy variables, see <a href="./ivy/doc/use"></a>), and even in the ant properties themselves there is going to be eager substitution on loading, effectively making it impossible to override some variable purely via the ivyconf.properties file. Some variables will really only be able to be overriden via ant properties because of this.<br/><br/>

Moreover, it's also important to understand the difference between ivy variables and ivy pattern tokens. 
See Patterns chapter below to see what pattern tokens are.
<h1>Patterns</h1>

Ivy patterns are used in many dependency resolvers and ivy tasks, and are a simple way to structure the way ivy works.<br/><br/>

First let's give an example. You can for instance configure the file system dependency resolver by giving it
a pattern to find artifacts. This pattern can be like this:<br/>
myrepository/[organisation]/[module]/[type]s/[artifact]-[revision].[ext]<br/>
This pattern indicates that the repository we use is in a directory called myrepository. 
In this directory we have directories having for name the name of the organisation of the module we look for. 
Then we have a directory per module, each having for name the name of the module.
Then in module directories we find a directory per artifact type (jars, wars, ivys, ...), in which we find
artifacts named by the artifact id, followed by an hyphen, then the revision, a dot, and the artifact extension.
Not too difficult to understand, isn't it ? That's it, you have understood the pattern concept !<br/><br/>

To give a bit more explanation, a pattern is composed of tokens, which are replaced by true values when
evaluated for a particular artifact or module. Those tokens are different from variables because they are
replaced differently for each artifact, whereas variables are usually given the same value.<br/><br/>

You can mix variables and tokens in a pattern:<br/>
${repository.dir}/[organisation]/[module]/[type]s/[artifact]-[revision].[ext]<br/><br/>

The tokens available depends on where the pattern is used (will it be evaluated with artifacts or modules, for instance).
But here are all the tokens currently available:<br/>
<b>[organisation]</b> the organisation name<br/>
<b>[module]</b> the module name<br/>
<b>[revision]</b> the revision name<br/>
<b>[artifact]</b> the artifact name (or id)<br/>
<b>[type]</b> the artifact type<br/>
<b>[ext]</b> the artifact file extension<br/>
<b>[conf]</b> the configuration name<br/><br/>

Difference between type and extension are explained in ivy file documentation.<br/>
<br/>
<span class="since">since 1.2</span> [organization] can be used instead of [organisation].<br/><br/>

<span class="since">since 1.3</span> Optinal parts can be used in patterns. <br/>
This let the possibility to avoid some input when a token is not defined, instead of having only the token as blank. Parenthesis are used to delimit the optional part, and only one token can be found inside the parenthesis.<br/>
So if you surround a token with '(' and ')', any other text which is between the parenthesis will be ignored if the token has no value.<br/><br/>

For instance, suppose the pattern: "abc(def[type]ghi)"<br/>
type = "jar" -> the substituted pattern: abcdefjarghi<br/>
type = null or "" -> the substitued pattern: abc <br/><br/>

A more real life example:<br/>
The pattern <code>[artifact](-[revision]).[ext]</code> let you accept both myartifact-1.0.jar when a revision is set, and myartifact.jar (instead of myartifact-.jar) when no revision is set<br/>
This is particularly useful when you need to keep control on artifact names.

<h1>Latest Strategy</h1>
Ivy often needs to know which revision between two has to be considered the "latest". For knowing that,
it uses the concept of latest strategy. Indeed, there are several way to consider a revision to be the latest.
You can choose an existing one or plug your own.<br/><br/>
But before knowing which revision is the latest, ivy needs to be able to consider several revision of a module. Thus ivy has to get a list of files in a directory, and it uses the dependency resolver for that. So check if the dependency resolver you use is compatible with latest revisions before wondering why ivy do not manage to get your latest revision.<br/><br/>
Finally, In order to get several revisions of a module, most of the time you need to use the [revision] token in your pattern, so that ivy gets all the files which match the pattern whatever the revision is. It's only then that the latest strategy is used to determine which of this revisions is the latest one.<br/><br/>

Ivy has three built-in latest strategies:<br/>
<ul>
<li>latest-time</li> it compares the revisions date to know which is the latest. While this is often a good 
strategy in terms of pertinence, it has the drawback to be costful to compute with distant repositories. If you use ivyrep, 
for example, ivy has to ask the http server what is the date of each ivy file before knowing which is the latest.<br/>
<li>latest-revision</li> it compares the revisions as string, using an algorithm close to the one used in the php version_compare function.
This algorithm takes into account special meaning of some text. For instance, with this strategy, 1.0-dev1 is considered
before 1.0-alpha1, which in turn is before 1.0-rc1, which is before 1.0, which is before 1.0.1.<br/>
<li>latest-lexico</li>: it compares the revisions as string, using lexicographic order (the one used by java string comparison).
</ul>

<h1>Conflict Manager</h1>
A conflict manager is able
to select, among a list of module revisions in conflict, a list of revisions to keep.
Yes, it can selects a list of revision, even if most conflicts manager select only one revision.
But in some cases you will need to keep several revisions, and load in separate class loaders,
for example.<br/><br/>

A list of revisions is said to be in conflict if they correspond to the same module, i.e. the same
organisation/module name couple.<br/><br/>

Ivy comes with 4 built-in conflicts manager, but you can also plug your own:<br/>
- all: this conflicts manager resolve conflicts by selecting all revisions. Also 
called NoConflictManager, it does evict any module.<br/>
- fixed: this conflict manager always select the same revision<br/>
- latest-time: this conflict manager selects only the 'latest' revision, 
latest being defined as the latest in time. Note that latest in time
is costly to compute, so prefer latest-revision if you can.<br/>
- latest-revision: this conflict manager selects only the 'latest' revision, 
latest being defined by a string comparison of revisions as defined by the latest-revision strategy.<br/><br/>

To have more details on how to setup your conflict managers and on how they work, see <a href="./ivy/doc/ivyfile">ivy file</a> reference.

<h1>Pattern matcher</h1>
<span class="since">since 1.3</span>
At several places Ivy let uses pattern to match a set of objects. For instance, you can exclude several modules at once when declaring a dependency by using a pattern matching all the modules to exclude.<br/><br/>

Ivy uses pluggable pattern matcher to match those object names. 3 are defined by default:
<ul>
<li>exact</li>This matcher matches only string when they are equal to the pattern one
<li>regexp</li>This matcher let you use regular expression as supported by the Pattern class of java 1.4 or greater
<li>glob</li>This matcher let you use unix like glob matcher, i.e. where the only meta characters are * which matches any sequence of characters and ? which matches exactly one character. Note that this matcher is available only with jakarta oro 2.0.8 in your classpath.
</ul>
Note also that with any matcher the character '*' has the special meaning of matching anything. This is particularly useful with default values which do not depend on the matcher.]]>
</content>
</node>
<node id="node-109">
<nodeinfo  path='ivy/doc/principle' md5_body='98989ccb828796ca4a72b0985b6bf795' weight='-12' depth='3' type='book' author='admin' uid='1' created='1118136132' status='1' format='4' sticky='0' promote='0'/>
<title>How does it work ?</title>
<teaser>
<![CDATA[Now that you have been introduced to main ivy terminology and concepts, it is time to give some explanations about how ivy works.

Here are the steps followed by ivy to resolve your dependencies:
<h1>Configure</h1>
Ivy needs to be configured to be able to resolve your dependencies. This configuration is usually done with a configuration file, which defines a set of dependency resolvers. Each resolver is able to find ivy files and / or artifacts, given simple information such as organition, module, revision, artifact name, artifact type and artifact extension. 

The configuration is also responsible for indicating which resolver should be used to resolve which module. This configuration is dependent only on your environment, i.e. where the modules and artifacts can be found. ]]>
</teaser>
<content>
<![CDATA[Now that you have been introduced to main ivy terminology and concepts, it is time to give some explanations about how ivy works.

Here are the steps followed by ivy to resolve your dependencies:
<h1>Configure</h1>
Ivy needs to be configured to be able to resolve your dependencies. This configuration is usually done with a configuration file, which defines a set of dependency resolvers. Each resolver is able to find ivy files and / or artifacts, given simple information such as organition, module, revision, artifact name, artifact type and artifact extension. 

The configuration is also responsible for indicating which resolver should be used to resolve which module. This configuration is dependent only on your environment, i.e. where the modules and artifacts can be found. 

A default configuration is used by ivy when none is given. This configuration uses ivyrep to resolve all modules.
<h1>Resolve</h1>
The resolve time is the moment when ivy actually resolve the dependencies of one module. It first needs to access the ivy file of the module for which it resolves the dependencies. 

Then, for each dependency declared in this file, it asks the appropriate resolver (according to configuration) to find the module (i.e. either an ivy file for it, or its artifacts if no ivy file can be found). It also uses a filesystem based cache to avoid asking for a dependency if it is already in cache (at least if possible, which is not the case with latest revisions).

If the resolver is a composite one (i.e. a chain or a dual resolver), several resolvers may actually be called to find the module.

When the dependency module has been found, its ivy file is downloaded to ivy cache. Then ivy checks if it has itself dependencies, in which case it recursilvely traverse the graph of dependencies. 

All over this traversal, conflict management are done to prevent the access to a module as soon as possible.

When ivy has traversed the whole graph, it asks to the resolvers to download the artifacts corresponding to each dependencies which are not already in cache and which have not been evicted by conflict managers. All downloads are made to ivy cache.

Finally, an xml report is generated in cache, which allows ivy to easily know what are all the dependencies of the module, without traversing the graph again.

After this resolve step, two main steps are possible: either build a path with artifacts in cache, or copy them to another directory structure.

<h1>Retrieve</h1>
What is called retrieve in ivy is the fact to copy artifacts from the cache to another directory structure. This is done using a pattern, which indicates to ivy where the files should be copied.

For this, ivy uses the xml report in cache corresponding to the module it should retrieve to know which artifacts should be copied.

It also checks if the files are not already copied to maximize performances.
<h1>Building a path from cache</h1>
In some cases, it is preferable to use artifacts directly from the cache. Ivy is able to use the xml report generated at resolve time to build a path of all artifacts required.

This can be particularly useful especially when building plug-ins for IDE.

<h1>Reports</h1>
Finally, ivy is able to generate readable reports describing the dependencies resolution.

This is done with a simple xsl transformation of the xml report generated at resolve time.
]]>
</content>
</node>
<node id="node-41">
<nodeinfo  path='ivy/doc/install' md5_body='f5af0e784c281e93169341bcbb0008d2' weight='-11' depth='3' type='book' author='admin' uid='1' created='1117213219' status='1' format='3' sticky='0' promote='1'/>
<title>Installation</title>
<teaser>
<![CDATA[Download the latest version <a href="./ivy/download"/>here</a>, unpack the downloaded zip
file wherever you want, and copy the ivy jar file in your ant lib directory
(ANT_HOME/lib).<br/>
<br/>
If you use ant 1.6.0 or superior, you can then simply go to the src/example/hello-ivy dir and run ant: if the build
is successful, you have successfully installed Ivy !<br />
<br />
If you use ant 1.5.1 or superior, you have to modify the build files in the examples:
- remove the namespace section at their head: xmlns:ivy="antlib:fr.jayasoft.ivy.ant" <br/>
- add taskdefs for ivy tasks:<br />
<pre>
  &lt;taskdef name="ivy-configure" classname="fr.jayasoft.ivy.ant.IvyConfigure"/&gt;
  &lt;taskdef name="ivy-resolve" classname="fr.jayasoft.ivy.ant.IvyResolve"/&gt;
  &lt;taskdef name="ivy-retrieve" classname="fr.jayasoft.ivy.ant.IvyRetrieve"/&gt;
  &lt;taskdef name="ivy-publish" classname="fr.jayasoft.ivy.ant.IvyPublish"/&gt; 
</pre>
- replace ivy:xxx tasks by ivy-xxx]]>
</teaser>
<content>
<![CDATA[Download the latest version <a href="./ivy/download"/>here</a>, unpack the downloaded zip
file wherever you want, and copy the ivy jar file in your ant lib directory
(ANT_HOME/lib).<br/>
<br/>
If you use ant 1.6.0 or superior, you can then simply go to the src/example/hello-ivy dir and run ant: if the build
is successful, you have successfully installed Ivy !<br />
<br />
If you use ant 1.5.1 or superior, you have to modify the build files in the examples:
- remove the namespace section at their head: xmlns:ivy="antlib:fr.jayasoft.ivy.ant" <br/>
- add taskdefs for ivy tasks:<br />
<pre>
  &lt;taskdef name="ivy-configure" classname="fr.jayasoft.ivy.ant.IvyConfigure"/&gt;
  &lt;taskdef name="ivy-resolve" classname="fr.jayasoft.ivy.ant.IvyResolve"/&gt;
  &lt;taskdef name="ivy-retrieve" classname="fr.jayasoft.ivy.ant.IvyRetrieve"/&gt;
  &lt;taskdef name="ivy-publish" classname="fr.jayasoft.ivy.ant.IvyPublish"/&gt; 
</pre>
- replace ivy:xxx tasks by ivy-xxx<br />
You can now run the build, if it is successful, you have successfully installed Ivy !
<br />
If the build is not successful, check the <a href="./ivy/faq">FAQ</a> to see what can be the problem
with the ivyrep resolver.
]]>
</content>
</node>
<node id="node-42">
<nodeinfo  path='ivy/doc/configuration' md5_body='4ede9488d9591c73fed2dd50d8d58042' weight='-10' depth='3' type='book' author='admin' uid='1' created='1117213291' status='1' format='4' sticky='0' promote='1'/>
<title>Configuration</title>
<teaser>
<![CDATA[In order to work as you want, ivy need some configuration. Actually, ivy can work with no configuration at all, see the <a href="/ivy/doc/tutorial/defaultconf">default configuration documentation</a> for details about that. But ivy is able 
to work in very different contexts. You just have to configure it properly.

Configuration is done through an xml file, usually called ivyconf.xml. To configure ivy from ant, you just have to call the configure task and pass it the path to your configuration file (see <a href="./ivy/doc/use/configure">configure</a> task documentation for details).

Here is an example of configuration file :]]>
</teaser>
<content>
<![CDATA[In order to work as you want, ivy need some configuration. Actually, ivy can work with no configuration at all, see the <a href="/ivy/doc/tutorial/defaultconf">default configuration documentation</a> for details about that. But ivy is able 
to work in very different contexts. You just have to configure it properly.

Configuration is done through an xml file, usually called ivyconf.xml. To configure ivy from ant, you just have to call the configure task and pass it the path to your configuration file (see <a href="./ivy/doc/use/configure">configure</a> task documentation for details).

Here is an example of configuration file :
<code type="xml">
<ivyconf>
        <properties file="${ivy.conf.dir}/ivyconf-file.properties" />
        <conf defaultCache="${cache.dir}" defaultResolver="ibiblio" checkUpToDate="false" />
        <resolvers>
                <ibiblio name="ibiblio" />
                <filesystem name="internal">
                        <ivy pattern="${repository.dir}/[module]/ivy-[revision].xml" />
                        <artifact pattern="${repository.dir}/[module]/[artifact]-[revision].[ext]" />
                </filesystem>
        </resolvers>
        <modules>
                <module organisation="jayasoft" name=".*" resolver="internal" />
        </modules>
</ivyconf>
</code>
</div>
<br/>
Mainly, the configuration enables to configure the default cache directory used by ivy and the dependency resolvers that it will use to resolve dependencies.
<i>Note: To work, this configuration file needs a property file named ivyconf-file.properties in the same directory as the configuration file, with ivy variables you want in it.</i>

Some useful variables are available in ivyconf files:
<ul>
<li>ivy.conf.dir</li> this variable references the directory in which the ivyconf itself is. This is available if the ivyconf has been loaded as a file. In case of an url, it takes the part before the last slash of the url, if any. If the url has no slash, then this variable is not set.
<li>ivy.conf.file</li>the path of the ivyconf file itself, it has been loaded as a file only. If it has been loaded as an url, this variable is not set
<li>ivy.conf.url</li>the url pointing to the ivyconf file. This is set both when it has been loaded as a file or an url
</ul>

<h1>Configuration file structure</h1>

The configuration file is structured in some parts and left other open. Indeed each resolver has its own 
structure, thus it's not the configuration file itself which define the structure for the resolvers.

<pre>
ivyconf
    <a href="./ivy/doc/configuration/property">property</a>
    <a href="./ivy/doc/configuration/properties">properties</a>
    <a href="./ivy/doc/configuration/conf">conf</a>
    <a href="./ivy/doc/configuration/include">include</a>
    <a href="./ivy/doc/configuration/typedef">typedef</a>
    <a href="./ivy/doc/configuration/latest-strategies">latest-strategies</a>
    <a href="./ivy/doc/configuration/parsers">parsers</a>
    <a href="./ivy/doc/configuration/namespaces">namespaces</a>
        <a href="./ivy/doc/configuration/namespace">namespace</a>
            <a href="./ivy/doc/configuration/namespace/rule">rule</a>
                <a href="./ivy/doc/configuration/namespace/fromtosystem">fromsystem</a>
                    <a href="./ivy/doc/configuration/namespace/src">src</a>
                    <a href="./ivy/doc/configuration/namespace/dest">dest</a>
                <a href="./ivy/doc/configuration/namespace/fromtosystem">tosystem</a>
                    <a href="./ivy/doc/configuration/namespace/src">src</a>
                    <a href="./ivy/doc/configuration/namespace/dest">dest</a>
    <a href="./ivy/doc/configuration/macrodef">macrodef</a>
        <a href="./ivy/doc/configuration/macrodef/attribute">attribute</a>
        any resolver
    <a href="./ivy/doc/configuration/resolvers">resolvers</a>
        any resolver
    <a href="./ivy/doc/configuration/conflict-managers">conflict-managers</a>
    <a href="./ivy/doc/configuration/modules">modules</a>
        <a href="./ivy/doc/configuration/module">module</a>
</pre>

<h1>ivyconf</h1>
<b>Tag:</b> ivyconf

Root tag of any ivyconf file.
<h2>Child elements</h2>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="./ivy/doc/configuration/property">property</a></td><td>set an ivy variable</td>
        <td>0..n</td></tr>
    <tr><td><a href="./ivy/doc/configuration/properties">properties</a></td><td>loads a properties file as ivy variables</td>
        <td>0..n</td></tr>
    <tr><td><a href="./ivy/doc/configuration/conf">conf</a></td><td>configures ivy with some defaults</td>
        <td>0..1</td></tr>
    <tr><td><a href="./ivy/doc/configuration/include">include</a></td><td>includes another ivyconf file</td>
        <td>0..n</td></tr>
    <tr><td><a href="./ivy/doc/configuration/typedef">typedef</a></td><td>defines new types in ivy</td>
        <td>0..n</td></tr>
    <tr><td><a href="./ivy/doc/configuration/latest-strategies">latest-strategies</a></td><td>defines latest strategies</td>
        <td>0..1</td></tr>
    <tr><td><a href="./ivy/doc/configuration/parsers">parsers</a></td><td>defines module descriptor parsers</td>
        <td>0..1</td></tr>
    <tr><td><a href="./ivy/doc/configuration/namespaces">namespaces</a></td><td>defines new namespaces</td>
        <td>0..1</td></tr>
    <tr><td><a href="./ivy/doc/configuration/macrodef">macrodef</a></td><td>defines a new macro resolver</td>
        <td>0..n</td></tr>
    <tr><td><a href="./ivy/doc/configuration/resolvers">resolvers</a></td><td>defines dependency resolvers</td>
        <td>0..1</td></tr>
    <tr><td><a href="./ivy/doc/configuration/conflict-managers">conflict-managers</a></td><td>defines conflicts managers</td>
        <td>0..1</td></tr>
    <tr><td><a href="./ivy/doc/configuration/modules">modules</a></td><td>defines rules between modules and dependency resolvers</td>
        <td>0..1</td></tr>
</tbody>
</table>
]]>
</content>
<node id="node-404">
<nodeinfo  path='ivy/doc/configuration/property' md5_body='e4d3c716b3574787b2590fe70b2dbefc' weight='-15' depth='4' type='book' author='xavier' uid='6' created='1137920966' status='1' format='4' sticky='0' promote='0'/>
<title>property</title>
<teaser>
<![CDATA[<b>Tag:</b> property

Defines an ivy variable. <span class="since">since 1.3</span>

The optional override attribute enables to avoid overriding the previous value of the varable, which makes the definition behave like ant properties, which is particularly useful to define default values (values which are used only if they haven't been defined yet).
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the variable to define</td>]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> property

Defines an ivy variable. <span class="since">since 1.3</span>

The optional override attribute enables to avoid overriding the previous value of the varable, which makes the definition behave like ant properties, which is particularly useful to define default values (values which are used only if they haven't been defined yet).
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the variable to define</td>
        <td>Yes</td></tr>
    <tr><td>value</td><td>the new value the variable must take</td>
        <td>Yes</td></tr>
    <tr><td>override</td><td>true if the previous value (if any) of the variable should overriden, false otherwise</td>
        <td>No, defaults to true</td></tr>
</tbody>
</table>
<h1>Examples</h1>
<code type="xml">
<property name="myvar" value="myvalue"/>
</code>
Sets the variable myvar to the value myvalue.
<hr/>
<code type="xml">
<property name="myvar" value="myvalue" override="false"/>
</code>
Sets the variable myvar to the value myvalue only if myvar has not been set yet.

]]>
</content>
</node>
<node id="node-51">
<nodeinfo  path='ivy/doc/configuration/properties' md5_body='32967079e954b27645f0f58393b72696' weight='-14' depth='4' type='book' author='admin' uid='1' created='1117629616' status='1' format='3' sticky='0' promote='1'/>
<title>properties</title>
<teaser>
<![CDATA[<b>Tag:</b> properties<br/>
<br/>
Loads a properties file into ivy variables. See variables chapter above for details about ivy variables.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>file</td><td>a path to a properties file to load</td>
        <td>Yes</td></tr>
    <tr><td>override</td><td>indicates if the variable found in the properties file should override their previous value, if any <span class="since">since 1.3</span></td>]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> properties<br/>
<br/>
Loads a properties file into ivy variables. See variables chapter above for details about ivy variables.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>file</td><td>a path to a properties file to load</td>
        <td>Yes</td></tr>
    <tr><td>override</td><td>indicates if the variable found in the properties file should override their previous value, if any <span class="since">since 1.3</span></td>
        <td>No, defaults to true</td></tr>
</tbody>
</table>

]]>
</content>
</node>
<node id="node-52">
<nodeinfo  path='ivy/doc/configuration/conf' md5_body='dfabaec4e7e45499aba500093185ec50' weight='-12' depth='4' type='book' author='admin' uid='1' created='1117629672' status='1' format='3' sticky='0' promote='1'/>
<title>conf</title>
<teaser>
<![CDATA[<b>Tag:</b> conf<br/>
<br/>
Configures some important ivy info: default cache, default resolver, ...<br/><br/>
<i>Note that this is not related at all with conf found in ivy files. This tag is only used to setup ivy.</i><br/><br/>
Default cache is used whenever a cache is not provided. It usually points to a directory in your filesystem. <strong>This should not point to a directory used as a repository !</strong><br/><br/>

Default resolver is used whenever nothing elese is configured in the modules section of the configuration file. It should
give the name of a dependency resolver defined in the resolvers section of the configuration file.<br/><br/>]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> conf<br/>
<br/>
Configures some important ivy info: default cache, default resolver, ...<br/><br/>
<i>Note that this is not related at all with conf found in ivy files. This tag is only used to setup ivy.</i><br/><br/>
Default cache is used whenever a cache is not provided. It usually points to a directory in your filesystem. <strong>This should not point to a directory used as a repository !</strong><br/><br/>

Default resolver is used whenever nothing elese is configured in the modules section of the configuration file. It should
give the name of a dependency resolver defined in the resolvers section of the configuration file.<br/><br/>

Default latest strategy and conflict manager can also be configured here.<br/><br/>

validate indicates if ivy files should generally be validate against xsd or not. This setting is only a default value,
and can be overriden :<br/>
1) in ant tasks<br/>
2) in resolvers<br/>
So if there is a setting in the resolver, it always win against all other settings.<br/><br/>

checkUpToDate indicates to ivy if it must check date of artifacts before retrieving them (i.e. copying them from
cache to another place in your filesystem). Usually it is a good thing to check date to avoid unnecessary copy, even if it's 
most of the time a local copy.<br/><br/>
cacheIvyPattern and cacheArtifactPattern are used to configure the way ivy stores ivy files and artifacts
in the cache. Usually you do not have to change this, unless you want to use the cache directly from another tool,
which is not recommended.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>defaultCache</td><td>a path to a directory to use as default cache</td>
        <td>No, defaults to .ivy/cache in user home</td></tr>
    <tr><td>defaultResolver</td><td>the name of the default resolver to use</td>
        <td>No, but all modules should be configured in the modules section if not provided</td></tr>
    <tr><td>defaultLatestStrategy</td><td>the name of the default latest strategy to use</td>
        <td>No, defaults to latest-revision</td></tr>
    <tr><td>defaultConflictManager</td><td>the name of the default conflict manager to use</td>
        <td>No, defaults to latest-revision</td></tr>
    <tr><td>validate</td><td>Indicates if ivy files should be validated against ivy.xsd or not.</td>
        <td>No, defaults to true</td></tr>
    <tr><td>checkUpToDate</td><td>Indicates if date should be checked before retrieving artifacts from cache</td>
        <td>No, defaults to true</td></tr>
    <tr><td>cacheIvyPattern</td><td>a pattern to indicate where ivy files should be put in cache</td>
        <td>No, defaults to [organisation]/[module]/ivy-[revision].xml</td></tr>
    <tr><td>cacheArtifactPattern</td><td>a pattern to indicate where artifact files should be put in cache</td>
        <td>No, defaults to [organisation]/[module]/[type]s/[artifact]-[revision].[ext]</td></tr>
    <tr><td>useRemoteConfig</td><td>true to configure ivyrep and ibiblio resolver from a remote configuration file (updated with changes in those repository structure if any) (<span class="since">since 1.2</span>)</td>
        <td>No, defaults to false</td></tr>
</tbody>
</table>
]]>
</content>
</node>
<node id="node-400">
<nodeinfo  path='ivy/doc/configuration/include' md5_body='0a96cf920699f9501eb444cc687b5db4' weight='-12' depth='4' type='book' author='xavier' uid='6' created='1137825809' status='1' format='4' sticky='0' promote='0'/>
<title>include</title>
<teaser>
<![CDATA[<b>Tag:</b> include

Includes another ivyconf file as if it were part of this one. <span class="since">since 1.3</span>

The included ivyconf file has to be a complete well formed ivyconf file, i.e. it does have to include the <code><ivyconf></code> tag.

<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>file</td><td>a path to the ivyconf file to include</td>
        <td>Yes</td></tr>
</tbody>
</table>
<h1>Examples</h1>]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> include

Includes another ivyconf file as if it were part of this one. <span class="since">since 1.3</span>

The included ivyconf file has to be a complete well formed ivyconf file, i.e. it does have to include the <code><ivyconf></code> tag.

<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>file</td><td>a path to the ivyconf file to include</td>
        <td>Yes</td></tr>
</tbody>
</table>
<h1>Examples</h1>
<code type="xml">
<ivyconf>
  <property name="myrepository" value="path/to/my/real/rep"/>
  <conf defaultResolver="default"/>
  <include file="path/to/ivyconf-default.xml"/>
</ivyconf>
</code>
with ivyconf-default.xml:
<code type="xml">
<ivyconf>
  <property name="myrepository" value="path/to/rep" overwrite="false"/>
  <resolvers>
    <ivyrep name="default" ivyroot="${myrepository}"/>
  </resolvers>
</ivyconf>
</code>

The included ivyconf defines a resolver named default, which is an ivyrep resolver, with its root configured as being the value of myrepository variable. This variable is given the value path/to/rep in the included file, but because the attribute overwrite is set to false, it will not overide the value given in the main ivyconf including this one, so the value used for myrepository will be path/to/my/real/rep.
<hr/>
<code type="xml">
<ivyconf>
  <include file="ivyconf-macro.xml"/>
  <resolvers>
    <mymacro name="includeworks" mymainrep="included/myrep" mysecondrep="included/secondrep"/>
  </resolvers>
</ivyconf> 
</code>
with ivyconf-macro.xml being the ivyconf example given on the <a href="/ivy/doc/configuration/macrodef">macrodef documentation page</a>.
This let reusing macro resolver easy.]]>
</content>
</node>
<node id="node-53">
<nodeinfo  path='ivy/doc/configuration/typedef' md5_body='bb77303a378950e33ff538eaa415a20a' weight='-10' depth='4' type='book' author='admin' uid='1' created='1117629838' status='1' format='3' sticky='0' promote='1'/>
<title>typedef</title>
<teaser>
<![CDATA[<b>Tag:</b> typedef<br/>
<br/>
Defines a new type in ivy. Useful to define new dependency resolvers, in particular, but also latest strategies.
See <a href="./ivy/doc/extend">how to write and plug your own dependency resolver</a> for details.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the type to define. This name is then used as an xml tag.</td>
        <td>Yes</td></tr>
    <tr><td>classname</td><td>the fully qualified class name of the type to define.</td>]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> typedef<br/>
<br/>
Defines a new type in ivy. Useful to define new dependency resolvers, in particular, but also latest strategies.
See <a href="./ivy/doc/extend">how to write and plug your own dependency resolver</a> for details.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the type to define. This name is then used as an xml tag.</td>
        <td>Yes</td></tr>
    <tr><td>classname</td><td>the fully qualified class name of the type to define.</td>
        <td>Yes</td></tr>
</tbody>
</table>
]]>
</content>
</node>
<node id="node-54">
<nodeinfo  path='ivy/doc/configuration/latest-strategies' md5_body='99ad5ebe28aff6fecb6387b037eeb93c' weight='-8' depth='4' type='book' author='admin' uid='1' created='1117629862' status='1' format='3' sticky='0' promote='1'/>
<title>latest-strategies</title>
<teaser>
<![CDATA[<b>Tag:</b> latest-strategies<br/>
<br/>
Defines a list of latest strategies usable in ivy. Each latest strategy is identified by its name, given as an attribute.
The child tag used for the latest strategy must be equal to a name of a latest strategy type (usually added with the typedef tag). <br/><br/>

The latest strategies which are always included in ivy (and do not require anything in the configuration file) are:<br/>
- <b>latest-time</b>: compares the revisions date to know which is the latest. While this is often a good 
strategy in terms of pertinence, it has the drawback to be costful to compute with distant repositories. If you use ivyrep, ]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> latest-strategies<br/>
<br/>
Defines a list of latest strategies usable in ivy. Each latest strategy is identified by its name, given as an attribute.
The child tag used for the latest strategy must be equal to a name of a latest strategy type (usually added with the typedef tag). <br/><br/>

The latest strategies which are always included in ivy (and do not require anything in the configuration file) are:<br/>
- <b>latest-time</b>: compares the revisions date to know which is the latest. While this is often a good 
strategy in terms of pertinence, it has the drawback to be costful to compute with distant repositories. If you use ivyrep, 
for example, ivy has to ask the http server what is the date of each ivy file before knowing which is the latest.<br/>
- <b>latest-revision</b>: compares the revisions as string, using an algorithm close to the one used in the php version_compare function.
This algorithm takes into account special meaning of some text. For instance, with this strategy, 1.0-dev1 is considered
before 1.0-alpha1, which in turn is before 1.0-rc1, which is before 1.0, which is before 1.0.1.<br/>
- <b>latest-lexico</b>: compares the revisions as string, using lexicographic order (the one used by java string comparison).

<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>any latest strategy</td><td>adds a latest strategy to the list of available strategies</td>
        <td>0..n</td></tr>
</tbody>
</table>
]]>
</content>
</node>
<node id="node-424">
<nodeinfo  path='ivy/doc/configuration/parsers' md5_body='1b1d35def223f3e0cd848b0ce602ccd0' weight='-8' depth='4' type='book' author='xavier' uid='6' created='1138193841' status='1' format='4' sticky='0' promote='0'/>
<title>parsers</title>
<teaser>
<![CDATA[<b>Tag:</b> parsers

Defines a list of module descriptor parsers usable in ivy. Each parser defines which resources (which descriptor file) it accepts.
The child tag used for the parser must be equal to a name of a parser type (added with the typedef tag).

Note that when looking for a parser, ivy queries the parsers list in the reverse order. So the last parser in the list will be queried first. Consequently, if the last parser accepts all resources, the other parsers will never have a chance to parse the resource.

Two parsers are available by default and thus do not need to be declared in this section:]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> parsers

Defines a list of module descriptor parsers usable in ivy. Each parser defines which resources (which descriptor file) it accepts.
The child tag used for the parser must be equal to a name of a parser type (added with the typedef tag).

Note that when looking for a parser, ivy queries the parsers list in the reverse order. So the last parser in the list will be queried first. Consequently, if the last parser accepts all resources, the other parsers will never have a chance to parse the resource.

Two parsers are available by default and thus do not need to be declared in this section:
<ul>
<li>ivy file parser</li> this is the parser used for ivy xml files. This parser is used for resources that aren't accepted by any other parser.
<li>pom parser</li>this parser is able to parse maven2 pom files
</ul>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>any module descriptor parser</td><td>adds a module descriptor parser to the list of available parsers</td>
        <td>0..n</td></tr>
</tbody>
</table>
]]>
</content>
</node>
<node id="node-425">
<nodeinfo  path='ivy/doc/configuration/namespaces' md5_body='c82f64ee21d441ceffa76ffd499d5002' weight='-7' depth='4' type='book' author='xavier' uid='6' created='1138194618' status='1' format='4' sticky='0' promote='0'/>
<title>namespaces</title>
<teaser>
<![CDATA[<b>Tag:</b> namespaces

Namespaces are an advanced feature of Ivy which let you use resolvers in which module names and organisations are not consistent between each other.

For instance, if you want to use maven2 repository and ivyrep collectively, you will face some naming issues. For example all apache commons projects are declared to be part of the organisation apache in ivyrep whereas in maven2 ibiblio repository, they are declared to be part of the organisation of the same name of the module.

So if you try to use both maven2 and ivyrep repositories, you will face some issues like:]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> namespaces

Namespaces are an advanced feature of Ivy which let you use resolvers in which module names and organisations are not consistent between each other.

For instance, if you want to use maven2 repository and ivyrep collectively, you will face some naming issues. For example all apache commons projects are declared to be part of the organisation apache in ivyrep whereas in maven2 ibiblio repository, they are declared to be part of the organisation of the same name of the module.

So if you try to use both maven2 and ivyrep repositories, you will face some issues like:
<quote>
How do I declare a dependency on commons-lang ?
I have an error while trying to resolve module xxx. It says that it depends on [commons-httpclient commons-httpclient] ant that it isn't available.
...
</quote>

Ivy has an answer to give to this kind of troubles, and this answer is called namespaces. In short, you can affect a namespace to each dependency resolver in Ivy, and each namespace defines rules to convert names from the system namespace to the defined namespace itself, and vice versa.

This very powerful feature is thoroughly used in the <a href="/ivy/doc/tutorial/build-repository/advanced1">build your own repository tutorial</a>, and this is a good place to have examples of what can be done with namespaces.

<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="/ivy/doc/configuration/namespace">namespace</a></td><td>defines a new namespace</td>
        <td>0..n</td></tr>
</tbody>
</table>
]]>
</content>
<node id="node-426">
<nodeinfo  path='ivy/doc/configuration/namespace' md5_body='972f38555353bfcd1e81cf0e33d60625' weight='0' depth='5' type='book' author='xavier' uid='6' created='1138195270' status='1' format='4' sticky='0' promote='0'/>
<title>namespace</title>
<teaser>
<![CDATA[<b>Tag:</b> namespace

Defines a new namespace. A namespace is identified by a name, which is used to reference the namespace in the resolvers using the namespace.

Namespaces overview is given in the <a href="/ivy/doc/configuration/namespaces">namespaces</a> documentation.

A namespace mainly consists of a list of rules, each rule defining a translation between system namespace and the defined namespace, and vice versa.

There are two main possibilities for using these rules. By default, a namespace iterate through the rules, and when it finds one that translate the given name, it returns the translated name. But the namespace can be configured to do use the list as a translator chain: in this case, all rules are applied in order, the result of the first rule translation being passed to the second, and so on.]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> namespace

Defines a new namespace. A namespace is identified by a name, which is used to reference the namespace in the resolvers using the namespace.

Namespaces overview is given in the <a href="/ivy/doc/configuration/namespaces">namespaces</a> documentation.

A namespace mainly consists of a list of rules, each rule defining a translation between system namespace and the defined namespace, and vice versa.

There are two main possibilities for using these rules. By default, a namespace iterate through the rules, and when it finds one that translate the given name, it returns the translated name. But the namespace can be configured to do use the list as a translator chain: in this case, all rules are applied in order, the result of the first rule translation being passed to the second, and so on.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the namespace name</td>
        <td>Yes</td></tr>
    <tr><td>chainrules</td><td>true to indicate that namespaces rules should be chained, false otherwise</td>
        <td>No, defaults to false</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="/ivy/doc/configuration/namespace/rule">rule</a></td><td>defines a new namespace rule</td>
        <td>0..n</td></tr>
</tbody>
</table>
<h1>Example</h1>
<code type="xml">
<namespace name="test">
  <rule>
    <fromsystem>
      <src org="systemorg"/>
      <dest org="A"/>
    </fromsystem>
    <tosystem>
      <src org="A"/>
      <dest org="systemorg"/>
    </tosystem>
  </rule>
</namespace>
</code>

<code type="xml">
<namespace name="test">
  <rule>
    <fromsystem>
      <src org="systemorg2" module="system\-(.+)"/>
      <dest org="B" module="$m1"/>
    </fromsystem>
    <tosystem>
      <src org="B" module=".+"/>
      <dest org="systemorg2" module="system-$m0"/>
    </tosystem>
  </rule>
</namespace>
</code>

<code type="xml">
<namespace name="test" chainrules="true">
  <rule>
    <fromsystem>
      <src org="systemorg"/>
      <dest org="A"/>
    </fromsystem>
    <tosystem>
      <src org="A"/>
      <dest org="systemorg"/>
    </tosystem>
  </rule>
  <rule>
    <fromsystem>
      <src module="systemmod"/>
      <dest module="A"/>
    </fromsystem>
    <tosystem>
      <src module="A"/>
      <dest module="systemmod"/>
    </tosystem>
  </rule>
  <rule>
    <fromsystem>
      <src module="systemmod2"/>
      <dest module="B"/>
    </fromsystem>
    <tosystem>
      <src module="B"/>
      <dest module="systemmod2"/>
    </tosystem>
  </rule>
</namespace>
</code>
]]>
</content>
<node id="node-427">
<nodeinfo  path='ivy/doc/configuration/namespace/rule' md5_body='1404be491250fb1a05e793d025441066' weight='0' depth='6' type='book' author='xavier' uid='6' created='1138196446' status='1' format='4' sticky='0' promote='0'/>
<title>rule</title>
<teaser>
<![CDATA[<b>Tag:</b> rule

Defines a new namespace rule. A rule defines a translation between system namespace and the defined namespace, and vice versa.

See <a href="/ivy/doc/configuration/namespace/namespace">namespace</a> doc for details.

<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="/ivy/doc/configuration/namespace/fromtosystem">fromsystem</a></td><td>defines the translation to apply from system namespace to the defined namespace</td>]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> rule

Defines a new namespace rule. A rule defines a translation between system namespace and the defined namespace, and vice versa.

See <a href="/ivy/doc/configuration/namespace/namespace">namespace</a> doc for details.

<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="/ivy/doc/configuration/namespace/fromtosystem">fromsystem</a></td><td>defines the translation to apply from system namespace to the defined namespace</td>
        <td>1</td></tr>
    <tr><td><a href="/ivy/doc/configuration/namespace/fromtosystem">tosystem</a></td><td>defines the translation to apply from the defined namespace to system namespace</td>
        <td>1</td></tr>
</tbody>
</table>]]>
</content>
<node id="node-428">
<nodeinfo  path='ivy/doc/configuration/namespace/fromtosystem' md5_body='f60ff0c7b41619f2f441297270bdc4ac' weight='0' depth='7' type='book' author='xavier' uid='6' created='1138196774' status='1' format='4' sticky='0' promote='0'/>
<title>fromsystem / tosystem</title>
<teaser>
<![CDATA[<b>Tag:</b> fromsystem / tosystem

Defines a one way translation rule, i.e. a translation from system namespace to the defined namespace or vice versa.
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="/ivy/doc/configuration/namespace/src">src</a></td><td>defines a source name which can be accepted</td>
        <td>1..n</td></tr>
    <tr><td><a href="/ivy/doc/configuration/namespace/dest">dest</a></td><td>defines the translation to apply when a name is accepted by an src pattern</td>]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> fromsystem / tosystem

Defines a one way translation rule, i.e. a translation from system namespace to the defined namespace or vice versa.
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="/ivy/doc/configuration/namespace/src">src</a></td><td>defines a source name which can be accepted</td>
        <td>1..n</td></tr>
    <tr><td><a href="/ivy/doc/configuration/namespace/dest">dest</a></td><td>defines the translation to apply when a name is accepted by an src pattern</td>
        <td>1</td></tr>
</tbody>
</table>
]]>
</content>
<node id="node-429">
<nodeinfo  path='ivy/doc/configuration/namespace/src' md5_body='e397f1982d21760c4c6ea095cca808ca' weight='0' depth='8' type='book' author='xavier' uid='6' created='1138197145' status='1' format='4' sticky='0' promote='0'/>
<title>src</title>
<teaser>
<![CDATA[<b>Tag:</b> src

Defines the acceptation part of a translation rule. If a name matches this src, it will be translated using the dest part.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>org</td><td>the organisation to match as a regexp</td>
        <td>No, defaults to .*</td></tr>
    <tr><td>module</td><td>the module name to match as a regexp</td>
        <td>No, defaults to .*</td></tr>
    <tr><td>rev</td><td>the revision to match as a regexp</td>]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> src

Defines the acceptation part of a translation rule. If a name matches this src, it will be translated using the dest part.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>org</td><td>the organisation to match as a regexp</td>
        <td>No, defaults to .*</td></tr>
    <tr><td>module</td><td>the module name to match as a regexp</td>
        <td>No, defaults to .*</td></tr>
    <tr><td>rev</td><td>the revision to match as a regexp</td>
        <td>No, defaults to .*</td></tr>
</tbody>
</table>
]]>
</content>
</node>
<node id="node-431">
<nodeinfo  path='ivy/doc/configuration/namespace/dest' md5_body='d07f4a7d131eb5126cf22ab60b35d499' weight='2' depth='8' type='book' author='xavier' uid='6' created='1138197358' status='1' format='4' sticky='0' promote='0'/>
<title>dest</title>
<teaser>
<![CDATA[<b>Tag:</b> dest

Defines the translation part of a translation rule. If a name has matched a corresponding src, it will be translated using this dest part.

The new names can contain references to groups of the matched name, using a slightly modified regexp syntax. Indeed, referenced groups can be part of either the organisation, module or revision part of the original name. So, to reference the groups, you just have to add a letter identifying the part in which the group should be selected: o for organisation, m for module, and r for revision.

For instance, $o0 matches the whole matched organisation, and $m0 the whole matched module name. $o1 matches the first group of the matched organisation.]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> dest

Defines the translation part of a translation rule. If a name has matched a corresponding src, it will be translated using this dest part.

The new names can contain references to groups of the matched name, using a slightly modified regexp syntax. Indeed, referenced groups can be part of either the organisation, module or revision part of the original name. So, to reference the groups, you just have to add a letter identifying the part in which the group should be selected: o for organisation, m for module, and r for revision.

For instance, $o0 matches the whole matched organisation, and $m0 the whole matched module name. $o1 matches the first group of the matched organisation.

For details about regexp and groups, see the <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/regex/Pattern.html">Pattern class documentation</a> in the jdk.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>org</td><td>the new organisation name</td>
        <td>No, defaults to $o0</td></tr>
    <tr><td>module</td><td>the new module name</td>
        <td>No, defaults to $m0</td></tr>
    <tr><td>rev</td><td>the new revision</td>
        <td>No, defaults to $r0</td></tr>
</tbody>
</table>
<h1>Examples</h1>
<code type="xml">
    <fromsystem>
      <src org="systemorg2" module="system\-(.+)"/>
      <dest org="B" module="$m1"/>
    </fromsystem>
</code>
Matches modules from systemorg2 which have a name beginning with system followed by a minus and anything else, and translate it to organisation B and module the part following <code>system-</code> of the original name.
]]>
</content>
</node>
</node>
</node>
</node>
</node>
<node id="node-401">
<nodeinfo  path='ivy/doc/configuration/macrodef' md5_body='bf81c11ed7a9e2edb5362407ca490883' weight='-6' depth='4' type='book' author='xavier' uid='6' created='1137827069' status='1' format='4' sticky='0' promote='0'/>
<title>macrodef</title>
<teaser>
<![CDATA[<b>Tag:</b> macrodef

Defines a new dependency resolver type based upon an other one. This definition is very similar to the macrodef feature of ant for defining macro tasks. <span class="since">since 1.3</span>

This task eases the lot the process of creating new dependency resolver, because it avoid writing java code.

It is generally used in combination with the <a href="/ivy/doc/configuration/include">include</a> feature to help reusing macro at several places.

A macro is defined by writing the resolver it is equivalent to as if it were written in the resolver place, except that you can use attributes to pass parameters to the newly defined resolver type. Attributes are defined with a name and sometimes a default value, and are used using the following syntax: <code>@{attributename}</code>.]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> macrodef

Defines a new dependency resolver type based upon an other one. This definition is very similar to the macrodef feature of ant for defining macro tasks. <span class="since">since 1.3</span>

This task eases the lot the process of creating new dependency resolver, because it avoid writing java code.

It is generally used in combination with the <a href="/ivy/doc/configuration/include">include</a> feature to help reusing macro at several places.

A macro is defined by writing the resolver it is equivalent to as if it were written in the resolver place, except that you can use attributes to pass parameters to the newly defined resolver type. Attributes are defined with a name and sometimes a default value, and are used using the following syntax: <code>@{attributename}</code>.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>name of the resover type created</td>
        <td>Yes</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="/ivy/doc/configuration/macrodef/attribute">attribute</a></td><td>defines an attribute for the macro resolver</td>
        <td>0..n</td></tr>
    <tr><td>any resolver</td><td>defines the base resolver upon which this macro is defined</td>
        <td>1</td></tr>
</tbody>
</table>
<h1>Examples</h1>
Defining a simple macro:
<code type="xml">
  <macrodef name="mymacro">
    <attribute name="mymainrep"/>
      <filesystem name="fs1">
        <ivy pattern="@{mymainrep}/[organisation]/[module]/[type]s/[artifact]-[revision].[ext]"/>
        <artifact pattern="@{mymainrep}/[organisation]/[module]/[type]s/[artifact]-[revision].[ext]"/>
      </filesystem>
  </macrodef>
</code>
Using it:
<code type="xml">
  <resolvers>
    <mymacro name="default" mymainrep="path/to/myrep"/>
  </resolvers>
</code>
<hr/>
A complete example:
<code type="xml">
<ivyconf>
  <macrodef name="mymacro">
    <attribute name="mymainrep"/>
    <attribute name="mysecondrep"/>
    <attribute name="myseconddirlayout" default="[organisation]/[module]/[type]s"/>
    <chain>
      <filesystem name="fs1">
        <ivy pattern="@{mymainrep}/[organisation]/[module]/[type]s/[artifact]-[revision].[ext]"/>
        <artifact pattern="@{mymainrep}/[organisation]/[module]/[type]s/[artifact]-[revision].[ext]"/>
      </filesystem>
      <filesystem name="fs2" latest="latest-time">
        <ivy pattern="@{mysecondrep}/@{myseconddirlayout}/ivy-[revision].xml"/>
        <artifact pattern="@{mysecondrep}/@{myseconddirlayout}/[artifact]-[revision].[ext]"/>
      </filesystem>
    </chain>
  </macrodef>
	
  <resolvers>
    <mymacro name="default" mymainrep="path/to/myrep" mysecondrep="path/to/secondrep"/>
    <mymacro name="other" 
       mymainrep="path/to/myrep" 
       mysecondrep="path/to/secondrep" 
       myseconddirlayout="[module]/[type]s"/>
   </resolvers>
</ivyconf>
</code>
]]>
</content>
<node id="node-402">
<nodeinfo  path='ivy/doc/configuration/macrodef/attribute' md5_body='2dae30fc4f34c477e970ed11db88d177' weight='0' depth='5' type='book' author='xavier' uid='6' created='1137828428' status='1' format='4' sticky='0' promote='0'/>
<title>attribute</title>
<teaser>
<![CDATA[<b>Tag:</b> attribute

Defines a macrodef attribute. See macrodef for details.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the attribute</td>
        <td>Yes</td></tr>
    <tr><td>default</td><td>the default value of the attribute if none is specified</td>
        <td>No, by default attribute are required</td></tr>
</tbody>
</table>

]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> attribute

Defines a macrodef attribute. See macrodef for details.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the attribute</td>
        <td>Yes</td></tr>
    <tr><td>default</td><td>the default value of the attribute if none is specified</td>
        <td>No, by default attribute are required</td></tr>
</tbody>
</table>

]]>
</content>
</node>
</node>
<node id="node-55">
<nodeinfo  path='ivy/doc/configuration/resolvers' md5_body='cedb1e8077547e08a00ba9dc1a2c8b5e' weight='-5' depth='4' type='book' author='admin' uid='1' created='1117629931' status='1' format='4' sticky='0' promote='1'/>
<title>resolvers</title>
<teaser>
<![CDATA[<b>Tag:</b> resolvers

Defines a list of dependency resolvers usable in ivy. Each dependency resolver is identified by its name, given as an attribute.

The child tag used for the dependency resolver must be equal to a name of a dependency resolver type (either built-in or added with the typedef tag).

<span class="since">since 1.3</span> Once defined, resolvers can be referenced by their name, using the following syntax:
<code type="xml">
<resolver ref="alreadydefinedresolver"/>
</code>
Note that this works only if the resolver has been already defined, and not if it is defined later in the ivyconf file.]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> resolvers

Defines a list of dependency resolvers usable in ivy. Each dependency resolver is identified by its name, given as an attribute.

The child tag used for the dependency resolver must be equal to a name of a dependency resolver type (either built-in or added with the typedef tag).

<span class="since">since 1.3</span> Once defined, resolvers can be referenced by their name, using the following syntax:
<code type="xml">
<resolver ref="alreadydefinedresolver"/>
</code>
Note that this works only if the resolver has been already defined, and not if it is defined later in the ivyconf file.
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>any resolver</td><td>adds a resolver to the list of available resolvers</td>
        <td>1..n</td></tr>
</tbody>
</table>

<h1>Built-in Resolvers</h1>
Ivy comes with a set of built-in dependency resolvers able to answer to the most common needs. 

If you don't find the one you want here, you can also check if some one has not contributed it in the <a href="./ivy/links">links page</a>, or even <a href="./ivy/doc/extend">write your own</a>.
<ul>
<li><a href="./ivy/doc/resolver/ivyrep">IvyRep</a></li> Finds ivy files on ivyrep and artifacts on ibiblio.
<li><a href="./ivy/doc/resolver/ibiblio">IBiblio</a></li> Finds artifacts on ibiblio.
<li><a href="./ivy/doc/resolver/filesystem">FileSystem</a></li> This very performant resolver finds ivy files and artifacts in your file system.
<li><a href="./ivy/doc/resolver/url">Url</a></li> Finds ivy files and artifacts in any repository accessible with urls.
<li><a href="./ivy/doc/resolver/chain">Chain</a></li> Delegates the finding to a chain of sub resolvers.
<li><a href="./ivy/doc/resolver/dual">Dual</a></li> Delegates the finding of ivy files to one resolver and of artifacts to another.
</ul>
<h1>Examples</h1>
<code type="xml">
<resolvers>
  <filesystem name="1">
    <ivy pattern="${ivy.conf.dir}/1/[organisation]/[module]/ivys/ivy-[revision].xml"/>
    <artifact pattern="${ivy.conf.dir}/1/[organisation]/[module]/[type]s/[artifact]-[revision].[ext]"/>
  </filesystem>
  <chain name="chain1">
    <resolver ref="1"/>
    <ivyrep name="ivyrep"/>
  </chain>
  <chain name="chain2" returnFirst="true" dual="true">
    <resolver ref="1"/>
    <ibiblio name="ibiblio"/>
  </chain>
</resolvers>
</code>
Defines a filesystem resolver, named '1', which is then used in two chains, the first which seconds the filesystem resolver with an ivyrep resolver, and second which seconds the filesystem resolver with an ibiblio resolver, and which returns the first module found, and uses the whole chain to download artifacts (see corresponding resolvers documentation for details about them).]]>
</content>
<node id="node-87">
<nodeinfo  path='ivy/doc/resolver/ivyrep' md5_body='e1f4ccbf6e299064ba50d8d307501925' weight='-14' depth='5' type='book' author='admin' uid='1' created='1117639521' status='1' format='3' sticky='0' promote='1'/>
<title>IvyRep Resolver</title>
<teaser>
<![CDATA[<table class="resolver">
<tr><td class="title">Tag</td><td class="value">ivyrep</td></tr>
<tr><td class="title">Handle latest</td><td class="value">yes, at least if the repository server is apache based</td></tr>
<tr><td class="title">Handle publish</td><td class="value">no</td></tr>
</table>
This resolver usually uses <a href="./ivy/ivyrep">ivyrep</a> to find ivy files
and ibiblio to find artifacts.
However it can be configured to use other similar repositories.<br/><br/>
<i>Note that if no ivy file is found on ivyrep, then this resolver behaves like ibiblio resolver. Thus it's always better to]]>
</teaser>
<content>
<![CDATA[<table class="resolver">
<tr><td class="title">Tag</td><td class="value">ivyrep</td></tr>
<tr><td class="title">Handle latest</td><td class="value">yes, at least if the repository server is apache based</td></tr>
<tr><td class="title">Handle publish</td><td class="value">no</td></tr>
</table>
This resolver usually uses <a href="./ivy/ivyrep">ivyrep</a> to find ivy files
and ibiblio to find artifacts.
However it can be configured to use other similar repositories.<br/><br/>
<i>Note that if no ivy file is found on ivyrep, then this resolver behaves like ibiblio resolver. Thus it's always better to
use this resolver instead of ibiblio one, which is provided mainly for compatibility reasons.</i>
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name which identify the resolver</td>
        <td>Yes</td></tr>
    <tr><td>validate</td><td>indicates if resolved ivy files should be validated against ivy xsd</td>
        <td>No, defaults to true</td></tr>
    <tr><td>checkmodified</td><td>Indicates if this resolver should check lastmodified date to know if an ivy file is up to date.</td>
    <tr><td>alwaysCheckExactRevision</td><td>Indicates if this resolver should check the given revision even if it's a special one (like latest.integration). <span class="since">since 1.3</span></td>
        <td>No, defaults to ${ivy.default.always.check.exact.revision}</td></tr>
    <tr><td>ivyroot</td><td>the root of the ivy repository.</td>
        <td>No, defaults to ${ivy.ivyrep.default.ivy.root}</td></tr>
    <tr><td>ivypattern</td><td>a pattern describing the layout of the ivy repository.</td>
        <td>No, defaults to ${ivy.ivyrep.default.ivy.pattern}</td></tr>
    <tr><td>artroot</td><td>the root of the artifacts repository.</td>
        <td>No, defaults to ${ivy.ivyrep.default.artifact.root}</td></tr>
    <tr><td>artpattern</td><td>a pattern describing the layout of the artifacts repository.</td>
        <td>No, defaults to ${ivy.ivyrep.default.artifact pattern}</td></tr>
    <tr><td>namespace</td><td>The name of the namespace to which this resolver belong <span class="since">since 1.3</span></td>
        <td>No, defaults to 'system'</td></tr>
    <tr><td>checkconsistency</td><td>true to check consistency of module descriptors found by this resolver, false to avoid consistency check <span class="since">since 1.3</span></td>
        <td>No, defaults to true</td></tr>
    <tr><td>latest</td><td>The name of the latest strategy to use.</td>
        <td>No, defaults to 'default'</td></tr>
</tbody>
</table>
]]>
</content>
</node>
<node id="node-88">
<nodeinfo  path='ivy/doc/resolver/ibiblio' md5_body='4e31403f26bd8405647961ae83527412' weight='-12' depth='5' type='book' author='admin' uid='1' created='1117639651' status='1' format='4' sticky='0' promote='1'/>
<title>IBiblio Resolver</title>
<teaser>
<![CDATA[<table class="resolver">
<tr><td class="title">Tag</td><td class="value">ibiblio</td></tr>
<tr><td class="title">Handle latest</td><td class="value">yes, at least if the repository server is apache based</td></tr>
<tr><td class="title">Handle publish</td><td class="value">no</td></tr>
</table>

This resolver usually uses ibiblio to find artifacts. 

Prefer the use of ivyrep resolver which adds ivy file handling to this resolver.

<span class="since">since 1.3</span> Using the m2compatible attribute, you can benefit from maven 2 repository compatibility (convert dots in organisation in slashes, search for poms, use transitive dependencies of poms). This setting also affects the default place where the resolver look for its artifacts to point to the maven2 repository. So setting this attribute to true is sufficient to use maven 2 ibiblio repository.]]>
</teaser>
<content>
<![CDATA[<table class="resolver">
<tr><td class="title">Tag</td><td class="value">ibiblio</td></tr>
<tr><td class="title">Handle latest</td><td class="value">yes, at least if the repository server is apache based</td></tr>
<tr><td class="title">Handle publish</td><td class="value">no</td></tr>
</table>

This resolver usually uses ibiblio to find artifacts. 

Prefer the use of ivyrep resolver which adds ivy file handling to this resolver.

<span class="since">since 1.3</span> Using the m2compatible attribute, you can benefit from maven 2 repository compatibility (convert dots in organisation in slashes, search for poms, use transitive dependencies of poms). This setting also affects the default place where the resolver look for its artifacts to point to the maven2 repository. So setting this attribute to true is sufficient to use maven 2 ibiblio repository.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name which identify the resolver</td>
        <td>Yes</td></tr>
    <tr><td>validate</td><td>indicates if resolved ivy files should be validated against ivy xsd</td>
        <td>No, defaults to call setting</td></tr>
    <tr><td>alwaysCheckExactRevision</td><td>Indicates if this resolver should check the given revision even if it's a special one (like latest.integration). <span class="since">since 1.3</span></td>
        <td>No, defaults to ${ivy.default.always.check.exact.revision}</td></tr>
    <tr><td>root</td><td>the root of the artifacts repository.</td>
        <td>No, defaults to ${ivy.ibiblio.default.artifact.root}</td></tr>
    <tr><td>pattern</td><td>a pattern describing the layout of the artifacts repository.</td>
        <td>No, defaults to ${ivy.ibiblio.default.artifact.pattern}</td></tr>
    <tr><td>m2compatible</td><td>True if this resolver should be maven2 compatible, false otherwise <span class="since">since 1.3</span></td>
        <td>No, defaults to false</td></tr>
    <tr><td>namespace</td><td>The name of the namespace to which this resolver belong <span class="since">since 1.3</span></td>
        <td>No, defaults to 'system'</td></tr>
    <tr><td>checkconsistency</td><td>true to check consistency of module descriptors found by this resolver, false to avoid consistency check <span class="since">since 1.3</span></td>
        <td>No, defaults to true</td></tr>
    <tr><td>latest</td><td>The name of the latest strategy to use.</td>
        <td>No, defaults to 'default'</td></tr>
</tbody>
</table>
]]>
</content>
</node>
<node id="node-89">
<nodeinfo  path='ivy/doc/resolver/filesystem' md5_body='b824ed59756e492b975f9bad7e523a15' weight='-9' depth='5' type='book' author='admin' uid='1' created='1117639683' status='1' format='3' sticky='0' promote='1'/>
<title>File System resolver</title>
<teaser>
<![CDATA[<table class="resolver">
<tr><td class="title">Tag</td><td class="value">filesystem</td></tr>
<tr><td class="title">Handle latest</td><td class="value">yes</td></tr>
<tr><td class="title">Handle publish</td><td class="value">yes</td></tr>
</table>

This resolver uses the file system to resolve ivy files and artifacts. It presents the advantage to
usually have very good performances. Moreover, it is easy to setup using basic OS file sharing mechanism.<br/>
<br/>
The configuration of such a resolver is mainly done through ivy and artifact patterns, indicating where ivy files
and artifacts can be found in the file system. You can indicate a list of pattern which will be checked one after]]>
</teaser>
<content>
<![CDATA[<table class="resolver">
<tr><td class="title">Tag</td><td class="value">filesystem</td></tr>
<tr><td class="title">Handle latest</td><td class="value">yes</td></tr>
<tr><td class="title">Handle publish</td><td class="value">yes</td></tr>
</table>

This resolver uses the file system to resolve ivy files and artifacts. It presents the advantage to
usually have very good performances. Moreover, it is easy to setup using basic OS file sharing mechanism.<br/>
<br/>
The configuration of such a resolver is mainly done through ivy and artifact patterns, indicating where ivy files
and artifacts can be found in the file system. You can indicate a list of pattern which will be checked one after
the other.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name which identify the resolver</td>
        <td>Yes</td></tr>
    <tr><td>validate</td><td>indicates if resolved ivy files should be validated against ivy xsd</td>
        <td>No, defaults to call setting</td></tr>
    <tr><td>checkmodified</td><td>Indicates if this resolver should check lastmodified date to know if an ivy file is up to date.</td>
        <td>No, defaults to ${ivy.resolver.default.check.modified}</td></tr>
    <tr><td>alwaysCheckExactRevision</td><td>Indicates if this resolver should check the given revision even if it's a special one (like latest.integration). <span class="since">since 1.3</span></td>
        <td>No, defaults to ${ivy.default.always.check.exact.revision}</td></tr>
    <tr><td>m2compatible</td><td>True if this resolver should be maven2 compatible, false otherwise <span class="since">since 1.3</span></td>
        <td>No, defaults to false</td></tr>
    <tr><td>namespace</td><td>The name of the namespace to which this resolver belong <span class="since">since 1.3</span></td>
        <td>No, defaults to 'system'</td></tr>
    <tr><td>checkconsistency</td><td>true to check consistency of module descriptors found by this resolver, false to avoid consistency check <span class="since">since 1.3</span></td>
        <td>No, defaults to true</td></tr>
    <tr><td>latest</td><td>The name of the latest strategy to use.</td>
        <td>No, defaults to 'default'</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>ivy</td><td>defines a pattern for ivy files, using the pattern attribute</td>
        <td>0..n</td></tr>
    <tr><td>artifact</td><td>defines a pattern for artifacts, using the pattern attribute</td>
        <td>1..n</td></tr>
</tbody>
</table>
]]>
</content>
</node>
<node id="node-90">
<nodeinfo  path='ivy/doc/resolver/url' md5_body='6eba729dacf981ae1054f25f5b7158c5' weight='-6' depth='5' type='book' author='admin' uid='1' created='1117639809' status='1' format='4' sticky='0' promote='1'/>
<title>Url Resolver</title>
<teaser>
<![CDATA[<table class="resolver">
<tr><td class="title">Tag</td><td class="value">url</td></tr>
<tr><td class="title">Handle latest</td><td class="value">yes with http urls (and apache server) and with file urls, no with other urls</td></tr>
<tr><td class="title">Handle publish</td><td class="value">no</td></tr>
</table>

<br/>
This resolver is one of the most generic, in fact most of the previous resolvers can be obtained by a particular configuration of this one. Indeed it uses urls to find ivy files and artifacts. The urls it uses are defined through ivy and artifact children, each giving a pattern to find ivy files or artifacts.]]>
</teaser>
<content>
<![CDATA[<table class="resolver">
<tr><td class="title">Tag</td><td class="value">url</td></tr>
<tr><td class="title">Handle latest</td><td class="value">yes with http urls (and apache server) and with file urls, no with other urls</td></tr>
<tr><td class="title">Handle publish</td><td class="value">no</td></tr>
</table>

<br/>
This resolver is one of the most generic, in fact most of the previous resolvers can be obtained by a particular configuration of this one. Indeed it uses urls to find ivy files and artifacts. The urls it uses are defined through ivy and artifact children, each giving a pattern to find ivy files or artifacts.

<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name which identify the resolver</td>
        <td>Yes</td></tr>
    <tr><td>validate</td><td>indicates if resolved ivy files should be validated against ivy xsd</td>
        <td>No, defaults to call setting</td></tr>
    <tr><td>checkmodified</td><td>Indicates if this resolver should check lastmodified date to know if an ivy file is up to date.</td>
        <td>No, defaults to ${ivy.resolver.default.check.modified}</td></tr>
    <tr><td>alwaysCheckExactRevision</td><td>Indicates if this resolver should check the given revision even if it's a special one (like latest.integration). <span class="since">since 1.3</span></td>
        <td>No, defaults to ${ivy.default.always.check.exact.revision}</td></tr>
    <tr><td>m2compatible</td><td>True if this resolver should be maven2 compatible, false otherwise <span class="since">since 1.3</span></td>
        <td>No, defaults to false</td></tr>
    <tr><td>namespace</td><td>The name of the namespace to which this resolver belong <span class="since">since 1.3</span></td>
        <td>No, defaults to 'system'</td></tr>
    <tr><td>checkconsistency</td><td>true to check consistency of module descriptors found by this resolver, false to avoid consistency check <span class="since">since 1.3</span></td>
        <td>No, defaults to true</td></tr>
    <tr><td>latest</td><td>The name of the latest strategy to use.</td>
        <td>No, defaults to 'default'</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>ivy</td><td>defines a pattern for ivy files, using the pattern attribute</td>
        <td>0..n</td></tr>
    <tr><td>artifact</td><td>defines a pattern for artifacts, using the pattern attribute</td>
        <td>1..n</td></tr>
</tbody>
</table>

<h1>Example</h1>
<code type="xml">
<url name="two-patterns-example">
  <ivy pattern="http://ivyrep.mycompany.com/[module]/[revision]/ivy-[revision].xml" />
  <artifact pattern="http://ivyrep.mycompany.com/[module]/[revision]/[artifact]-[revision].[ext]" />
  <artifact pattern="http://ivyrep.mycompany.com/[module]/[revision]/[artifact].[ext]" />
</url>
</code>
Looks for ivy files in one place and for artifacts in two places: with or without revision in name (revision being already in the directory structure).
]]>
</content>
</node>
<node id="node-91">
<nodeinfo  path='ivy/doc/resolver/chain' md5_body='58ae60bd858c46a7f434606571a58886' weight='-3' depth='5' type='book' author='admin' uid='1' created='1117639885' status='1' format='4' sticky='0' promote='1'/>
<title>Chain Resolver</title>
<teaser>
<![CDATA[<table class="resolver">
<tr><td class="title">Tag</td><td class="value">chain</td></tr>
<tr><td class="title">Handle latest</td><td class="value">depends on sub resolvers</td></tr>
<tr><td class="title">Handle publish</td><td class="value">delegates to first sub resolver in chain</td></tr>
</table>

This resolver is only a container of a chain of other resolvers. The sub resolvers can be any resolver, including a chain. An attribute enable to indicate if the chain must be iterated after the first found or not (at least when asking for a latest revision). If the chain is iterated, then it's the latest among the ones found that is returned. If the chain is not iterated, then it's the first found which is returned.]]>
</teaser>
<content>
<![CDATA[<table class="resolver">
<tr><td class="title">Tag</td><td class="value">chain</td></tr>
<tr><td class="title">Handle latest</td><td class="value">depends on sub resolvers</td></tr>
<tr><td class="title">Handle publish</td><td class="value">delegates to first sub resolver in chain</td></tr>
</table>

This resolver is only a container of a chain of other resolvers. The sub resolvers can be any resolver, including a chain. An attribute enable to indicate if the chain must be iterated after the first found or not (at least when asking for a latest revision). If the chain is iterated, then it's the latest among the ones found that is returned. If the chain is not iterated, then it's the first found which is returned.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name which identify the resolver</td>
        <td>Yes</td></tr>
    <tr><td>validate</td><td>indicates if resolved ivy files should be validated against ivy xsd</td>
        <td>No, defaults to call setting</td></tr>
    <tr><td>returnFirst</td><td>true if the first found should be returned.</td>
        <td>No, defaults to false</td></tr>
    <tr><td>dual</td><td>true if the chain should behave like a dual chain. <span class="since">since 1.3</span></td>
        <td>No, defaults to false</td></tr>
    <tr><td>namespace</td><td>The name of the namespace to which this resolver belong <span class="since">since 1.3</span></td>
        <td>No, defaults to 'system'</td></tr>
    <tr><td>latest</td><td>The name of the latest strategy to use.</td>
        <td>No, defaults to 'default'</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>any resolver</td><td>a sub resolver to use</td>
        <td>1..n</td></tr>
</tbody>
</table>
<h1>Examples</h1>
<code type="xml">
<chain name="test">
  <filesystem name="1">
    <ivy pattern="${ivy.conf.dir}/1/[organisation]/[module]/ivys/ivy-[revision].xml"/>
    <artifact pattern="${ivy.conf.dir}/1/[organisation]/[module]/[type]s/[artifact]-[revision].[ext]"/>
  </filesystem>
  <ivyrep name="2"/>
</chain>
</code>
Both a filesystem and ivyrep will be used to look for ivy files. If a dynamic revision is required, then both the filesystem and ivyrep will be queried to find the most recent revision among the two resolvers. Once the most recent revision is found in one resolver, it's the same resolver which will be used to download artifacts.
<hr/>
<code type="xml">
<chain name="test" returnFirst="true">
  <filesystem name="1">
    <ivy pattern="${ivy.conf.dir}/1/[organisation]/[module]/ivys/ivy-[revision].xml"/>
    <artifact pattern="${ivy.conf.dir}/1/[organisation]/[module]/[type]s/[artifact]-[revision].[ext]"/>
  </filesystem>
  <ivyrep name="2"/>
</chain>
</code>
Same as before, except that if a revision is found in the filesystem then ivyrep will not be queried: its the filesystem which will be used for both the ivy file and the artifacts.
<hr/>
<code type="xml">
<chain name="test" dual="true">
  <filesystem name="1">
    <ivy pattern="${ivy.conf.dir}/1/[organisation]/[module]/ivys/ivy-[revision].xml"/>
    <artifact pattern="${ivy.conf.dir}/1/[organisation]/[module]/[type]s/[artifact]-[revision].[ext]"/>
  </filesystem>
  <ivyrep name="2"/>
</chain>
</code>
Same as first example, except that once a module is found by either filesystem or ivyrep, then it's the whole chain which will be queried to download the artifacts. So in this case ivy file and artifacts may be split across the two resolvers for the same module.]]>
</content>
</node>
<node id="node-92">
<nodeinfo  path='ivy/doc/resolver/dual' md5_body='70aca563ea9d7851982cdb8006e223fa' weight='0' depth='5' type='book' author='admin' uid='1' created='1117639958' status='1' format='3' sticky='0' promote='1'/>
<title>Dual resolver</title>
<teaser>
<![CDATA[<table class="resolver">
<tr><td class="title">Tag</td><td class="value">dual</td></tr>
<tr><td class="title">Handle latest</td><td class="value">depends on sub resolvers</td></tr>
<tr><td class="title">Handle publish</td><td class="value">delegates to ivy sub resolver if artifact to publish is of "ivy" type, to artifact sub resolver otherwise</td></tr>
</table>

This resolver delegates its job to one resolver for ivy files and another for artifacts.

<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>]]>
</teaser>
<content>
<![CDATA[<table class="resolver">
<tr><td class="title">Tag</td><td class="value">dual</td></tr>
<tr><td class="title">Handle latest</td><td class="value">depends on sub resolvers</td></tr>
<tr><td class="title">Handle publish</td><td class="value">delegates to ivy sub resolver if artifact to publish is of "ivy" type, to artifact sub resolver otherwise</td></tr>
</table>

This resolver delegates its job to one resolver for ivy files and another for artifacts.

<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name which identify the resolver</td>
        <td>Yes</td></tr>
    <tr><td>validate</td><td>indicates if resolved ivy files should be validated against ivy xsd</td>
        <td>No, defaults to call setting</td></tr>
    <tr><td>namespace</td><td>The name of the namespace to which this resolver belong <span class="since">since 1.3</span></td>
        <td>No, defaults to 'system'</td></tr>
    <tr><td>latest</td><td>The name of the latest strategy to use.</td>
        <td>No, defaults to 'default'</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>any resolver</td><td>two resolvers, the first being the ivy resolver, the second the artifact resolver</td>
        <td>2</td></tr>
</tbody>
</table>
]]>
</content>
</node>
</node>
<node id="node-56">
<nodeinfo  path='ivy/doc/configuration/conflict-managers' md5_body='1460f2a845dfda008ace396acc0ac7d7' weight='-3' depth='4' type='book' author='admin' uid='1' created='1117629970' status='1' format='3' sticky='0' promote='1'/>
<title>conflict-managers</title>
<teaser>
<![CDATA[<b>Tag:</b> conflict-managers<br/>
<br/>
Defines a list of conflicts managers usable in ivy. Each conflict manager is identified by its name, given as an attribute.
The child tag used for the conflict manager must be equal to a name of a conflict manager type (either built-in
or added with the typedef tag). <br/><br/>

Here is a list of predefined conflicts managers (which do not require anything in the configuration file):<br/>
- all: this conflicts manager resolve conflicts by selecting all revisions. Also 
called NoConflictManager, it does evict any module.<br/>
- fixed: this conflict manager always select the same revision<br/>]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> conflict-managers<br/>
<br/>
Defines a list of conflicts managers usable in ivy. Each conflict manager is identified by its name, given as an attribute.
The child tag used for the conflict manager must be equal to a name of a conflict manager type (either built-in
or added with the typedef tag). <br/><br/>

Here is a list of predefined conflicts managers (which do not require anything in the configuration file):<br/>
- all: this conflicts manager resolve conflicts by selecting all revisions. Also 
called NoConflictManager, it does evict any module.<br/>
- fixed: this conflict manager always select the same revision<br/>
- latest-time: this conflict manager selects only the 'latest' revision, 
latest being defined as the latest in time. Note that latest in time
is costly to compute, so prefer latest-revision if you can.<br/>
- latest-revision: this conflict manager selects only the 'latest' revision, 
latest being defined by a string comparison of revisions.<br/><br/>

<h3>Child elements</h3>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>any conflict manager</td><td>adds a conflict manager to the list of available conflict managers</td>
        <td>0..n</td></tr>
</tbody>
</table>
]]>
</content>
</node>
<node id="node-57">
<nodeinfo  path='ivy/doc/configuration/modules' md5_body='7f0f536cf52624663ee0055e6dc2a548' weight='0' depth='4' type='book' author='admin' uid='1' created='1117630048' status='1' format='3' sticky='0' promote='1'/>
<title>modules</title>
<teaser>
<![CDATA[<b>Tag:</b> modules<br/>
<br/>
Defines the rules indicating which resolvers should be used for which modules.
The rules are given by defining a module set, using regexp for module organisation and name, and giving the name of the corresponding resolver to use.<br/>
If no rule match a given module, the default resolver will be used.<br/>
Even if not required, because the use of a default big resolver (chain, for instance) able to resolve all dependencies can answer all the needs, the configuration of smaller resolvers used for different cases can improve performances a lot. For instance, if you have a local repository for your modules and a distant repository for third party libraries, it is a good idea to have two separate resolvers, and configure ivy to use one for all your modules and another for the rest (the default one).]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> modules<br/>
<br/>
Defines the rules indicating which resolvers should be used for which modules.
The rules are given by defining a module set, using regexp for module organisation and name, and giving the name of the corresponding resolver to use.<br/>
If no rule match a given module, the default resolver will be used.<br/>
Even if not required, because the use of a default big resolver (chain, for instance) able to resolve all dependencies can answer all the needs, the configuration of smaller resolvers used for different cases can improve performances a lot. For instance, if you have a local repository for your modules and a distant repository for third party libraries, it is a good idea to have two separate resolvers, and configure ivy to use one for all your modules and another for the rest (the default one).
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="./ivy/doc/configuration/module">module</a></td><td>defines a module set rule</td>
        <td>1..n</td></tr>
</tbody>
</table>
]]>
</content>
<node id="node-58">
<nodeinfo  path='ivy/doc/configuration/module' md5_body='89a8ecf9d0534b55bee09be82e80e4a5' weight='-14' depth='5' type='book' author='admin' uid='1' created='1117630097' status='1' format='4' sticky='0' promote='1'/>
<title>module</title>
<teaser>
<![CDATA[<b>Tag:</b> module

Define a resolver application rule. The tag defines a module set, by giving an expression and the matcher to use for organisation and name (for instance, you can use
* to specify all). It also gives the name of the resolver to use for this module set.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>organisation</td><td>the name of the organisation to which apply the resolver. May be a regexp.</td>
        <td>Yes</td></tr>]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> module

Define a resolver application rule. The tag defines a module set, by giving an expression and the matcher to use for organisation and name (for instance, you can use
* to specify all). It also gives the name of the resolver to use for this module set.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>organisation</td><td>the name of the organisation to which apply the resolver. May be a regexp.</td>
        <td>Yes</td></tr>
    <tr><td>name</td><td>the name of the module to which apply the resolver. May be a regexp.</td>
        <td>Yes</td></tr>
    <tr><td>matcher</td><td>the matcher to use to match the modules to which the resolver should be applied <span class="since">since 1.3</span></td>
        <td>No, defaults to exactOrRegexp in pre 1.3 ivy files, and exact in 1.3 and superior</td></tr>
    <tr><td>resolver</td><td>the name of the resolver to apply. The resolver must have been defined in the resolvers section of the configuration file.</td>
        <td>Yes</td></tr>
</tbody>
</table>
<h1>Examples</h1>
<code type="xml">
<modules>
  <module organisation="jayasoft" name="*" resolver="myprojectsresolver"/>
</modules>
</code>
Uses myprojectresolver for all modules from jayasoft.
<hr/>
<code type="xml">
<modules>
  <module organisation="apache" name="commons-*" matcher="glob" resolver="myapachecommonsresolver"/>
</modules>
</code>
Uses myapachecommonsresolver for all modules beginning by commons- from apache.
<hr/>
<code type="xml">
<modules>
  <module organisation="apache" name="commons-[a-z]+" matcher="regexp" resolver="myapachecommonsresolver"/>
</modules>
</code>
Uses myapachecommonsresolver for all modules from apache beginning by commons- followed by any number of alphabetic lowercase characters.

]]>
</content>
</node>
</node>
</node>
<node id="node-43">
<nodeinfo  path='ivy/doc/ivyfile' md5_body='33467df92a1d66c8aaa684645fb9169f' weight='-8' depth='3' type='book' author='admin' uid='1' created='1117213581' status='1' format='4' sticky='0' promote='1'/>
<title>Ivy Files</title>
<teaser>
<![CDATA[Ivy use is entirely based on what is called ivy files. Ivy files are xml files, usually called ivy.xml, containing the description of the dependencies of a module, its published artifacts and its configurations.

Here is the simplest ivy file you can write:
<code type="xml">
<ivy-module version="1.3">
  <info organisation="myorg"
        module="mymodule"
        />
</ivy-module>
</code>

Since version 0.8, ivy publishes an xslt which help make ivy files more readable. You just have to add
a line like this one in your ivy file:
<pre>
&lt;?xml-stylesheet type="text/xsl" href="http://www.ivyrep.org/ivy-doc.xsl"?&gt;]]>
</teaser>
<content>
<![CDATA[Ivy use is entirely based on what is called ivy files. Ivy files are xml files, usually called ivy.xml, containing the description of the dependencies of a module, its published artifacts and its configurations.

Here is the simplest ivy file you can write:
<code type="xml">
<ivy-module version="1.3">
  <info organisation="myorg"
        module="mymodule"
        />
</ivy-module>
</code>

Since version 0.8, ivy publishes an xslt which help make ivy files more readable. You just have to add
a line like this one in your ivy file:
<pre>
&lt;?xml-stylesheet type="text/xsl" href="http://www.ivyrep.org/ivy-doc.xsl"?&gt;
</pre>
However, all information is not presented with the xslt (dependency configurations, in particular).
And due to security issues, it only works if the ivy file is in the same domain as the xsl... But they are particularly useful to browse the <a href="http://www.ivyrep.org/">ivy repository</a>.

If you want to see a sample file using almost all possibilities of ivy files, check this one, <a href="http://www.jayasoft.org/misc/ivy/samples/ivy-sample-xslt.xml">with</a> or <a href="./misc/ivy/samples/ivy-sample.xml">without</a> xslt.

Before beginning the reference itself, it is required to have in mind the terminology defined in the <a href="./ivy/doc/reference">main page</a> of this reference documentation.

For those familiar with xml schema, the schema used to validate ivy files can be found <a href="./misc/ivy/ivy.xsd">here</a>. For those using xsd aware IDE, you can declare the xsd in your ivy files to benefit from code completion / validation:
<code type="xml">
<?xml version="1.0" encoding="UTF-8"?>
<ivy-module version="1.3" 
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:noNamespaceSchemaLocation=
                   "http://www.jayasoft.org/misc/ivy/ivy.xsd">
  <info organisation="myorg"
        module="mymodule"
        />
</ivy-module>
</code>

<h1>Hierarchical Index</h1>
<pre>
ivy-module
    <a href="./ivy/doc/ivyfile/info">info</a>
        <a href="./ivy/doc/ivyfile/license">license</a>
        <a href="./ivy/doc/ivyfile/ivyauthor">ivyauthor</a>
        <a href="./ivy/doc/ivyfile/repository">repository</a>
        <a href="./ivy/doc/ivyfile/description">description</a>
    <a href="./ivy/doc/ivyfile/configurations">configurations</a>
        <a href="./ivy/doc/ivyfile/conf">conf</a>
    <a href="./ivy/doc/ivyfile/publications">publications</a>
        <a href="./ivy/doc/ivyfile/artifact">artifact</a>
            <a href="./ivy/doc/ivyfile/artifact-conf">conf</a>
    <a href="./ivy/doc/ivyfile/dependencies">dependencies</a>
        <a href="./ivy/doc/ivyfile/dependency">dependency</a>
            <a href="./ivy/doc/ivyfile/dependency-conf">conf</a>
                <a href="./ivy/doc/ivyfile/mapped">mapped</a>
            <a href="./ivy/doc/ivyfile/dependency-artifact">artifact</a>
                <a href="./ivy/doc/ivyfile/dependency-artifact-conf">conf</a>
            <a href="./ivy/doc/ivyfile/dependency-artifact">include</a>
                <a href="./ivy/doc/ivyfile/dependency-artifact-conf">conf</a>
            <a href="./ivy/doc/ivyfile/artifact-exclude">exclude</a>
                <a href="./ivy/doc/ivyfile/artifact-exclude-conf">conf</a>
    <a href="./ivy/doc/ivyfile/conflicts">conflicts</a>
        <a href="./ivy/doc/ivyfile/manager">manager</a>
</pre>

<h1>ivy-module</h1>
<b>Tag:</b> ivy-module

Root tag of any ivy-file.
<h2>Attributes</h2>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>version</td><td>the version of the ivy file specification - should be '1.3' with current version of ivy</td>
        <td>Yes</td></tr>
</tbody>
</table>
<h2>Child elements</h2>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>info</td><td>contains information about the described module</td>
        <td>1</td></tr>
    <tr><td>configurations</td><td>container for configuration elements</td>
        <td>0..1</td></tr>
    <tr><td>publications</td><td>container for published artifact elements</td>
        <td>0..1</td></tr>
    <tr><td>dependencies</td><td>container for dependency elements</td>
        <td>0..1</td></tr>
    <tr><td>conflicts</td><td>section to configure the conflict managers to use</td>
        <td>0..1</td></tr>
</tbody>
</table>]]>
</content>
<node id="node-59">
<nodeinfo  path='ivy/doc/ivyfile/info' md5_body='bef447b1ad4c2a8c1778db96db61ebb7' weight='-15' depth='4' type='book' author='admin' uid='1' created='1117630443' status='1' format='3' sticky='0' promote='1'/>
<title>info</title>
<teaser>
<![CDATA[<b>Tag:</b> info <b>Parent:</b> <a href="./ivy/doc/ivyfile">ivy-module</a><br/>
<br/>
Gives information about the module this ivy file describe
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>organisation</td><td>the name of the organisation that is the owner of this module.</td>
        <td>Yes</td></tr>
    <tr><td>module</td><td>the name of the module described by this ivy file.</td>
        <td>Yes</td></tr>
    <tr><td>revision</td><td>the revision of this module.</td>]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> info <b>Parent:</b> <a href="./ivy/doc/ivyfile">ivy-module</a><br/>
<br/>
Gives information about the module this ivy file describe
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>organisation</td><td>the name of the organisation that is the owner of this module.</td>
        <td>Yes</td></tr>
    <tr><td>module</td><td>the name of the module described by this ivy file.</td>
        <td>Yes</td></tr>
    <tr><td>revision</td><td>the revision of this module.</td>
        <td>Yes in repository ivy files, no in ivy files to resolve</td></tr>
    <tr><td>status</td><td>the status of this module. See <a href="./ivy/doc/reference">terminology</a> section for details</td>
        <td>No, default to 'integration'</td></tr>
    <tr><td>publication</td><td>the date of publication of this module. It should be given in this format: yyyyMMddHHmmss</td>
        <td>No, but it's a good practice to set it with delivered ivy files</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="./ivy/doc/ivyfile/license">license</a></td><td>contains information about the licenses of the described module</td>
        <td>0..n</td></tr>
    <tr><td><a href="./ivy/doc/ivyfile/ivyauthor">ivyauthor</a></td><td>describes who has contributed to write the ivy file</td>
        <td>0..n</td></tr>
    <tr><td><a href="./ivy/doc/ivyfile/repository">repository</a></td><td>describes on which public repositories this module can be found</td>
        <td>0..n</td></tr>
    <tr><td><a href="./ivy/doc/ivyfile/">description</a></td><td>describes how to use the module</td>
        <td>0..1</td></tr>
</tbody>
</table>
]]>
</content>
<node id="node-60">
<nodeinfo  path='ivy/doc/ivyfile/license' md5_body='58ab3563e1a87fc9df5b6886d38c0bad' weight='-12' depth='5' type='book' author='admin' uid='1' created='1117630648' status='1' format='3' sticky='0' promote='1'/>
<title>license</title>
<teaser>
<![CDATA[<b>Tag:</b> license <b>Parent:</b> <a href="./ivy/doc/ivyfile/info">info</a><br/>
<br/>
Gives information about a license of the described module.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the license. Try to respect spelling when using a classical license.</td>
        <td>Yes</td></tr>
    <tr><td>url</td><td>an url pointing to the license text.</td>
        <td>No, but it's a good practice to indicate it</td></tr>]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> license <b>Parent:</b> <a href="./ivy/doc/ivyfile/info">info</a><br/>
<br/>
Gives information about a license of the described module.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the license. Try to respect spelling when using a classical license.</td>
        <td>Yes</td></tr>
    <tr><td>url</td><td>an url pointing to the license text.</td>
        <td>No, but it's a good practice to indicate it</td></tr>
</tbody>
</table>
]]>
</content>
</node>
<node id="node-61">
<nodeinfo  path='ivy/doc/ivyfile/ivyauthor' md5_body='692558b67b626c5d278e69b9579fd7ae' weight='-10' depth='5' type='book' author='admin' uid='1' created='1117630720' status='1' format='3' sticky='0' promote='1'/>
<title>ivyauthor</title>
<teaser>
<![CDATA[<b>Tag:</b> ivyauthor <b>Parent:</b> <a href="./ivy/doc/ivyfile/info">info</a><br/>
<br/>
Gives information about who has contributed to write this ivy file. It does NOT indicate who 
is the author of the module itself.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the author, as a person or a company.</td>
        <td>Yes</td></tr>
    <tr><td>url</td><td>an url pointing to where the author can bea reached.</td>]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> ivyauthor <b>Parent:</b> <a href="./ivy/doc/ivyfile/info">info</a><br/>
<br/>
Gives information about who has contributed to write this ivy file. It does NOT indicate who 
is the author of the module itself.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the author, as a person or a company.</td>
        <td>Yes</td></tr>
    <tr><td>url</td><td>an url pointing to where the author can bea reached.</td>
        <td>No, but it's a good practice to indicate it</td></tr>
</tbody>
</table>
]]>
</content>
</node>
<node id="node-62">
<nodeinfo  path='ivy/doc/ivyfile/repository' md5_body='367c89e4e45f7a77ffec3e5a894b1b32' weight='-7' depth='5' type='book' author='admin' uid='1' created='1117630849' status='1' format='3' sticky='0' promote='1'/>
<title>repository</title>
<teaser>
<![CDATA[<b>Tag:</b> repository <b>Parent:</b> <a href="./ivy/doc/ivyfile/info">info</a><br/>
<br/>
Gives information about a public repository where the module can be found. This information
is given as an indication, repositories being able to be down over time.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the repository. Try to respect spelling for common repositories (ibiblio, ivyrep, ...)</td>
        <td>Yes</td></tr>]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> repository <b>Parent:</b> <a href="./ivy/doc/ivyfile/info">info</a><br/>
<br/>
Gives information about a public repository where the module can be found. This information
is given as an indication, repositories being able to be down over time.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the repository. Try to respect spelling for common repositories (ibiblio, ivyrep, ...)</td>
        <td>Yes</td></tr>
    <tr><td>url</td><td>an url pointing to the repository.</td>
        <td>Yes</td></tr>
    <tr><td>pattern</td><td>an ivy pattern to find modules on this repository</td>
        <td>No, but it's recommended to indicate it.</td></tr>
    <tr><td>ivys</td><td>true if ivy file can be found on this repository</td>
        <td>No, defaults to false.</td></tr>
    <tr><td>artifacts</td><td>true if module artifacts can be found on this repository</td>
        <td>No, defaults to false.</td></tr>
</tbody>
</table>
]]>
</content>
</node>
<node id="node-63">
<nodeinfo  path='ivy/doc/ivyfile/description' md5_body='9528656ba3dada84b5d90db79eb23f82' weight='-3' depth='5' type='book' author='admin' uid='1' created='1117630915' status='1' format='3' sticky='0' promote='1'/>
<title>description</title>
<teaser>
<![CDATA[<b>Tag:</b> description <b>Parent:</b> <a href="./ivy/doc/ivyfile/info">info</a><br/>
<br/>
Describes the current module. This tag is the only one which can contain free text,
including html. It is used to describe the module itself, usually in a single short phrase
(it is not meant to replace the module description on the corresponding web site), and then
gives all information necessary to use the module, especially information about
public configurations, how and when to use them.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> description <b>Parent:</b> <a href="./ivy/doc/ivyfile/info">info</a><br/>
<br/>
Describes the current module. This tag is the only one which can contain free text,
including html. It is used to describe the module itself, usually in a single short phrase
(it is not meant to replace the module description on the corresponding web site), and then
gives all information necessary to use the module, especially information about
public configurations, how and when to use them.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>homepage</td><td>the url of the homepage of the module</td>
        <td>No, but it's recommended to indicate it.</td></tr>
</tbody>
</table>
]]>
</content>
</node>
</node>
<node id="node-64">
<nodeinfo  path='ivy/doc/ivyfile/configurations' md5_body='a5ddc3392afd703a232ded3ca43cf44e' weight='-12' depth='4' type='book' author='admin' uid='1' created='1117630958' status='1' format='4' sticky='0' promote='1'/>
<title>configurations</title>
<teaser>
<![CDATA[<b>Tag:</b> configurations <b>Parent:</b> <a href="./ivy/doc/ivyfile">ivy-module</a>

Container for configuration element. If this container is not present, it is assumed that the module has one public configuration called 'default'.

<span class="since">since 1.3</span> You can define a new default conf mapping on this container by specifying the defaultconfmapping attribute.

A default conf mapping is very similar to the defaultconf which can be set on the dependencies tag, but it has a slightly different behaviour. 
The default conf mapping not only defines the conf mapping to use when no conf mapping is specified for a dependency in this ivy file, but it also modify the way ivy interprets conf mapping with no mapped conf. In this case, Ivy will look in the default conf mapping and use the conf mapping defined in the default conf mapping for the conf for which there is no mapped conf.]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> configurations <b>Parent:</b> <a href="./ivy/doc/ivyfile">ivy-module</a>

Container for configuration element. If this container is not present, it is assumed that the module has one public configuration called 'default'.

<span class="since">since 1.3</span> You can define a new default conf mapping on this container by specifying the defaultconfmapping attribute.

A default conf mapping is very similar to the defaultconf which can be set on the dependencies tag, but it has a slightly different behaviour. 
The default conf mapping not only defines the conf mapping to use when no conf mapping is specified for a dependency in this ivy file, but it also modify the way ivy interprets conf mapping with no mapped conf. In this case, Ivy will look in the default conf mapping and use the conf mapping defined in the default conf mapping for the conf for which there is no mapped conf.

See <a href="./ivy/doc/ivyfile/dependency#defaultconfmapping">examples on the dependency</a> page.

<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>defaultconfmapping</td><td>the default conf mapping to use in this ivy file <span class="since">since 1.3</span></td>
        <td>No, defaults to no default conf mapping</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="./ivy/doc/ivyfile/conf">conf</a></td><td>declares a configuration of this module</td>
        <td>0..n</td></tr>
    <tr><td><a href="./ivy/doc/ivyfile/include">include</a></td><td>include configurations from another file</td>
        <td>0..n</td></tr>
</tbody>
</table>
]]>
</content>
<node id="node-65">
<nodeinfo  path='ivy/doc/ivyfile/conf' md5_body='b9ec597cbcda18ce7c9d11000042c8cd' weight='-11' depth='5' type='book' author='admin' uid='1' created='1117631038' status='1' format='3' sticky='0' promote='1'/>
<title>conf</title>
<teaser>
<![CDATA[<b>Tag:</b> conf <b>Parent:</b> <a href="./ivy/doc/ivyfile/configurations">configurations</a><br/>
<br/>
Declares a configuration of this module. As described in the reference page, a 
configuration is a way to use or construct a module. Some modules may be 
used in different ways (think about hibernate which can be used inside or outside
an application server), and this way may alter the artifacts you need (in the case
of hibernate, jta.jar is needed only if it is used outside an application server).
Moreover, a module may need some other modules and artifacts only at build time,
and some others at runtime. All those differents ways to use or build a module]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> conf <b>Parent:</b> <a href="./ivy/doc/ivyfile/configurations">configurations</a><br/>
<br/>
Declares a configuration of this module. As described in the reference page, a 
configuration is a way to use or construct a module. Some modules may be 
used in different ways (think about hibernate which can be used inside or outside
an application server), and this way may alter the artifacts you need (in the case
of hibernate, jta.jar is needed only if it is used outside an application server).
Moreover, a module may need some other modules and artifacts only at build time,
and some others at runtime. All those differents ways to use or build a module
are called in ivy configurations.<br/><br/>
The conf element in the configurations section declares one configuration. This 
declaration gives the name of the configuration declared, its visibility and the 
other configurations of the module it extends.<br/><br/>
Visibility is used to indicate whether or not a configuration can be used from
other modules depending on this one. Thus a private configuration is only used
for internal purpose (maybe at build time), and other modules cannot declare
to depend on it.<br/><br/>
A configuration can also extend one or several other ones of the same module. When 
a configuration extends another one, then all artifacts required in the extended
configuration will also be required in the configuration that extends the other one.
For instance, if configuration B extends configuration A, and if artifacts art1 and art2
are required in configuration A, then they will be automatically required in configuration B.
On the other hand, artifacts required in configuration B are not necessarily required in 
configuration A.<br/>
This notion is very helpful to define configurations which are similar with some differences.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the declared configuration</td>
        <td>Yes</td></tr>
    <tr><td>description</td><td>a description for the declared configuration</td>
        <td>No</td></tr>
    <tr><td>visibility</td><td>the visibility of the declared configuration. 
    'public' means that this configuration can be used by other modules, while 'private'
    means that this configuration is used only in the module itself, and is not exposed
    to other modules</td>
        <td>No, defaults to public</td></tr>
    <tr><td>extends</td><td>a comma separated list of configurations of this module that the 
    current configuration extends</td>
        <td>No, defaults to none</td></tr>
    <tr><td>deprecated</td><td>indicates that this conf has been deprecated by giving the date of the deprecation. 
    	It should be given in this format: yyyyMMddHHmmss</td>
        <td>No, by default the conf is not deprecated</td></tr>
</tbody>
</table>
]]>
</content>
</node>
<node id="node-415">
<nodeinfo  path='ivy/doc/ivyfile/include' md5_body='422cfbe5e12d1706e1b3baad0dab0cae' weight='0' depth='5' type='book' author='xavier' uid='6' created='1138080184' status='1' format='4' sticky='0' promote='0'/>
<title>include</title>
<teaser>
<![CDATA[<b>Tag:</b> include <b>Parent:</b> <a href="./ivy/doc/ivyfile/configurations">configurations</a>

Include configurations specified in another file. <span class="since">since 1.3</span>

The included file should have a configurations tag as root tag, which follow the same specification as the <a href="./ivy/doc/ivyfile/configurations">configurations</a> tag of the ivy file. 

This means that it can contain conf declarations, other file inclusion, and also a defaultconfmapping.

When delivering an ivy file with such an inclusion, the included configuration file is inlined, i.e. ivy remove the dependency on the external file.]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> include <b>Parent:</b> <a href="./ivy/doc/ivyfile/configurations">configurations</a>

Include configurations specified in another file. <span class="since">since 1.3</span>

The included file should have a configurations tag as root tag, which follow the same specification as the <a href="./ivy/doc/ivyfile/configurations">configurations</a> tag of the ivy file. 

This means that it can contain conf declarations, other file inclusion, and also a defaultconfmapping.

When delivering an ivy file with such an inclusion, the included configuration file is inlined, i.e. ivy remove the dependency on the external file.

<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>file</td><td>the file to include</td>
        <td>Yes</td></tr>
</tbody>
</table>
<h1>Examples</h1>
<code type="xml">
<ivy-module version="1.0">
  <info organisation="myorg"
         module="mymodule"
  />
  <configurations>
    <include file="path/to/included-configurations.xml"/>
    <conf name="conf3"/>
  </configurations>
  <dependencies>
    <dependency name="mymodule1" rev="1.0"/>
    <dependency name="mymodule2" rev="2.0" conf="conf2,conf3->*"/>
  </dependencies>
</ivy-module>
</code>
with included-configurations.xml like this:
<code type="xml">
<configurations defaultconfmapping="*->@">
  <conf name="conf1" visibility="public"/>
  <conf name="conf2" visibility="private"/>
</configurations>
</code>
Defines 3 configurations, conf1, conf2 and conf3. mymodule1 is required in each configuration, with for each the same configuration (conf1 is needed in conf1, conf2 in conf2, and conf3 in conf3) due to the defaultconfmapping defined in the included file.]]>
</content>
</node>
</node>
<node id="node-66">
<nodeinfo  path='ivy/doc/ivyfile/publications' md5_body='74d7ec6c1712d555a042bb893c811eea' weight='-6' depth='4' type='book' author='admin' uid='1' created='1117631116' status='1' format='3' sticky='0' promote='1'/>
<title>publications</title>
<teaser>
<![CDATA[<b>Tag:</b> publications <b>Parent:</b> <a href="./ivy/doc/ivyfile">ivy-module</a><br/><br/>

Container for artifact elements, used to describe the artifacts published by this module. 
If this container is not present, it is assumed that the module has one artifact, with the same name
as the module, and published in all module configurations.<br/>
Thus if you have a module which publishes no artifacts (a sort of virtual module, 
made only to integrate several other modules as a whole), you have to include
a publications element with no artifact sub element.
<h1>Child elements</h1>
<table class="ivy-children">]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> publications <b>Parent:</b> <a href="./ivy/doc/ivyfile">ivy-module</a><br/><br/>

Container for artifact elements, used to describe the artifacts published by this module. 
If this container is not present, it is assumed that the module has one artifact, with the same name
as the module, and published in all module configurations.<br/>
Thus if you have a module which publishes no artifacts (a sort of virtual module, 
made only to integrate several other modules as a whole), you have to include
a publications element with no artifact sub element.
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>artifact</td><td>declares a published artifact for this module</td>
        <td>0..n</td></tr>
</tbody>
</table>
]]>
</content>
<node id="node-67">
<nodeinfo  path='ivy/doc/ivyfile/artifact' md5_body='298135c07deb7085ffec4ee70839ebe4' weight='0' depth='5' type='book' author='admin' uid='1' created='1117631172' status='1' format='3' sticky='0' promote='1'/>
<title>artifact</title>
<teaser>
<![CDATA[<b>Tag:</b> artifact <b>Parent:</b> <a href="./ivy/doc/ivyfile/publications">publications</a><br/><br/>

Declares an artifact published by this module. This is especially useful
for other modules dependending on this one. They thus get all published artifacts
belonging to the configurations asked. Indeed, each published artifact declares in which
public configuration it is published. Thus a module depending on this module
only get artifacts marked with the asked configurations, taking into account
configurations extension (see <a href="./ivy/doc/ivyfile/conf">configuration declaration</a>).<br/><br/>]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> artifact <b>Parent:</b> <a href="./ivy/doc/ivyfile/publications">publications</a><br/><br/>

Declares an artifact published by this module. This is especially useful
for other modules dependending on this one. They thus get all published artifacts
belonging to the configurations asked. Indeed, each published artifact declares in which
public configuration it is published. Thus a module depending on this module
only get artifacts marked with the asked configurations, taking into account
configurations extension (see <a href="./ivy/doc/ivyfile/conf">configuration declaration</a>).<br/><br/>
The configurations in which an artifact is published can be configured in two ways:<br/>
- conf attribute on artifact element<br/>
- conf subelement<br/>
The twos are equivalent, it is only a matter of preference. However, do not mix both
for one artifact.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the published artifact. This name must not include revision.</td>
        <td>Yes</td></tr>
    <tr><td>type</td><td>the type of the published artifact. It's usually its extension, but not necessarily. For instance, ivy files are of type 'ivy' but have 'xml' extension</td>
        <td>Yes</td></tr>
    <tr><td>ext</td><td>the extension of the published artifact</td>
        <td>No, defaults to type</td></tr>
    <tr><td>conf</td><td>comma separated list of public configurations in which this artifact is published.
    	'*' wildcard can be used to designate all public configurations of this module</td>
        <td>No, defaults to '*' if neither conf attribute nor conf children element is given</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="/ivy/doc/ivyfile/artifact-conf">conf</a></td><td>indicates a public configuration in which this artifact is published</td>
        <td>0..n</td></tr>
</tbody>
</table>
]]>
</content>
<node id="node-68">
<nodeinfo  path='ivy/doc/ivyfile/artifact-conf' md5_body='e0feabd1cef5f4154080484e4c1f27b2' weight='0' depth='6' type='book' author='admin' uid='1' created='1117631300' status='1' format='3' sticky='0' promote='1'/>
<title>conf</title>
<teaser>
<![CDATA[<b>Tag:</b> conf <b>Parent:</b> <a href="./ivy/doc/ivyfile/artifact">artifact</a><br/>
<br/>
Indicates a public configuration in which enclosing artifact is published.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the module public configuration in which this artifact is published. 
    	'*' wildcard can be used to designate all public configurations of this module</td>
        <td>Yes</td></tr>]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> conf <b>Parent:</b> <a href="./ivy/doc/ivyfile/artifact">artifact</a><br/>
<br/>
Indicates a public configuration in which enclosing artifact is published.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the module public configuration in which this artifact is published. 
    	'*' wildcard can be used to designate all public configurations of this module</td>
        <td>Yes</td></tr>
</tbody>
</table>
]]>
</content>
</node>
</node>
</node>
<node id="node-69">
<nodeinfo  path='ivy/doc/ivyfile/dependencies' md5_body='170b8224ef36ebe3671a723d5b3f21ab' weight='0' depth='4' type='book' author='admin' uid='1' created='1117631368' status='1' format='4' sticky='0' promote='1'/>
<title>dependencies</title>
<teaser>
<![CDATA[<b>Tag:</b> dependencies <b>Parent:</b> <a href="./ivy/doc/ivyfile/">ivy-module</a>

Container for dependency elements, used to describe the dependencies of this module. 
If this container is not present, it is assumed that the module has no dependency at all.

This container let the possibility to defines two very similar things: defaultconf and defaultconfmapping.

<code>defaultconf</code> exists since Ivy 1.1 and enables to define the default conf attribute to use when no conf is defined for a dependency in this ivy file. It is only used when no conf mapping is defined, and has no influence in other cases.]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> dependencies <b>Parent:</b> <a href="./ivy/doc/ivyfile/">ivy-module</a>

Container for dependency elements, used to describe the dependencies of this module. 
If this container is not present, it is assumed that the module has no dependency at all.

This container let the possibility to defines two very similar things: defaultconf and defaultconfmapping.

<code>defaultconf</code> exists since Ivy 1.1 and enables to define the default conf attribute to use when no conf is defined for a dependency in this ivy file. It is only used when no conf mapping is defined, and has no influence in other cases.

<code>defaultconfmapping</code> exists since Ivy 1.3 and enables not only to define the default conf mapping when no conf is specified for a dependency in this ivy file, but it also influence the way conf mapping with no mapped conf are interpreted (see <a href="/ivy/doc/ivyfile/configurations">configurations doc page</a> for details about this).

Note that if both defaultconf and defaultconfmapping are defined, it's the defaultconfmapping that is used. Note also that if several defaultconfmapping are defined (one in the configurations tag, one or several in included configurations file, and/or one in the dependency tag, then it's only the last which is taken into account, the others will have no effect at all.
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>defaultconf</td><td>the default configuration to use when none is specified in a dependency. <span class="since">since 1.1</span></em></td>
        <td>No, defaults to *->*</td></tr>
    <tr><td>defaultconfmapping</td><td>the default configuration mapping to use in this ivy fie. <span class="since">since 1.3</span></em></td>
        <td>No, defaults to no default conf mapping</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="./ivy/doc/ivyfile/dependency">dependency</a></td><td>declares a dependency for this module</td>
        <td>1..n</td></tr>
</tbody>
</table>
]]>
</content>
<node id="node-70">
<nodeinfo  path='ivy/doc/ivyfile/dependency' md5_body='7248901f254e397b9dcb7435af5a197d' weight='0' depth='5' type='book' author='admin' uid='1' created='1117631409' status='1' format='4' sticky='0' promote='1'/>
<title>dependency</title>
<teaser>
<![CDATA[<b>Tag:</b> dependency <b>Parent:</b> <a href="./ivy/doc/ivyfile/dependencies">dependencies</a>

Declares a dependency for this module. A dependency is described by the module on which the current module depends (identified by its name, organisation and revision), and a mapping of configurations.

<h2>Fixed and latest revisions</h2>
The revision can be given as a fixed one (1.5.2, for instance) or as a latest one. Two possibilities are offered for the moment:
<ul>
<li>latest.integration</li> selects the latest revision of the dependency module.
<li>end the revision with a +</li> selects the latest sub-revision of the dependency module. For instance, ]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> dependency <b>Parent:</b> <a href="./ivy/doc/ivyfile/dependencies">dependencies</a>

Declares a dependency for this module. A dependency is described by the module on which the current module depends (identified by its name, organisation and revision), and a mapping of configurations.

<h2>Fixed and latest revisions</h2>
The revision can be given as a fixed one (1.5.2, for instance) or as a latest one. Two possibilities are offered for the moment:
<ul>
<li>latest.integration</li> selects the latest revision of the dependency module.
<li>end the revision with a +</li> selects the latest sub-revision of the dependency module. For instance, 
if the dependency module exists in revision 1.0.3, 1.0.7 and 1.1.2, "1.0.+" will select 1.0.7.
</ul>
The way to determine which revision is the "latest" between two is configurable through the use of pluggable LatestStrategy. See <a href="./ivy/doc/reference">ivy main concepts</a> for details about this.

<h2>Configurations mapping</h2>
This mapping indicates which configurations of the dependency are required in which configurations of the current module, also called master configurations.

There are several ways to declare this mapping of configurations, choose depending more on preference than on possibilities. Try to avoid mixing usage in a single dependency element: do not use both nested and inline mapping declaration.

The first way to declare this mapping is called the inline mapping. It is maybe the less natural at first, but it's powerful and concise. Inline mapping can take several forms.

<ul>
<li>Specify one configuration name</li> This means that in this master configuration the same dependency configuration is needed (except if a defaultconfmapping has been specified in this ivy file, see <a href="/ivy/doc/ivyfile/configurations">configurations</a> for details, or table below for examples).
For instance, if the current module has defined a configuration named 'runtime', and the dependency too, then having an inline mapping configuration set to 'runtime' means that in the runtime master configuration the runtime dependency configuration is required.

<a name="defaultconfmapping"/>More examples:
The table below indicates how ivy interpret the conf attribute according to how <a href="/ivy/doc/ivyfile/configurations">defaultconfmapping</a> is set:<table class="ivy-attributes"><thead><tr><th>defaultconfmapping</th><th>conf</th><th>ivy interpretation</th></tr>
</thead>
<tbody>
<tr><td></td><td></td><td><code>*->*</code></td></tr>
<tr><td></td><td>runtime</td><td><code>runtime->runtime</code></td></tr>
<tr><td></td><td>test</td><td><code>test->test</code></td></tr>
<tr><td><code>runtime->*;test->default</code></td><td></td><td><code>runtime->*;test->default</code></td></tr>
<tr><td><code>runtime->*;test->default</code></td><td>runtime</td><td><code>runtime->*</code></td></tr>
<tr><td><code>runtime->*;test->default</code></td><td>test</td><td><code>test->default</code></td></tr>
</tbody>
</table>

<li>Specify a configuration mapping using the '->' operator separating a comma separated list of master configurations (left operand) of a comma separated list of dependency configurations (right operand).</li>
In this case, all specified dependency configurations are required in all specified master configurations.
For instance, 'A, B, C -> E, F' means that dependency configurations E & F are required in master configurations A, B and C.

Note that you can use the wildcard '*' as a configuration name, meaning that all configurations (either master or dependency public ones depending on the side) are wanted. For instance, '* -> B, C' means that B & C dependency configurations are required in all master configurations.

<span class="since">since 1.2</span> '@' also has a special meaning as a right operand of the dependency mapping, it means map to self. This is particularly useful with '*', '*->@' meaning that all configurations of the module maps to their equivalent (same name) in the dependency.

<span class="since">since 1.3</span> a fallback mechanism can be used when you are not sure that the dependency will have the required conf. You can indicate to ivy that you want one configuration, but if it isn't present, use another one. 
The syntax for specifying this adds the fallback conf between parenthesis right after the required conf. 
For instance, <code>test->runtime(default)</code> means that in the test configuration of the module the <code>runtime</code> conf of the dependency is required, but if doesn't exist, it will use the <code>default</code> conf instead. If <code>default</code> conf doesn't exist then it will be considered as an error. Note that the <code>*</code> wildcard can be used as fallback conf.

<li>Specify a semi-column separated list of any of the previous specs.</li> In this case, it is the union of the mapping which is kept. For instance, 'A -> B; * -> C' means that B conf is needed in A conf and C conf is need in all master conf... so both B & C dep conf are required in A master conf
</ul>

If you prefer more verbose mapping declaration, everything is also possible with sub elements mapping declaration. 

<h2>Artifact restriction</h2>
Moreover, the dependency element also supports an artifact restriction feature (since 0.6).
See <a href="#dependency-artifact">dependency artifact restriction</a> for details. <br/><br/>

<h2>Forcing revision</h2>
Finally, the dependency element also supports an a force attribute (since 0.8), which gives an indication
to conflicts manager to force the revision of a dependency to the one given here.<br/>
See <a href="./ivy/doc/ivyfile/conflicts">conflicts manager</a> for details. <br/><br/>


<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>org</td><td>the name of the organisation of the dependency.</td>
        <td>No, defaults to the master module organisation</td></tr>
    <tr><td>name</td><td>the module name of the dependency</td>
        <td>Yes</td></tr>
    <tr><td>rev</td><td>the revision of the dependency. Use 'latest.integration' to get the latest version of the dependency. You can also end the revision asked with a '+' to get the latest matching revision. Both latest works only with some dependency resolvers (see <a href="./ivy/doc/configuration">configuration</a>)</td>
        <td>Yes</td></tr>
    <tr><td>force</td><td>a boolean to give an indication to conflict manager that this dependency 
     should be forced to this revision (see <a href="./ivy/doc/ivyfile/conflicts">conflicts manager</a>)</td>
        <td>No, defaults to false</td></tr>
    <tr><td>conf</td><td>an inline mapping configuration spec (see above for details)</td>
        <td>No, defaults to defaultconf attribute of dependencies element if neither conf attribute nor conf children element is given</td></tr>
    <tr><td>transitive</td><td>true to resolve this dependency transitively, false otherwise (<span class="since">since 1.2</span>)</td>
        <td>No, defaults to true</td></tr>
    <tr><td>changing</td><td>true if the dependency artifacts may change without revision change, false otherwise (<span class="since">since 1.2</span>). Artifacts update will be looked after only if the publication date of the ivy file has changed. Note that this is not a recommended use and that it avoid some cache optimization in ivy.</td>
        <td>No, defaults to false</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="./ivy/doc/ivyfile/dependency-conf">conf</a></td><td>defines configuration mapping has sub element</td>
        <td>0..n</td></tr>
    <tr><td><a href="./ivy/doc/ivyfile/dependency-artifact">artifact / include</a></td><td>defines artifacts inclusion - use only if you do not control dependency ivy file</td>
        <td>0..n</td></tr>
    <tr><td><a href="./ivy/doc/ivyfile/artifact-exclude">exclude</a></td><td>defines artifacts exclusion - use only if you do not control dependency ivy file</td>
        <td>0..n</td></tr>
</tbody>
</table>

<h1>Examples</h1>
<code type="xml">
<dependency org="jayasoft" name="swtbinding" revision="0.2"/>
</code>
Declares a dependency on the module swtbinding from jayasoft in its revision 0.2. All the configuration of this dependency will be included in all configurations of the module in which the dependency is declared.
<hr/>
<code type="xml">
<dependency name="mymodule" revision="latest.integration" conf="test->default"/>
</code>
Declares a dependency on the module <code>mymodule</code> from the same organisation as the module in which the dependency is declared. The latest available revision of this dependency will be used. This dependency will only be included in the test configuration of the module, and it's only the default configuration of the dependency which will be included.
<hr/>
<code type="xml">
<dependency org="apache" name="commons-lang" revision="2.0" force="true" conf="default"/>
</code>
Declares a dependency on the module <code>commons-lang</code> from apache, in revision 2.0. The revision 2.0 will be used even if another dependency declares itself a dependency on another version of commons-lang. Moreover, if no defaultconfmapping is defined, only the <code>default</code> conf of commons-lang will be used in the <code>default</code> conf of the master module. If <code>*->runtime</code> was declared as defaultconfmapping, then the runtime conf of commons-lang would be included in the default conf of the master module. Note that whatever the defaultconfmapping is, the dependency only be included in the default conf of the master module. The defaultconfmapping only changes the required dependency confs.
<hr/>
<code type="xml">
<dependency org="foo" name="bar" revision="3.0" transitive="false" conf="default->@;runtime,test->runtime"/>
</code>
Declares a dependency on the module <code>bar</code> from foo, in revision 3.0. The dependencies of bar will themselves not be included due to the setting of transitive. The default dependency conf will be included in the default master conf, and the runtime dependency conf will be included in both the runtime and test master conf.
<hr/>
<code type="xml">
<dependency org="foo" name="bar" revision="3.0" changing="true" conf="compile->runtime(default)"/>
</code>
Declares a dependency on the module <code>bar</code> from foo, in revision 3.0. This revision is considered to be able to change (<code>changing="true"</code>), so even if it is already in ivy cache, Ivy will check if a revision is a more recent last modified date is available on the repository. The runtime conf of bar is required in the compile conf of the master module, but if bar doesn't define a runtime conf, then the <code>default</code> conf will be used.]]>
</content>
<node id="node-71">
<nodeinfo  path='ivy/doc/ivyfile/dependency-conf' md5_body='aca2329705de2274585aeaa526a26b02' weight='-12' depth='6' type='book' author='admin' uid='1' created='1117631747' status='1' format='3' sticky='0' promote='1'/>
<title>conf</title>
<teaser>
<![CDATA[<b>Tag:</b> conf <b>Parent:</b> <a href="./ivy/doc/ivyfile/dependency">dependency</a><br/>
<br/>
Describes a configuration mapping for a dependency. See also the inline configuration mapping
in dependency element.

<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the master configuration to map. 
    	'*' wildcard can be used to designate all configurations of this module</td>
        <td>Yes</td></tr>]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> conf <b>Parent:</b> <a href="./ivy/doc/ivyfile/dependency">dependency</a><br/>
<br/>
Describes a configuration mapping for a dependency. See also the inline configuration mapping
in dependency element.

<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the master configuration to map. 
    	'*' wildcard can be used to designate all configurations of this module</td>
        <td>Yes</td></tr>
    <tr><td>mapped</td><td>a comma separated list of dependency configurations to which this
    master configuration should be mapped</td>
        <td>No, default to the same configuration as master one, unless nested mapped elements are specified</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="./ivy/doc/ivyfile/mapped">mapped</a></td><td>map dependency configurations for this master configuration</td>
        <td>0..n</td></tr>
</tbody>
</table>
]]>
</content>
<node id="node-72">
<nodeinfo  path='ivy/doc/ivyfile/mapped' md5_body='451e9414f13469349e9eaf98893a60b5' weight='0' depth='7' type='book' author='admin' uid='1' created='1117631793' status='1' format='3' sticky='0' promote='1'/>
<title>mapped</title>
<teaser>
<![CDATA[<b>Tag:</b> mapped <b>Parent:</b> <a href="./ivy/doc/ivyfile/dependency-conf">conf</a><br/>
<br/>
Describes a mapped dependency configuration for a master configuration.

<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the dependency configuration mapped. 
    	'*' wildcard can be used to designate all configurations of this module</td>
        <td>Yes</td></tr>
</tbody>
</table>
]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> mapped <b>Parent:</b> <a href="./ivy/doc/ivyfile/dependency-conf">conf</a><br/>
<br/>
Describes a mapped dependency configuration for a master configuration.

<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the dependency configuration mapped. 
    	'*' wildcard can be used to designate all configurations of this module</td>
        <td>Yes</td></tr>
</tbody>
</table>
]]>
</content>
</node>
</node>
<node id="node-73">
<nodeinfo  path='ivy/doc/ivyfile/dependency-artifact' md5_body='263d28d8239885f8c2634ea37e177aae' weight='0' depth='6' type='book' author='admin' uid='1' created='1117633224' status='1' format='3' sticky='0' promote='1'/>
<title>artifact include</title>
<teaser>
<![CDATA[<b>Tag:</b> artifact <b>Parent:</b> <a href="./ivy/doc/ivyfile/dependency">dependency</a><br/>
<b>Tag:</b> include <b>Parent:</b> <a href="./ivy/doc/ivyfile/dependency">dependency</a><br/>
<br/>

This feature gives you more control on a dependency for which you do not control its ivy file. 
It enables two things:<br/>
- restrict the artifacts required by including only the artifacts given here, even if configuration does not a good separation of published artifacts<br/>
- specify the artifacts required, if the dependency has no ivy file. Indeed, when a module has no ivy file, it 
is assumed that it publishes exactly one artifact having the same name as the module itself. But when this ]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> artifact <b>Parent:</b> <a href="./ivy/doc/ivyfile/dependency">dependency</a><br/>
<b>Tag:</b> include <b>Parent:</b> <a href="./ivy/doc/ivyfile/dependency">dependency</a><br/>
<br/>

This feature gives you more control on a dependency for which you do not control its ivy file. 
It enables two things:<br/>
- restrict the artifacts required by including only the artifacts given here, even if configuration does not a good separation of published artifacts<br/>
- specify the artifacts required, if the dependency has no ivy file. Indeed, when a module has no ivy file, it 
is assumed that it publishes exactly one artifact having the same name as the module itself. But when this 
module publishes more artifacts, or simply does not respect the name rule, and if you cannot deliver
an ivy file for it (because you do not control the repository, for instance - think about maven ibiblio 
repository, to give no name), then this feature let you specify the artifacts names you want to retrieve.<br/><br/>

This feature is handled by two tags, artifact and include, which are stricly equivalent. However,
it is a good practive to use the artifact tag to specify the artifact required, and the include tag to specify
artifact inclusion among dependency published ones.<br/><br/>

Each artifact restriction can be given in the context of particular master configurations. By default, if no 
configuration is specified, artifacts restriction apply to all master configurations. But you can specify 
that a restriction applies only to one or several master configurations, using either inline or nested conf
specification. In this case, do not forget that if you do not specify any restriction for a particular configuration,
then no restriction will apply for this configuration and it will be resolved not taking into account any restriction.<br/><br/>
For instance, imagine you have A, B & C master configurations. If you restrict to art1 in A & B and art2 in A,
then C will not be restricted at all, and will thus get all artifacts of all dependency configurations if you do not
specify a configuration mapping. To prevent this, you have to specify a configuration mapping for the dependency,
mapping only A & B to some or all dependency configurations.<br/>
Example:<br/>
<pre>
&lt;dependency org="yourorg" name="yourmodule9" rev="9.1" <b>conf="A,B-&gt;default"</b>&gt;
	&lt;artifact name="art1" type="jar" conf="A,B"/&gt;
	&lt;artifact name="art2" type="jar" conf="A"/&gt;
&lt;/dependency&gt;		
</pre>

<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of an artifact of the dependency module to add to the include list, or a regexp matching this name</td>
        <td>No, defaults to .*</td></tr>
    <tr><td>type</td><td>the type of the artifact of the dependency module to add to the include list, or a regexp matching this name</td>
        <td>No, defaults to .*</td></tr>
    <tr><td>ext</td><td>the extension of the artifact of the dependency module to add to the include list, or a regexp matching this name</td>
        <td>No, defaults to type</td></tr>
    <tr><td>conf</td><td>comma separated list of the master configurations in which this artifact should be included.
    '*' wildcard can be used to designate all configurations of this module</td>
        <td>No, defaults to '*', unless nested conf are specified</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="./ivy/doc/ivyfile/dependency-artifact-conf">conf</a></td><td>configuration in which the artifact should be included</td>
        <td>0..n</td></tr>
</tbody>
</table>
]]>
</content>
<node id="node-74">
<nodeinfo  path='ivy/doc/ivyfile/dependency-artifact-conf' md5_body='d90fbe1955183ba22d4a16533be0e682' weight='0' depth='7' type='book' author='admin' uid='1' created='1117633683' status='1' format='3' sticky='0' promote='1'/>
<title>conf</title>
<teaser>
<![CDATA[<b>Tag:</b> conf <b>Parent:</b> <a href="./ivy/doc/ivyfile/dependency-artifact">artifact</a><br/>
<br/>
Specify a configuration in which the enclosing artifact inclusion should be included.

<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the master configuration in which the enclosing artifact should be included</td>
        <td>Yes</td></tr>
</tbody>
</table>
]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> conf <b>Parent:</b> <a href="./ivy/doc/ivyfile/dependency-artifact">artifact</a><br/>
<br/>
Specify a configuration in which the enclosing artifact inclusion should be included.

<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the master configuration in which the enclosing artifact should be included</td>
        <td>Yes</td></tr>
</tbody>
</table>
]]>
</content>
</node>
</node>
<node id="node-75">
<nodeinfo  path='ivy/doc/ivyfile/artifact-exclude' md5_body='61afd1495f274ecb638e83a879c6b8aa' weight='0' depth='6' type='book' author='admin' uid='1' created='1117633749' status='1' format='4' sticky='0' promote='1'/>
<title>exclude</title>
<teaser>
<![CDATA[<b>Tag:</b> exclude <b>Parent:</b> <a href="./ivy/doc/ivyfile/dependency">dependency</a>

This feature gives you more control on a dependency for which you do not control its ivy file. 
It enables to restrict the artifacts required, by excluding artifacts being published by the dependency or any of its transitive dependencies, 
even if configuration does not a good separation of published artifacts

The same principle concerning configuration as for include applies to this exclude feature (see above the include feature).

Note that exclusion is always done AFTER inclusion has been done.]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> exclude <b>Parent:</b> <a href="./ivy/doc/ivyfile/dependency">dependency</a>

This feature gives you more control on a dependency for which you do not control its ivy file. 
It enables to restrict the artifacts required, by excluding artifacts being published by the dependency or any of its transitive dependencies, 
even if configuration does not a good separation of published artifacts

The same principle concerning configuration as for include applies to this exclude feature (see above the include feature).

Note that exclusion is always done AFTER inclusion has been done.

<span class="since">since 1.3</span> This exclude feature can also be used not only to exclude artifacts but also to exclude whole modules. Indeed when you exclude artifacts, it doesn't avoid ivy to search for the module itself, and to resolve the dependencies of the module. But you can also exclude the whole module, which means that the module will not be downloaded at all, and so its own dependencies will not be resolved. For sure, this is usually done to exclude not a direct dependency but an indirect one. To exclude a whole module, you just have to not specify any artifact name, type and ext in your exclude rule. For instance:
<code type="xml">
<dependency name="A" rev="1.0">
  <exclude module="B"/>
</dependency>
</code>
<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>org</td><td>the organisation of the dependency module or artifact to exclude, or a regexp matching this organisation <span class="since">since 1.3</span></td>
        <td>No, defaults to *</td></tr>
    <tr><td>module</td><td>the name of the dependency module or the artifact to exclude, or a regexp matching this module name <span class="since">since 1.3</span></td>
        <td>No, defaults to *</td></tr>
    <tr><td>name</td><td>the name of an artifact of the dependency module to add to the exclude list, or a regexp matching this name</td>
        <td>No, defaults to *</td></tr>
    <tr><td>type</td><td>the type of the artifact of the dependency module to add to the exclude list, or a regexp matching this name</td>
        <td>No, defaults to *</td></tr>
    <tr><td>ext</td><td>the extension of the artifact of the dependency module to add to the exclude list, or a regexp matching this name</td>
        <td>No, defaults to type</td></tr>
    <tr><td>matcher</td><td>the matcher to use to match the modules to excludes <span class="since">since 1.3</span></td>
        <td>No, defaults to exactOrRegexp in pre 1.3 ivy files, and exact in 1.3 and superior</td></tr>
    <tr><td>conf</td><td>comma separated list of the master configurations in which this artifact should be included.
    '*' wildcard can be used to designate all configurations of this module</td>
        <td>No, defaults to '*', unless nested conf are specified</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="/ivy/doc/ivyfile/artifact-exclude-conf">conf</a></td><td>configuration in which the artifact should be included</td>
        <td>0..n</td></tr>
</tbody>
</table>
]]>
</content>
<node id="node-76">
<nodeinfo  path='ivy/doc/ivyfile/artifact-exclude-conf' md5_body='0672ece2db667dd470d81ce6e4a2fe67' weight='0' depth='7' type='book' author='admin' uid='1' created='1117633949' status='1' format='3' sticky='0' promote='1'/>
<title>conf</title>
<teaser>
<![CDATA[<b>Tag:</b> conf <b>Parent:</b> <a href="./ivy/doc/ivyfile/artifact-exclude">artifact</a><br/>
<br/>
Specify a configuration in which the enclosing artifact exclusion should be included.

<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the master configuration in which the enclosing artifact should be excluded</td>
        <td>Yes</td></tr>
</tbody>
</table>
]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> conf <b>Parent:</b> <a href="./ivy/doc/ivyfile/artifact-exclude">artifact</a><br/>
<br/>
Specify a configuration in which the enclosing artifact exclusion should be included.

<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the master configuration in which the enclosing artifact should be excluded</td>
        <td>Yes</td></tr>
</tbody>
</table>
]]>
</content>
</node>
</node>
</node>
</node>
<node id="node-77">
<nodeinfo  path='ivy/doc/ivyfile/conflicts' md5_body='5c14b63a2fc08727e91668e94691fa80' weight='3' depth='4' type='book' author='admin' uid='1' created='1117634115' status='1' format='3' sticky='0' promote='1'/>
<title>conflicts</title>
<teaser>
<![CDATA[<b>Tag:</b> conflicts <b>Parent:</b> <a href="./ivy/doc/ivyfile/ivy-module">ivy-module</a><br/><br/>

Container for conflict manager elements, used to indicate how conflicts should be resolved
for this module. <br/><br/>

A conflict occurs when two revisions of the same module are required. This can happen in several cases,
but the more often it is due to transitive dependencies: a module depends on A rev 1.0 and on B rev 2.0, and
B depends on A rev 1.1. Then we say there is a conflict on A.<br/><br/>

To resolve the conflict, ivy uses conflicts managers. A conflict manager is able
to select, among a list of module revisions in conflict, a list of revisions to keep.]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> conflicts <b>Parent:</b> <a href="./ivy/doc/ivyfile/ivy-module">ivy-module</a><br/><br/>

Container for conflict manager elements, used to indicate how conflicts should be resolved
for this module. <br/><br/>

A conflict occurs when two revisions of the same module are required. This can happen in several cases,
but the more often it is due to transitive dependencies: a module depends on A rev 1.0 and on B rev 2.0, and
B depends on A rev 1.1. Then we say there is a conflict on A.<br/><br/>

To resolve the conflict, ivy uses conflicts managers. A conflict manager is able
to select, among a list of module revisions in conflict, a list of revisions to keep.
Yes, it can selects a list of revision, even if most conflicts manager select only one revision.
But in some cases you will need to keep several revisions, and load in separate class loaders,
for example.<br/><br/>

Conflicts manager can be defined in each ivy file.
Conflicts are thus resolved recursively, each module being responsible to resolve
conflicts of its dependencies.<br/><br/>

Conflicts manager are declared by module, this means that you can declare a different
conflict manager for each dependency. Moreover, conflicts manager being in a separate section
in the ivy file (and not in the dependencies section), you can declare them for a set of modules
(using regular expression, see <a href="./ivy/doc/ivyfile/manager">manager</a>), and you can declare them
for non direct dependencies. Imagine a module depends on A and B, A depends on C rev 1.0 and B 
depends on C rev 2.0. Then there is conflict on C which must be solved by the module, even if
the module has no direct dependency on C. This is possible with the conflict manager handling of ivy.<br/><br/>

Ivy comes with 4 built-in conflicts manager, but you can also plug your own:<br/>
- all: this conflicts manager resolve conflicts by selecting all revisions. Also 
called NoConflictManager, it does evict any module.<br/>
- fixed: this conflict manager always select the same revision<br/>
- latest-time: this conflict manager selects only the 'latest' revision, 
latest being defined as the latest in time. Note that latest in time
is costly to compute, so prefer latest-revision if you can.<br/>
- latest-revision: this conflict manager selects only the 'latest' revision, 
latest being defined by a string comparison of revisions as defined by the latest-revision strategy
(see <a href="./ivy/doc/reference">Latest Strategies</a> for details).<br/><br/>

The two "latest" conflicts manager also take into account the force attribute of the dependencies.
Indeed direct dependencies can declare a force attribute (see <a href="./ivy/doc/ivyfile/dependency">dependency</a>), 
which indicates the the revision given in the direct dependency should be prefered over
indirect dependencies.<br/><br/>

Conflicts manager are used during the resolve operation, i.e. when ivy analyse the graph of dependencies
and download corresponding ivy files and artifacts. The fact to manage conflict at resolve time
enables to minimize downloads: when a module is evicted by a conflict manager, it is not downloaded.<br/><br/>

There are two things optimized during conflict resolution: download of artifacts and download
of ivy files. The first is always ensured by ivy, i.e. artifacts of a module evicted will never
be downloaded. The second is not as simple to handle because to know what are the conflicts
ivy needs to know the dependency graph, and to know the dependency graph, it has to download
ivy files. But ivy is highly optimized on this too, and it tries to evict modules as soon as possible.<br/>
That's why the order of dependencies is important for download optimization. Indeed ivy
traverses the dependency graph in the order in which dependencies are declared in the ivy files, 
and each time it encounters a dependency on a module, it first check if there is a conflict on this module, 
and if this is the case, it asks the conflict manager to resolve the conflict. Then if the module is evicted,
it does not download its ivy file, and the whole branch is not traversed, which can saves
a lot of time.<br/><br/>

If this container is not present, a default conflict manager is used for all modules. 
The current default conflict manager is the "latest-revision" conflict manager.
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="./ivy/doc/ivyfile/manager">manager</a></td><td>declares a conflict manager for this module</td>
        <td>1..n</td></tr>
</tbody>
</table>
]]>
</content>
<node id="node-78">
<nodeinfo  path='ivy/doc/ivyfile/manager' md5_body='4533f93cb4b016859eb60835e0679d44' weight='0' depth='5' type='book' author='admin' uid='1' created='1117634248' status='1' format='3' sticky='0' promote='1'/>
<title>manager</title>
<teaser>
<![CDATA[<b>Tag:</b> manager <b>Parent:</b> <a href="./ivy/doc/ivyfile/conflicts">conflicts</a><br/>
<br/>
Specify a a conflict manager for one or several dependencies.<br/>
The way to specify a conflict manager is by giving indication to which dependencies
the conflict manager applies (by giving organisation and module names or name regexp), 
and then specifying the conflict manager, either by giving its name or by
specifying a fixed revision list, in which case a fixed conflicts manager is used.<br/><br/>

See <a href="./ivy/doc/ivyfile/conflicts">Conflicts Manager</a> for details on conflicts manager in general.]]>
</teaser>
<content>
<![CDATA[<b>Tag:</b> manager <b>Parent:</b> <a href="./ivy/doc/ivyfile/conflicts">conflicts</a><br/>
<br/>
Specify a a conflict manager for one or several dependencies.<br/>
The way to specify a conflict manager is by giving indication to which dependencies
the conflict manager applies (by giving organisation and module names or name regexp), 
and then specifying the conflict manager, either by giving its name or by
specifying a fixed revision list, in which case a fixed conflicts manager is used.<br/><br/>

See <a href="./ivy/doc/ivyfile/conflicts">Conflicts Manager</a> for details on conflicts manager in general.

<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>org</td><td>the name, or a regexp matching the name of organisation to which this conflict manager should apply</td>
        <td>No, defaults to * (match all)</td></tr>
    <tr><td>module</td><td>the name, or a regexp matching the name of module to which this conflict manager should apply</td>
        <td>No, defaults to * (match all)</td></tr>
    <tr><td>name</td><td>the name of the conflict manager to use</td>
        <td rowspan="2">Exactly one of two</td></tr>
    <tr><td>rev</td><td>a comma separated list of revisions this conflict manager should select</td></tr>
    <tr><td>matcher</td><td>the matcher to use to match the modules for which the conflict manager should be used <span class="since">since 1.3</span></td>
        <td>No, defaults to exactOrRegexp in pre 1.3 ivy files, and exact in 1.3 and superior</td></tr>
</tbody>
</table>
]]>
</content>
</node>
</node>
</node>
<node id="node-178">
<nodeinfo  path='ivy/doc/use' md5_body='366950256831797cd909f5679dd317a5' weight='-5' depth='3' type='book' author='xavier' uid='6' created='1120048161' status='1' format='1' sticky='0' promote='0'/>
<title>Using Ivy</title>
<teaser>
<![CDATA[The main and most frequent way to use ivy is from an ant build file. However, ivy can also be called as a standalone application]]>
</teaser>
<content>
<![CDATA[The main and most frequent way to use ivy is from an ant build file. However, ivy can also be called as a standalone application]]>
</content>
<node id="node-44">
<nodeinfo  path='ivy/doc/ant' md5_body='8000e94dc7cb40493191fc4e344a568e' weight='-5' depth='4' type='book' author='admin' uid='1' created='1117213924' status='1' format='4' sticky='0' promote='1'/>
<title>From Ant</title>
<teaser>
<![CDATA[The main and most frequent way to use ivy is from an ant build file. However, ivy can also be called as a standalone application

If you use ant version <b>1.6.0</b> or superior, you just have to add ivy namespace to your project (<code>xmlns:ivy="antlib:fr.jayasoft.ivy.ant"</code> attribute of your project tag), and you can call ivy tasks.

If you want to make your build handle ivy.jar in either ant lib dir or a local lib dir, you can follow <a href="./node/233">this tip</a> given by colin sampaleanu.

If you use ant <b>1.5.1</b> or superior, you have to define the tasks you use in your build file. For instance:]]>
</teaser>
<content>
<![CDATA[The main and most frequent way to use ivy is from an ant build file. However, ivy can also be called as a standalone application

If you use ant version <b>1.6.0</b> or superior, you just have to add ivy namespace to your project (<code>xmlns:ivy="antlib:fr.jayasoft.ivy.ant"</code> attribute of your project tag), and you can call ivy tasks.

If you want to make your build handle ivy.jar in either ant lib dir or a local lib dir, you can follow <a href="./node/233">this tip</a> given by colin sampaleanu.

If you use ant <b>1.5.1</b> or superior, you have to define the tasks you use in your build file. For instance:
<code>
  <taskdef name="ivy-configure" classname="fr.jayasoft.ivy.ant.IvyConfigure"/>
  <taskdef name="ivy-resolve" classname="fr.jayasoft.ivy.ant.IvyResolve"/>
  <taskdef name="ivy-retrieve" classname="fr.jayasoft.ivy.ant.IvyRetrieve"/>
  <taskdef name="ivy-deliver" classname="fr.jayasoft.ivy.ant.IvyDeliver"/> 
  <taskdef name="ivy-publish" classname="fr.jayasoft.ivy.ant.IvyPublish"/>
</code>
Then you can use the tasks, but check their name, following samples assume you use the ivy namespace (ivy:xxx tasks), whereas with ant 1.5 you cannot use namespace, and should therefore use ivy-xxx tasks if you have followed the taskdefs above.

If you use an ant version lower than 1.5.1, you can not use the ivy tasks... you should then call ivy as any external program.
<h1>Calling ivy from ant: first steps</h1>
Once your build file is ok to call ivy tasks, the simplest way to use ivy is to call the ivy retrieve task with no parameters:
<code>
<ivy:retrieve />
</code>
This calls ivy with default values, which might be ok in several projects. In fact, it is equivalent to:
<code type="xml">
<target name="resolve">
    <ivy:configure />
    
    <ivy:resolve file="${ivy.dep.file}" conf="${ivy.configurations}" />
    
    <ivy:retrieve pattern="${ivy.retrieve.pattern}" conf="${ivy.configurations}" />
</target>
</code>

Those 3 tasks follow the 3 main steps of ivy retrieving dependencies process:
<ul>
<li>First the configure task tells it how it can find dependencies giving it a path to an <a href="./ivy/doc/configuration">xml configuration file</a>.</li> 
<li>Then the resolve task actually resolve dependencies described by an <a href="./ivy/doc/ivyfile">ivy file</a>, and put those dependencies in the ivy cache (a directory configured in the configuration file).</li>
<li>Finally the retrieve task copies dependencies from the cache to anywhere you want in your file system. You can then use those dependencies to make your classpath with standard ant paths.</li>
</ul>

To understand more accurately the behaviour of ivy tasks, one should know that a property file is loaded in ant by ivy at the beginning of the configure call. This property file contains the following properties:
<code>
ivy.project.dir = ${basedir}
ivy.lib.dir = ${ivy.project.dir}/lib
ivy.build.artifacts.dir = ${ivy.project.dir}/build/artifacts
ivy.distrib.dir = ${ivy.project.dir}/distrib
	
ivy.configurations = *
ivy.resolver.default.check.modified = false
ivy.resolve.default.type.filter = *
ivy.status = integration
ivy.dep.file = ivy.xml
ivy.conf.file = ivyconf.xml
ivy.retrieve.pattern = ${ivy.lib.dir}/[artifact]-[revision].[ext]
ivy.deliver.ivy.pattern = ${ivy.distrib.dir}/[type]s/[artifact]-[revision].[ext]
ivy.publish.src.artifacts.pattern = ${ivy.distrib.dir}/[type]s/[artifact]-[revision].[ext]

ivy.report.output.pattern = [organisation]-[module]-[conf].html

ivy.buildlist.ivyfilepath = ivy.xml
</code>

<h1>Ivy tasks attributes : generalities</h1>
Some tasks attributes values may be given through different places. The three possible places are :
<ol>
<li>task attribute</li>
<li>ivy instance</li>
<li>project property</li>
</ol>
The places are queried in this order, so anything set in task attribute will overwrite what would have been found in ivy instance, for example.

The ivy instance considered here is an instance of the class Ivy, which is setup by a call to the configure task, and then reused for other tasks. Because most of the tasks need an ivy instance, they first check if one is available (i.e. configure has been called), and if none is available, then a default configure is called and the resulting ivy instance is used in the remaining tasks (unless another configure is called).

It isn't generally necessary to understand this, but it can lead to some issues if you forget to call configure before another task and if the configure step was required in your environment.

<h1>Example</h1>
Here is a more complete example of build file using ivy:

<code type="xml">
<project xmlns:ivy="antlib:fr.jayasoft.ivy.ant" name="sample" default="resolve">

    <target name="resolve">
        <ivy:configure file="../ivyconf.xml" />
        
        <ivy:resolve file="my-ivy.xml" conf="default, myconf" />
        
    </target>
    
    <target name="retrieve-default" depends="resolve">
        <ivy:retrieve pattern="lib/default/[artifact]-[revision].[ext]" conf="default" />
    </target>

    <target name="retrieve-myconf" depends="resolve">
        <ivy:retrieve pattern="lib/myconf/[artifact]-[revision].[ext]" conf="myconf" />
    </target>

    <target name="retrieve-all" depends="resolve">
        <ivy:retrieve pattern="lib/[conf]/[artifact]-[revision].[ext]" conf="*" />
    </target>

    <target name="deliver" depends="retrieve-all">
        <ivy:deliver deliverpattern="distrib/[artifact]-[revision].[ext]" pubrevision="1.1b4" pubdate="20050115123254" status="milestone" />
    </target>

    <target name="publish" depends="deliver">
        <ivy:publish resolver="internal" artifactspattern="distrib/[artifact]-[revision].[ext]" pubrevision="1.1b4" />
    </target>
</project>
</code>
All ivy tasks are documented in the following pages.]]>
</content>
<node id="node-79">
<nodeinfo  path='ivy/doc/use/configure' md5_body='49f379fea2e158cf83f8f986bce456a6' weight='-14' depth='5' type='book' author='admin' uid='1' created='1117634671' status='1' format='3' sticky='0' promote='1'/>
<title>configure</title>
<teaser>
<![CDATA[The configure task is used to configure ivy with an xml configuration file.<br/><br/>
See <a href="./ivy/doc/configuration">configuration</a> for details about the configuration
file itself.<br/><br/>
<i>Note for developers:<br/>
After the call to this task, a reference to the configured ivy instance used by all subsequent ant tasks is put in the ant project,
under the id "ivy.instance".</i>
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>file</td><td>path to the configuration file to use</td>]]>
</teaser>
<content>
<![CDATA[The configure task is used to configure ivy with an xml configuration file.<br/><br/>
See <a href="./ivy/doc/configuration">configuration</a> for details about the configuration
file itself.<br/><br/>
<i>Note for developers:<br/>
After the call to this task, a reference to the configured ivy instance used by all subsequent ant tasks is put in the ant project,
under the id "ivy.instance".</i>
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>file</td><td>path to the configuration file to use</td>
        <td rowspan="2">No. If a file is provided, url is ignored. If none are 
        provided, then it attempts to find a file at ${ivy.conf.file}, and if
        this file does not exist, it uses a <a href="./misc/ivy/samples/ivyconf-default.xml">default configuration file</a></td></tr>
    <tr><td>url</td><td>url of the configuration file to use</td></tr>
    <tr><td>host</td><td>http authentication host</td><td rowspan="4">No, unless authentication is required</td></tr>
    <tr><td>realm</td><td>http authentication realm</td></tr>
    <tr><td>username</td><td>http authentication user name</td></tr>
    <tr><td>passwd</td><td>http authentication password</td></tr>
</tbody>
</table>
<h2>HTTP Authentication</h2>
<i>Note: HTTP Authentication can be used only if <a href="http://jakarta.apache.org/commons/httpclient/">commons-httpclient.jar</a> is in your classpath</i>
If any of the url you use in ivy (especially in dependency resolvers) need http
authentication, then you have to provide the host, realm, username and passwd
attributes of the configure task. These settings will then be used in any
further call to ivy tasks.
<h2>Examples</h2>
<h3>Simplest configuration</h3>
<pre>&lt;ivy:configure /&gt;</pre>
Use either ${ivy.conf.file} if it exists, or the <a href="./misc/ivy/samples/ivyconf-default.xml">default configuration file</a>
<h3>Configure with a file</h3>
<pre>&lt;ivy:configure file="myconffile.xml" /&gt;</pre>
<h3>Configure with an url</h3>
<pre>&lt;ivy:configure url="http://mysite.com/myconffile.xml" /&gt;</pre>
]]>
</content>
</node>
<node id="node-80">
<nodeinfo  path='ivy/doc/use/resolve' md5_body='cd52f122d93b04d404ec208d8fb7ebc5' weight='-12' depth='5' type='book' author='admin' uid='1' created='1117634772' status='1' format='4' sticky='0' promote='1'/>
<title>resolve</title>
<teaser>
<![CDATA[The resolve task actually resolve dependencies described in an <a href="./ivy/doc/ivyfile">ivy file</a>, and put the resolved dependencies in the ivy cache.
If configure has not been called before resolve is called, a default configuration will be used (equivalent to call configure with no attributes).

After the call to this task, four properties are set in ant:
<ul>
<li>ivy.organisation</li>
set to the organisation name found in the ivyfile which was used for resolve
<li>ivy.module</li>
set to the module name found in the ivyfile which was used for resolve
<li>ivy.revision</li>
set to the revision name found in the ivyfile which was used for resolve, or a generated revision name if no revision was specified in the file]]>
</teaser>
<content>
<![CDATA[The resolve task actually resolve dependencies described in an <a href="./ivy/doc/ivyfile">ivy file</a>, and put the resolved dependencies in the ivy cache.
If configure has not been called before resolve is called, a default configuration will be used (equivalent to call configure with no attributes).

After the call to this task, four properties are set in ant:
<ul>
<li>ivy.organisation</li>
set to the organisation name found in the ivyfile which was used for resolve
<li>ivy.module</li>
set to the module name found in the ivyfile which was used for resolve
<li>ivy.revision</li>
set to the revision name found in the ivyfile which was used for resolve, or a generated revision name if no revision was specified in the file
<li>ivy.resolved.configurations</li>
set to the comma separated list of configurations resolved
</ul>
An additional property is set only if there are changes since the last resolve: <code>ivy.deps.changed</code> (<span class="since">since 1.2</span>)

When ivy has finished the resolve task, it outputs a summary of what has been resolved. This summary looks like this:
<pre>
---------------------------------------------------------------------
|                  |            modules            ||   artifacts   |
|       conf       | number| search|dwnlded|evicted|| number|dwnlded|
---------------------------------------------------------------------
|      default     |   4   |   0   |   0   |   0   ||   4   |   0   |
---------------------------------------------------------------------
</pre>
This table gives some statistics about the dependency resolution. Each line correspond to a configuration resolved. Then the table is divided in two parts:
<ul>
<li>modules</li>
<ul>
<li>number</li>
This is the total number of dependency modules resolved in this configuration, including transitive ones
<li>search</li>
This is the number of dependency modules that required a repository access. The repository access is needed if the module is not yet in cache, or if a latest version is required, or in some other cases (depending on checkModified, for instance)
<li>downlded</li>
This is the number of dependency ivy files downloaded from the repository. This number can be less than the total number of modules even with a clean cache, if no ivy file is provided for some dependencies.
<li>evicted</li>
This is the number of dependency module evicted by conflict managers.
</ul>
<li>artifacts</li>
<ul>
<li>number</li>
This is the total number of artifacts resolved in the given configuration.
<li>dwnlded</li>
This is the number of artifacts actually downloaded from the repository.
</ul>
</ul>


<i>Note for developers:
After the call to this task, a reference to the module descriptor resolved is put in the ant project under the id <code>"ivy.resolved.descriptor"</code>.</i>

<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>file</td><td>path to the ivy file to use for resolution</td>
        <td>No. Defaults to ${ivy.dep.file}</td></tr>
    <tr><td>conf</td><td>a comma separated list of the configurations to resolve</td><td>No. Defaults to ${ivy.configurations}</td></tr>
    <tr><td>type</td><td>comma separated list of accepted artifact types (<span class="since">since 1.2</span>)</td><td>No. defaults to ${ivy.resolve.default.type.filter}</td></tr>
    <tr><td>haltonfailure</td><td>true to halt the build on ivy failure, false to continue</td><td>No. Defaults to true</td></tr>
    <tr><td>showprogress</td><td>true to show dots while downloading, false otherwise</td><td>No. Defaults to true</td></tr>
    <tr><td>validate</td><td>true to force ivy files validation against ivy.xsd, false to force no validation</td><td>No. Defaults to default ivy value (as configured in configuration file)</td></tr>
</tbody>
</table>
<h1>Examples</h1>
<code type="xml">
<ivy:resolve file="path/to/ivy.xml"/>
</code>
Resolve all dependencies declared in path/to/ivy.xml file.

<code type="xml">
<ivy:resolve file="path/to/ivy.xml" conf="default, test"/>
</code>
Resolve the dependencies declared in the configuration default and test of the path/to/ivy.xml file.

<code type="xml">
<ivy:resolve file="path/to/ivy.xml" type="jar"/>
</code>
Resolve all dependencies declared in path/to/ivy.xml file, but download only jar artifacts.

]]>
</content>
</node>
<node id="node-81">
<nodeinfo  path='ivy/doc/use/retrieve' md5_body='421073601232142e3ef5f55c501a9038' weight='-9' depth='5' type='book' author='admin' uid='1' created='1117634832' status='1' format='4' sticky='0' promote='1'/>
<title>retrieve</title>
<teaser>
<![CDATA[The retrieve task copies resolved dependencies anywhere you want in your file system.
If no resolve has been called before retrieve is called, a default resolve is called (equivalent to a call to resolve with no attributes).
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>pattern</td><td>the pattern to use to copy the dependencies</td>
        <td>No. Defaults to ${ivy.retrieve.pattern}</td></tr>
    <tr><td>ivypattern</td><td>the pattern to use to copy the ivy files of dependencies <span class="since">since 1.3</span></td>]]>
</teaser>
<content>
<![CDATA[The retrieve task copies resolved dependencies anywhere you want in your file system.
If no resolve has been called before retrieve is called, a default resolve is called (equivalent to a call to resolve with no attributes).
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>pattern</td><td>the pattern to use to copy the dependencies</td>
        <td>No. Defaults to ${ivy.retrieve.pattern}</td></tr>
    <tr><td>ivypattern</td><td>the pattern to use to copy the ivy files of dependencies <span class="since">since 1.3</span></td>
        <td>No. Dependencies ivy files are not retrieved by default.</td></tr>
    <tr><td>conf</td><td>a comma separated list of the configurations to retrieve</td>
        <td>No. Defaults to the configurations resolved by the last resolve call, or * if no resolve was explicitly called</td></tr>
    <tr><td>organisation</td><td>the organisation of the module to retrieve. This usually doesn't need to be set since it defaults to the last resolved one.</td><td>No. Defaults to last resolved organisation</td></tr>
    <tr><td>module</td><td>the name of the module to retrieve. This usually doesn't need to be set since it defaults to the last resolved one.</td><td>No. Defaults to last resolved module name</td></tr>
    <tr><td>haltonfailure</td><td>true to halt the build on ivy failure, false to continue</td><td>No. Defaults to true</td></tr>
    <tr><td>validate</td><td>true to force ivy files validation against ivy.xsd, false to force no validation</td><td>No. Defaults to default ivy value (as configured in configuration file)</td></tr>
</tbody>
</table>
<h1>Examples</h1>
<code type="xml">
<ivy:retrieve />
</code>
Retrieves dependencies using default parameters. This usually retrieves all the dependencies of the last resolve call to a lib directory.

<code type="xml">
<ivy:retrieve pattern="${lib.dir}/[conf]/[artifact].[ext]"/>
</code>
Retrieves all dependencies of the last resolve call to a lib directory, dependencies being separated in directories named by configuration, each conf directory containing corresponding artifacts without the revision.
For instance, if the ivy file declares two configurations default and test, the resulting lib dir could look like this:
<code>
lib
  default
    commons-lang.jar
    commons-logging.jar
  test
    junit.jar
</code>
Note that if a dependency is required in the two configurations, it will be copied in the two directories. The download of the dependency is however only made once at resolve time.

<code type="xml">
<ivy:retrieve pattern="${lib.dir}/[type]/[artifact]-[revision].[ext]" conf="runtime"/>
</code>
Retrieves only the dependencies of the <code>runtime</code> configuration in directories named by artifact type. The resulting lib dir could look like this:
<code>
lib
  jar
    commons-lang-1.0.jar
    looks-1.1.jar
  source
    looks-1.1.zip
</code>
]]>
</content>
</node>
<node id="node-82">
<nodeinfo  path='ivy/doc/use/deliver' md5_body='574d0af40bfd287abdfc0e66b651c0df' weight='-5' depth='5' type='book' author='admin' uid='1' created='1117634901' status='1' format='4' sticky='0' promote='1'/>
<title>deliver</title>
<teaser>
<![CDATA[Delivers a resolved ivy file of the current module, and possibly do recursive delivery of dependencies. 
This task does two main things:
<h2>Deliver a resolved ivy file</h2>
This task delivers a resolved ivy file of the current module, based upon the last resolve done. The resolved ivy file contains updated information about the delivered module, such as revision and status.

Moreover, all included configurations files are included in the ivy file, and variables are replaced by their values.

Finally, in the resolved ivy file, dynamic revisions are replaced by the static ones that have been found during the resolve step, so the ivy file can be used later safely to obtain the same dependencies (providing that a revision uniquely identifies a module, which should be the case for proper ivy use).]]>
</teaser>
<content>
<![CDATA[Delivers a resolved ivy file of the current module, and possibly do recursive delivery of dependencies. 
This task does two main things:
<h2>Deliver a resolved ivy file</h2>
This task delivers a resolved ivy file of the current module, based upon the last resolve done. The resolved ivy file contains updated information about the delivered module, such as revision and status.

Moreover, all included configurations files are included in the ivy file, and variables are replaced by their values.

Finally, in the resolved ivy file, dynamic revisions are replaced by the static ones that have been found during the resolve step, so the ivy file can be used later safely to obtain the same dependencies (providing that a revision uniquely identifies a module, which should be the case for proper ivy use).

<span class="since">since 1.3</span> The replacement of dynamic revisions by static ones can be turned off, so that dynamic revisions are kept in the ivy file.
<h2>do recursive delivery</h2>
This is done only if a deliver target is given to the deliver task.

If a deliver target is set, then it is called for each dependency which has not a suffisant status compared to the deliver status set for this task. This means that if you deliver an integration revision, no recursive delivery will be done.

If you deliver a milestone revision, deliver target will be called with each integration dependency. 

Finally, if you deliver a release revision, then deliver target will be called with each integration and milestone dependency.

The deliver target is called with the following properties available:
<ul>
  <li>dependency.name</li>
the name of the dependency to recursively deliver
  <li>dependency.published.status</li>
the status to which the dependency should be delivered
  <li>dependency.published.version</li>
the revision to which the dependency should be delivered
  <li>dependency.version</li>
the revision of the dependency that should be delivered (the one that was retrieved during last resolve)
</ul>
Note that both <code>dependency.published.status</code> and <code>dependency.published.version</code> are in fact asked to the user via standard ant input. The delivered ivy file will update its dependency revisions with those given here.  
  
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>deliverpattern</td><td>the pattern to use for ivy file delivery</td>
        <td>No. Defaults to ${ivy.deliver.ivy.pattern}</td></tr>
    <tr><td>pubrevision</td><td>the revision to use for the publication</td>
        <td>No. Defaults to the ${ivy.deliver.revision}</td></tr>
    <tr><td>pubdate</td><td>the publication date to use for the publication. This date should be either 'now', or a date given with the following pattern: yyyyMMddHHmmss</td>
        <td>No. Defaults to 'now'</td></tr>
    <tr><td>status</td><td>the status to use for the publication</td>
        <td>No. Defaults to ${ivy.status}</td></tr>
    <tr><td>delivertarget</td><td>the target to call for recursive delivery</td>
        <td>No. No recursive delivery is done by default</td></tr>
    <tr><td>validate</td><td>true to force ivy files validation against ivy.xsd, false to force no validation</td>
        <td>No. Defaults to default ivy value (as configured in configuration file)</td></tr>
    <tr><td>replacedynamicrev</td><td>true to replace dynmic revisions by static ones in the delivered file, false to avoid this replacement <span class="since">since 1.3</span></td>
        <td>No. Defaults to true</td></tr>
</tbody>
</table>
]]>
</content>
</node>
<node id="node-83">
<nodeinfo  path='ivy/doc/use/publish' md5_body='ca3ad14b4c38b1ae1cc364fb8f2b8a0a' weight='-3' depth='5' type='book' author='admin' uid='1' created='1117634984' status='1' format='3' sticky='0' promote='1'/>
<title>publish</title>
<teaser>
<![CDATA[Publishes the current modules artifacts.<br/><br/>
This task is meant to publish the declared published artifacts of the current module to a repository.<br/>
The repository is given through the name of a resolver declared in current ivy configuration. See <a href="./ivy/doc/configuration">configuration</a>
for details about resolver supporting artifact publishing.<br/>
It also publishes the delivered ivy file (except if you don't want), and even deliver it if it has not been done with a previous
deliver call. That's why this task takes some parameters useful only for delivery.
  
<table class="ant">]]>
</teaser>
<content>
<![CDATA[Publishes the current modules artifacts.<br/><br/>
This task is meant to publish the declared published artifacts of the current module to a repository.<br/>
The repository is given through the name of a resolver declared in current ivy configuration. See <a href="./ivy/doc/configuration">configuration</a>
for details about resolver supporting artifact publishing.<br/>
It also publishes the delivered ivy file (except if you don't want), and even deliver it if it has not been done with a previous
deliver call. That's why this task takes some parameters useful only for delivery.
  
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>artifactspattern</td><td>the pattern to use to find artifacts to publish</td>
        <td>No. Defaults to ${ivy.publish.src.artifacts.pattern}</td></tr>
    <tr><td>resolver</td><td>the name of the resolver to use for publication</td>
        <td>Yes</td></tr>
    <tr><td>pubrevision</td><td>the revision to use for the publication</td>
        <td>No. Defaults to the ${ivy.deliver.revision}</td></tr>
    <tr><td>validate</td><td>true to force ivy files validation against ivy.xsd, false to force no validation</td>
        <td>No. Defaults to default ivy value (as configured in configuration file)</td></tr>
    <tr><td>replacedynamicrev</td><td>true to replace dynmic revisions by static ones in the delivered file, false to avoid this replacement <span class="since">since 1.3</span></td>
        <td>No. Defaults to true</td></tr>
    <tr><td>publishivy</td><td>True to publish delivered ivy file, false otherwise</td>
        <td>No. Defaults to true</td></tr>
    <tr><td>warnonmissing</td><td>True to warn when artifacts to be published are missing</td>
        <td>No. Defaults to true</td></tr>
    <tr><td>haltonmissing</td><td>True to halt build when artifacts to be published are missing</td>
        <td>No. Defaults to true</td></tr>
    <tr><td>srcivypattern</td><td>the pattern to use to find ivy file to publish, and even deliver if necessary (<span class="since">since 1.2</span>)</td>
        <td>No. Defaults to the value of artifactspattern</td></tr>
    <tr><td>pubdate</td><td>the publication date to use for the delivery, if necessary. This date should be either 'now', or a date given with the following pattern: yyyyMMddHHmmss</td>
        <td>No. Defaults to 'now'</td></tr>
    <tr><td>status</td><td>the status to use for the delivery, if necessary</td>
        <td>No. Defaults to ${ivy.status}</td></tr>
    <tr><td>delivertarget</td><td>the target to call for recursive delivery</td>
        <td>No. No recursive delivery is done by default</td></tr>
</tbody>
</table>
]]>
</content>
</node>
<node id="node-255">
<nodeinfo  path='ivy/doc/use/cachefileset' md5_body='75f624b8ac0eb5363d28b2d922afee10' weight='0' depth='5' type='book' author='xavier' uid='6' created='1126720383' status='1' format='4' sticky='0' promote='0'/>
<title>cachefileset</title>
<teaser>
<![CDATA[Constructs an ant fileset consisting of artifacts in ivy cache for a configuration (<span class="since">since 1.2</span>).<br/><br/>
This task is usually used after a resolve, and can be used instead of retrieve. Note that this task
does not rely on retrieve, because built fileset is made of artifacts direcly in ivy cache.<br/><br/>
Please prefer the use of retrieve + standard ant path creation, which make your build
more independent from ivy (once artifacts are properly retrieved, ivy is not required any more).<br/><br/>
Built fileset is registered in ant with a given id, and can thus be used like any other ant fileset using]]>
</teaser>
<content>
<![CDATA[Constructs an ant fileset consisting of artifacts in ivy cache for a configuration (<span class="since">since 1.2</span>).<br/><br/>
This task is usually used after a resolve, and can be used instead of retrieve. Note that this task
does not rely on retrieve, because built fileset is made of artifacts direcly in ivy cache.<br/><br/>
Please prefer the use of retrieve + standard ant path creation, which make your build
more independent from ivy (once artifacts are properly retrieved, ivy is not required any more).<br/><br/>
Built fileset is registered in ant with a given id, and can thus be used like any other ant fileset using
refid.
  
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>setid</td><td>the id to reference the built fileset</td>
        <td>Yes</td></tr>
    <tr><td>conf</td><td>a comma separated list of the configurations to put in the created path</td>
        <td>No. Defaults to the configurations resolved by the last resolve call, or * if no resolve was explicitly called</td></tr>
    <tr><td>organisation</td><td>the organisation of the module for which the fileset should be built</td>
        <td>No. Defaults to the organisation of the last resolved module in the same build.</td></tr>
    <tr><td>module</td><td>the name of the module for which the fileset should be built</td>
        <td>No. Defaults to the name of the last resolved module in the same build.</td></tr>
    <tr><td>type</td><td>comma separated list of artifact types to accept in the path, * for all</td><td>No. Defaults to *</td></tr>
    <tr><td>haltonfailure</td><td>true to halt the build on ivy failure, false to continue</td><td>No. Defaults to true</td></tr>
    <tr><td>validate</td><td>true to force ivy files validation against ivy.xsd, false to force no validation</td>
        <td>No. Defaults to default ivy value (as configured in configuration file)</td></tr>
</tbody>
</table>
]]>
</content>
</node>
<node id="node-84">
<nodeinfo  path='ivy/doc/use/cachepath' md5_body='1e83b04436e35c71cbcf6c37f5a76c2e' weight='0' depth='5' type='book' author='admin' uid='1' created='1117635023' status='1' format='3' sticky='0' promote='1'/>
<title>cachepath</title>
<teaser>
<![CDATA[Constructs an ant path consisting of artifacts in ivy cache for a configuration.<br/><br/>
This task is usually used after a resolve, and can be used instead of retrieve. Note that this task
does not rely on retrieve, because built path is made of artifacts direcly in ivy cache.<br/><br/>
Please prefer the use of retrieve + standard ant path creation, which make your build
more independent from ivy (once artifacts are properly retrieved, ivy is not required any more).<br/><br/>
Built path is registered in ant with a given id, and can thus be used like any other ant path using
refid.
  ]]>
</teaser>
<content>
<![CDATA[Constructs an ant path consisting of artifacts in ivy cache for a configuration.<br/><br/>
This task is usually used after a resolve, and can be used instead of retrieve. Note that this task
does not rely on retrieve, because built path is made of artifacts direcly in ivy cache.<br/><br/>
Please prefer the use of retrieve + standard ant path creation, which make your build
more independent from ivy (once artifacts are properly retrieved, ivy is not required any more).<br/><br/>
Built path is registered in ant with a given id, and can thus be used like any other ant path using
refid.
  
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>pathid</td><td>the id to reference the built path</td>
        <td>Yes</td></tr>
    <tr><td>conf</td><td>a comma separated list of the configurations to put in the created path</td>
        <td>No. Defaults to the configurations resolved by the last resolve call, or * if no resolve was explicitly called</td></tr>
    <tr><td>organisation</td><td>the organisation of the module for which the path should be built</td>
        <td>No. Defaults to the organisation of the last resolved module in the same build.</td></tr>
    <tr><td>module</td><td>the name of the module for which the path should be built</td>
        <td>No. Defaults to the name of the last resolved module in the same build.</td></tr>
    <tr><td>type</td><td>comma separated list of artifact types to accept in the path, * for all (<span class="since">since 1.2</span>)</td><td>No. Defaults to *</td></tr>
    <tr><td>haltonfailure</td><td>true to halt the build on ivy failure, false to continue</td><td>No. Defaults to true</td></tr>
    <tr><td>validate</td><td>true to force ivy files validation against ivy.xsd, false to force no validation</td>
        <td>No. Defaults to default ivy value (as configured in configuration file)</td></tr>
</tbody>
</table>
]]>
</content>
</node>
<node id="node-85">
<nodeinfo  path='ivy/doc/use/report' md5_body='88cd058a35e1c47f3967b0a5cc774f7b' weight='3' depth='5' type='book' author='admin' uid='1' created='1117635064' status='1' format='3' sticky='0' promote='1'/>
<title>report</title>
<teaser>
<![CDATA[Generates reports of dependency resolving. One report per configuration is generated, but
all reports generated together are hyperlinked one to each other.<br/><br/>
This task should be used only after a call to resolve, even if the call was not done during the same
ant build.<br/>In fact, this task uses xml report generated by resolve in cache. So if you call resolve
on a module for a given configuration, you can call report safely on this module and this configuration
as long as you do not clean your ivy cache.<br/><br/>

If you want to have an idea of what reports look like, check this very simple <a href="./misc/ivy/samples/jayasoft-ivyrep-example-default.html">example</a>.]]>
</teaser>
<content>
<![CDATA[Generates reports of dependency resolving. One report per configuration is generated, but
all reports generated together are hyperlinked one to each other.<br/><br/>
This task should be used only after a call to resolve, even if the call was not done during the same
ant build.<br/>In fact, this task uses xml report generated by resolve in cache. So if you call resolve
on a module for a given configuration, you can call report safely on this module and this configuration
as long as you do not clean your ivy cache.<br/><br/>

If you want to have an idea of what reports look like, check this very simple <a href="./misc/ivy/samples/jayasoft-ivyrep-example-default.html">example</a>.

The task also generates a graphml file which can be loaded with the free <a href="http://www.yworks.com/en/products_yed_about.htm">yEd</a> graph editor.
Then following a few <a href="./ivy/doc/yed">simple steps</a> you can obtain a graph like this <a href="./misc/ivy/samples/jayasoft-ivyrep-example-default.jpg">one</a>.
  
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>todir</td><td>the directory to which reports should be generated</td>
        <td>No, defaults to ${ivy.report.todir}, or execution directory if not defined</td></tr>
    <tr><td>outputpattern</td><td>the generated report names pattern</td>
        <td>No, defaults to ${ivy.report.output.pattern}, or [organisation]-[module]-[conf].html if not defined</td></tr>
    <tr><td>xsl</td><td>true to generate a report (by default html report) using xslt, false otherwise <span class="since">since 1.3</span></td>
        <td>No, defaults to true</td></tr>
    <tr><td>xml</td><td>true to generate a xml report, false otherwise <span class="since">since 1.3</span></td>
        <td>No, defaults to false</td></tr>
    <tr><td>graph</td><td>true to generate graphml files, false otherwise</td>
        <td>No, defaults to true</td></tr>
    <tr><td>conf</td><td>a comma separated list of the configurations for which a report should be generated</td>
        <td>No. Defaults to the configurations resolved by the last resolve call (during same ant build), or ${ivy.resolved.configurations} if no resolve was called</td></tr>
    <tr><td>organisation</td><td>the name of the organisation of the module for which report should be generated</td>
        <td>No, unless no resolve was called during the build. Defaults to last resolved module organisation.</td></tr>
    <tr><td>module</td><td>the name of the module for which report should be generated</td>
        <td>No, unless no resolve was called during the build. Defaults to last resolved module.</td></tr>
    <tr><td>validate</td><td>true to force ivy files validation against ivy.xsd, false to force no validation</td>
        <td>No. Defaults to default ivy value (as configured in configuration file)</td></tr>
    <tr><td>xslfile</td><td>indicates which xsl file should be used to generate the report</td>
        <td>No, defaults to ivy provided xsl which generates html report</td></tr>
</tbody>
</table>
]]>
</content>
<node id="node-45">
<nodeinfo  path='ivy/doc/yed' md5_body='402167d061fd987ff1bf27e463008ebd' weight='0' depth='6' type='book' author='admin' uid='1' created='1117214124' status='1' format='3' sticky='0' promote='1'/>
<title>Using yEd to layout report graphs</title>
<teaser>
<![CDATA[<a href="http://www.yworks.com/en/products_yed_about.htm">yEd</a> is a free graph editor, benefiting from
all the automatic layouts of yFiles. Ivy is able to generate graphs which are readable by yEd.<br/><br/>

The graphs generated by ivy are not layed out (in fact it's why we use yEd), so you have to follow a simple
sequence of steps to layout the generated graphs.<br/><br/>

<h2>Preparation</h2>
First you have to generate a graphml file. Simply call the report task (see <a href="./ivy/doc/use">ivy use documentation</a>)
for that.

<h2>Step 1: open the graphml file</h2>
Launch yEd editor, and open the graphml file generated by the report task. You should obtain something like this:<br/>]]>
</teaser>
<content>
<![CDATA[<a href="http://www.yworks.com/en/products_yed_about.htm">yEd</a> is a free graph editor, benefiting from
all the automatic layouts of yFiles. Ivy is able to generate graphs which are readable by yEd.<br/><br/>

The graphs generated by ivy are not layed out (in fact it's why we use yEd), so you have to follow a simple
sequence of steps to layout the generated graphs.<br/><br/>

<h2>Preparation</h2>
First you have to generate a graphml file. Simply call the report task (see <a href="./ivy/doc/use">ivy use documentation</a>)
for that.

<h2>Step 1: open the graphml file</h2>
Launch yEd editor, and open the graphml file generated by the report task. You should obtain something like this:<br/>
<center>
<img src="/misc/ivy/images/yed-step1.JPG"/>
</center>

<h2>Step 2: ask yEd to adjust nodes size</h2>
<center>
<img src="/misc/ivy/images/yed-step2.JPG"/><br/>
<img src="/misc/ivy/images/yed-step3.JPG"/><br/>
<img src="/misc/ivy/images/yed-step3-2.JPG"/>
</center>

<h2>Step 3: ask yEd to layout nodes</h2>
<center>
<img src="/misc/ivy/images/yed-step4.JPG"/><br/>
<img src="/misc/ivy/images/yed-step5.JPG"/><br/>
<img src="/misc/ivy/images/yed-step6.JPG"/><br/>
<br/>
That's all, you should have obtained something like this:<br/><br/>
<img src="/misc/ivy/images/yed-step7.JPG"/><br/>
<br/>
Note that this is only one possibility, test the available layouts yourself, you could find one better in your case.
Once you have layed out the graph, you can either save it with in the same file (but be warned that it will be overwritten at next 
ivy report call), or another file, export it to jpg, gif, svg, etc. (see <a href="http://www.yworks.com/en/products_yed_about.htm">yEd</a> site for details).
</center>

]]>
</content>
</node>
</node>
<node id="node-405">
<nodeinfo  path='ivy/doc/use/install' md5_body='dffd0f25ab7bd109b5121ee2f38b8bc4' weight='4' depth='5' type='book' author='xavier' uid='6' created='1138000267' status='1' format='4' sticky='0' promote='0'/>
<title>install</title>
<teaser>
<![CDATA[Installs a module and all its dependencies in a resolver. <span class="since">since 1.3</span>

The module to install should be available in a resolver, and will be installed in another resolver which should support publish.

This is particularly useful for users who only have a private repository, and want to benefit from public repositories from time to time. In this case, when a module is missing in the private repository, a call to install let download the module from a public repository not usually used for dependency resolution, and install it and its dependencies in the private repository.]]>
</teaser>
<content>
<![CDATA[Installs a module and all its dependencies in a resolver. <span class="since">since 1.3</span>

The module to install should be available in a resolver, and will be installed in another resolver which should support publish.

This is particularly useful for users who only have a private repository, and want to benefit from public repositories from time to time. In this case, when a module is missing in the private repository, a call to install let download the module from a public repository not usually used for dependency resolution, and install it and its dependencies in the private repository.
  
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>from</td><td>the name of the resolver in which the module must be found</td>
        <td>Yes</td></tr>
    <tr><td>to</td><td>the name of the resolver in which the module must be installed</td>
        <td>Yes</td></tr>
    <tr><td>organisation</td><td>the name of the organisation of the module to install</td>
        <td>Yes</td></tr>
    <tr><td>module</td><td>the name of the module to install</td>
        <td>Yes</td></tr>
    <tr><td>revision</td><td>the revision of the module to install</td>
        <td>Yes</td></tr>
    <tr><td>validate</td><td>true to force ivy files validation against ivy.xsd, false to force no validation</td>
        <td>No. Defaults to default ivy value (as configured in configuration file)</td></tr>
    <tr><td>overwrite</td><td>true to override modules already present in the destination resolver, false otherwise</td>
        <td>No, defaults to false</td></tr>
    <tr><td>transitive</td><td>true to install the module and all its transitive dependencies, false to install only the module</td>
        <td>No, defaults to false</td></tr>
    <tr><td>matcher</td><td>the name of the matcher to use to find the modules to install</td>
        <td>No, defaults to exact</td></tr>
</tbody>
</table>
<h1>Examples</h1>
<code type="xml">
<ivy:install organisation="apache" module="commons-lang" revision="2.0" from="ivyrep" to="myfsresolver"/>
</code>
Installs the module commons-lang from apache in revision 2.0 in the resolver myfsresolver. The module is found in the resolver named 'ivyrep'.
]]>
</content>
</node>
<node id="node-131">
<nodeinfo  path='ivy/doc/use/artifactproperty' md5_body='f4fcf0996aaf66c4a06a2e8dc0504f3b' weight='7' depth='5' type='book' author='xavier' uid='6' created='1118223688' status='1' format='4' sticky='0' promote='1'/>
<title>artifactproperty</title>
<teaser>
<![CDATA[<div class="since">since 1.1</div>
Sets an ant property for each dependency artifacts previously resolved.

Please prefer the use of retrieve + standard ant path creation, which make your build more independent from ivy (once artifacts are properly retrieved, ivy is not required any more).

The property name and value are generated using the classical pattern concept, all artifact tokens and ivy variables being available.
  
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>]]>
</teaser>
<content>
<![CDATA[<div class="since">since 1.1</div>
Sets an ant property for each dependency artifacts previously resolved.

Please prefer the use of retrieve + standard ant path creation, which make your build more independent from ivy (once artifacts are properly retrieved, ivy is not required any more).

The property name and value are generated using the classical pattern concept, all artifact tokens and ivy variables being available.
  
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>a pattern used to generate the name of the properties to set</td>
        <td>Yes</td></tr>
    <tr><td>value</td><td>a pattern used to generate the value of the properties to set</td>
        <td>Yes</td></tr>
    <tr><td>conf</td><td>a comma separated list of the configurations for which properties should be set</td>
        <td>No. Defaults to the configurations resolved by the last resolve call, or * if no resolve was explicitly called</td></tr>
    <tr><td>haltonfailure</td><td>true to halt the build on ivy failure, false to continue</td><td>No. Defaults to true</td></tr>
    <tr><td>validate</td><td>true to force ivy files validation against ivy.xsd, false to force no validation</td>
        <td>No. Defaults to default ivy value (as configured in configuration file)</td></tr>
</tbody>
</table>

<h1>Example</h1>
Suppose we have one dependency called <i>mydep</i> in revision 1.0 publishing two artifacts: <i>foo.jar</i> and <i>bar.jar</i>.
Then:
<code type="xml">
<artifactproperty conf="build" 
       name="[module].[artifact]-[revision]" 
       value="${cache.dir}/[module]/[artifact]-[revision].[ext]"/>
</code>
will set two properties:
<code>
mydep.foo-1.0 = my/cache/dir/mydep/foo-1.0.jar
mydep.bar-1.0 = my/cache/dir/mydep/bar-1.0.jar
</code>
]]>
</content>
</node>
<node id="node-254">
<nodeinfo  path='ivy/doc/use/buildlist' md5_body='7038dcc2df6f6e6393e24944a04495ef' weight='13' depth='5' type='book' author='xavier' uid='6' created='1126718139' status='1' format='4' sticky='0' promote='0'/>
<title>buildlist</title>
<teaser>
<![CDATA[The buildlist task enable to obtain a filelist of files (usually build.xml files) ordered according to ivy dependency information from the least dependent to the most one, or the inverse. (<span class="since">since 1.2</span>)

This is particularly useful combined with subant, to build a set of interelated projects being sure that a dependency will be built before any module depending on it.

<span class="since">since 1.3</span> A root attribute can also be used to include, among all the modules found, only the one that are dependencies (either direct or transitive) of a root module. This can also be used with the excluderoot attribute, which when set to true will exclude the root itself from the list.]]>
</teaser>
<content>
<![CDATA[The buildlist task enable to obtain a filelist of files (usually build.xml files) ordered according to ivy dependency information from the least dependent to the most one, or the inverse. (<span class="since">since 1.2</span>)

This is particularly useful combined with subant, to build a set of interelated projects being sure that a dependency will be built before any module depending on it.

<span class="since">since 1.3</span> A root attribute can also be used to include, among all the modules found, only the one that are dependencies (either direct or transitive) of a root module. This can also be used with the excluderoot attribute, which when set to true will exclude the root itself from the list.

<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>reference</td><td>the reference of the path to set</td>
        <td>Yes</td></tr>
    <tr><td>ivyfilepath</td><td>the relative path from files to order to corresponding ivy files</td><td>No. Defaults to ${ivy.buildlist.ivyfilepath}</td></tr>
    <tr><td>root</td><td><span class="since">since 1.3</span> the name of the module which should be considered as the root of the buildlist</td><td>No. Defaults to no root (all modules are used in the build list)</td></tr>
    <tr><td>excluderoot</td><td><span class="since">since 1.3</span> true if the root defined should be excluded from the list</td><td>No. Defaults to false</td></tr>
    <tr><td>haltonerror</td><td>true to halt the build when an invalid ivy file is encountered, false to continue</td><td>No. Defaults to true</td></tr>
    <tr><td>skipbuildwithoutivy</td><td>true to skip files of the fileset with no corresponding ivy file, false otherwise. If false the file with no corresponding ivy file will be considered as independent of the other and put at the beginning of the built filelist.</td><td>No. Defaults to false</td></tr>
    <tr><td>reverse</td><td>true to obtain the list in the reverse order, i.e. from the most dependent to the least one</td><td>No. Defaults to default false</td></tr>
</tbody>
</table>

<h2>Parameters specified as nested elements</h2>
<h3>fileset</h3>
FileSets are used to select sets of files to order.
<h1>Examples</h1>
<code type="xml">
    <ivy:buildlist reference="build-path">
      <fileset dir="projects" includes="**/build.xml"/>
    </ivy:buildlist>
</code>
Builds a list of build.xml files sorted according to the ivy.xml files found at the same level (the default value for ivyfilepath is ivy.xml).

This list can then be used like that:
<code type="xml">
    <subant target="build" buildpathref="build-path" />
</code>

<hr/>
<code type="xml">
    <ivy:buildlist reference="build-path" ivyfilepath="ivy/ivy.xml" reverse="true">
      <fileset dir="projects" includes="**/build.xml"/>
    </ivy:buildlist>
</code>
Builds a list of build.xml files sorted according to the ivy.xml files found in an ivy directory relative to those build files. The list is sorted from the most dependent to the least one.
<hr/>
<code type="xml">
    <ivy:buildlist reference="build-path" ivyfilepath="ivy/ivy.xml" root="myapp">
      <fileset dir="projects" includes="**/build.xml"/>
    </ivy:buildlist>
</code>
Builds a list of build.xml files sorted according to the ivy.xml files found in an ivy directory relative to those build files. Only build.xml files of modules which are dependencies of myapp (either direct or transitive) are put in the result list.


]]>
</content>
</node>
<node id="node-86">
<nodeinfo  path='ivy/doc/use/var' md5_body='6a0a7a90fdd709aaac46eaaf713d251b' weight='13' depth='5' type='book' author='admin' uid='1' created='1117635132' status='1' format='3' sticky='0' promote='1'/>
<title>var</title>
<teaser>
<![CDATA[Sets a variable (by name and value), or set of variables (from file or url) in ivy. <br/>
Variables are case sensitive.<br/><br/>
Contrary to ant properties, ivy variables are mutable. But a problem with this is that you do not control when 
variables are substituted, and usually it is done as soon as possible. So changing the value of a variable will
have no effect if it has already been substituted. Consequently, <b>using this task is NOT recommended</b>.
See <a href="./ivy/doc/reference">reference</a> page for details about ivy variables.
<br/><br/>
  
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>]]>
</teaser>
<content>
<![CDATA[Sets a variable (by name and value), or set of variables (from file or url) in ivy. <br/>
Variables are case sensitive.<br/><br/>
Contrary to ant properties, ivy variables are mutable. But a problem with this is that you do not control when 
variables are substituted, and usually it is done as soon as possible. So changing the value of a variable will
have no effect if it has already been substituted. Consequently, <b>using this task is NOT recommended</b>.
See <a href="./ivy/doc/reference">reference</a> page for details about ivy variables.
<br/><br/>
  
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the variable to set</td>
        <td>No</td></tr>
    <tr><td>value</td><td>the value of the variable to set</td>
        <td>Yes when using the name attribute</td></tr>
    <tr><td>file</td><td>the filename of the property file to load as ivy variables</td>
        <td rowspan="2">One of these, when <b>not</b> using the name attribute</td></tr>
    <tr><td>url</td><td>the url from which to read ivy variables</td></tr>
    <tr><td>prefix</td><td>Prefix to apply to variables. A "." is appended to the prefix if not specified.</td>
        <td>No</td></tr>
</tbody>
</table>
]]>
</content>
</node>
</node>
<node id="node-179">
<nodeinfo  path='ivy/doc/standalone' md5_body='44877462a6d299dcbdb10fe0f558b840' weight='0' depth='4' type='book' author='xavier' uid='6' created='1120048285' status='1' format='4' sticky='0' promote='0'/>
<title>Standalone</title>
<teaser>
<![CDATA[In the case you want to call ivy as a standalone program (outside from ant), you have to put commons-cli 1.0 and its dependencies in your classpath.

Then here is how to call it:
<code>
java fr.jayasoft.ivy.Main -?
</code>
It will indicate you what can be given as argument. 


<span class="since">since 1.3</span> System properties are included as ivy variables, so you can easily define an ivy variable like this:
<code>
java -Dmyivyvar=myvalue fr.jayasoft.ivy.Main [parameters]
</code>


<h1>Examples</h1>
<code>
java fr.jayasoft.ivy.Main
</code>
calls ivy with default configuration using ivy.xml in the current dir]]>
</teaser>
<content>
<![CDATA[In the case you want to call ivy as a standalone program (outside from ant), you have to put commons-cli 1.0 and its dependencies in your classpath.

Then here is how to call it:
<code>
java fr.jayasoft.ivy.Main -?
</code>
It will indicate you what can be given as argument. 


<span class="since">since 1.3</span> System properties are included as ivy variables, so you can easily define an ivy variable like this:
<code>
java -Dmyivyvar=myvalue fr.jayasoft.ivy.Main [parameters]
</code>


<h1>Examples</h1>
<code>
java fr.jayasoft.ivy.Main
</code>
calls ivy with default configuration using ivy.xml in the current dir
<hr/>
<code>
java fr.jayasoft.ivy.Main -conf path/to/myivyconf.xml -ivy path/to/myivy.xml
</code>
calls ivy with given ivyconf file using given ivy file
<hr/>
<span class="since">since 1.3</span>
<code>
java fr.jayasoft.ivy.Main -conf path/to/myivyconf.xml -dependency apache commons-lang 2.0
</code>
calls ivy with given ivyconf file and resolve apache commons-lang 2.0. 

This is equivalent to:
<code>
java fr.jayasoft.ivy.Main -conf path/to/myivyconf.xml -ivy ivy.xml
</code>
with ivy.xml like this:
<code type="xml">
<ivy-module version="1.0">
  <info organisation="org"
       module="standalone"
       revision="working"
   />
  <dependencies>
    <dependency org="apache" name="commons-lang" rev="2.0" conf="default->*"/>
  </dependencies>
</ivy-module>
</code>
<hr/>
<span class="since">since 1.3</span>
<code>
java fr.jayasoft.ivy.Main -conf path/to/myivyconf.xml -ivy path/to/myivy.xml -cachepath mycachefile.txt
</code>
calls ivy with given ivyconf file and resolve the dependencies found in the given ivy file, and then output the classpath of resolved artifacts in cache in a file. This file can then be used to define a classpath corresponding to all the resolved dependencies for any java program. 

]]>
</content>
</node>
</node>
<node id="node-110">
<nodeinfo  path='ivy/doc/extend' md5_body='18d182f0ac5178bf12b1cb76cbdd31d6' weight='0' depth='3' type='book' author='admin' uid='1' created='1118139755' status='1' format='3' sticky='0' promote='1'/>
<title>Extending Ivy</title>
<teaser>
<![CDATA[Many things are configurable in ivy, and many things are available with ivy core. But when you want to do 
something not built in ivy core, you can still plug your own code.<br/><br/>

Several things are pluggable in ivy:
<ul>
<li>module descriptor parsers</li>
<li>dependency resolvers</li>
<li>latest strategies</li>
<li>conflict managers</li>
</ul>

Before trying to implement your own, we encourage you to check if the solution to your problem cannot be 
addressed by existing features, or by <a href="./ivy/links">contributed ones</a>. Do not hesitate to ask for help on the forum.<br/><br/>]]>
</teaser>
<content>
<![CDATA[Many things are configurable in ivy, and many things are available with ivy core. But when you want to do 
something not built in ivy core, you can still plug your own code.<br/><br/>

Several things are pluggable in ivy:
<ul>
<li>module descriptor parsers</li>
<li>dependency resolvers</li>
<li>latest strategies</li>
<li>conflict managers</li>
</ul>

Before trying to implement your own, we encourage you to check if the solution to your problem cannot be 
addressed by existing features, or by <a href="./ivy/links">contributed ones</a>. Do not hesitate to ask for help on the forum.<br/><br/>

If you still don't find what you need, there are two solutions:<br/>
- prepare yourself to enter in ivy internals<br/>
- <a href="mailto:commercial@jayasoft.org">contact us</a> to ask for specific development or advice. As ivy creators,
we will always spend less time to implement your features or help you make good developement environment a reality.
So do not hesitate to contact us and ask for a pricing.<br/><br/>

And what if you still want to develop your own plugins ? Here are the main things to know...<br/><br/>

All ivy plug-ins use the same code patterns as ant specific tasks for parameters. This means that
if you want to have a "myattribute" of type String, you just have to declare a method called
setMyattribute(String val) on your plug-in. The same applies to child tags, you just have to follow ant specifications.<br/><br/>

Knowing that, you then have to implement the appropriate interface:
<ul>
<li>fr.jayasoft.ivy.DependencyResolver for dependency resolvers</li>
<li>fr.jayasoft.ivy.LatestStrategy for latest strategies</li>
<li>fr.jayasoft.ivy.ConflictManager for conflict managers</li>
<li>fr.jayasoft.ivy.parser.ModuleDescriptorParser for module descriptor parsers</li>
</ul>

To help you understand what is required in each implementation, and what you can use to do it, have a look
to existing implementations, it's the best advice we can give you !
]]>
</content>
</node>
</node>
<node id="node-105">
<nodeinfo  path='ivy/doc/appendix' md5_body='f1ad53e4969f9ccc556e1adc1beea8d4' weight='4' depth='2' type='book' author='admin' uid='1' created='1118037482' status='1' format='1' sticky='0' promote='1'/>
<title>Appendix</title>
<teaser>
<![CDATA[This section is the home of a bunch of appendixes to ivy main documentation.

For the moment, you will find here a product comparison giving a rapid overview of several dependency management tools and how they compare to ivy.]]>
</teaser>
<content>
<![CDATA[This section is the home of a bunch of appendixes to ivy main documentation.

For the moment, you will find here a product comparison giving a rapid overview of several dependency management tools and how they compare to ivy.]]>
</content>
<node id="node-142">
<nodeinfo  path='ivy/ivyrep' md5_body='3b82392892651068e824efc6271dbe73' weight='-3' depth='3' type='book' author='xavier' uid='6' created='1118592542' status='1' format='1' sticky='0' promote='0'/>
<title>IvyRep</title>
<teaser>
<![CDATA[IvyRep is the official  ivy repository. For the moment, it only stores ivy files, artifacts being most of the time found on ibiblio.

You can find more information on ivyrep on its own home page:
<a href="http://ivyrep.jayasoft.org/">http://ivyrep.jayasoft.org/</a>.]]>
</teaser>
<content>
<![CDATA[IvyRep is the official  ivy repository. For the moment, it only stores ivy files, artifacts being most of the time found on ibiblio.

You can find more information on ivyrep on its own home page:
<a href="http://ivyrep.jayasoft.org/">http://ivyrep.jayasoft.org/</a>.]]>
</content>
</node>
<node id="node-562">
<nodeinfo  path='ivy/doc/m2comparison' md5_body='90b05f1081ce7d929588719e90374f68' weight='0' depth='3' type='book' author='xavier' uid='6' created='1143214768' status='1' format='4' sticky='0' promote='0'/>
<title>Ivy / Maven2 Comparison</title>
<teaser>
<![CDATA[We are frequently asked how ivy compares to maven2, and since the <a href="./ivy/doc/comparison">products comparison</a> page is really outdated, we have decided that this comparison deserves its own page.

Obviously this comparison is biased (hey, you are on official Ivy site :-)), but we'll try to keep it as fair as possible. Do not hesitate to add comment if you feel something is missing or false on this page. You can also have a look at <a href="http://docs.codehaus.org/display/MAVEN/Feature+Comparisons">Maven2 feature comparison page on codehaus</a>, which itself offers another point of view.]]>
</teaser>
<content>
<![CDATA[We are frequently asked how ivy compares to maven2, and since the <a href="./ivy/doc/comparison">products comparison</a> page is really outdated, we have decided that this comparison deserves its own page.

Obviously this comparison is biased (hey, you are on official Ivy site :-)), but we'll try to keep it as fair as possible. Do not hesitate to add comment if you feel something is missing or false on this page. You can also have a look at <a href="http://docs.codehaus.org/display/MAVEN/Feature+Comparisons">Maven2 feature comparison page on codehaus</a>, which itself offers another point of view.

But here is the points we think mainly differentiate maven2 and Ivy.

<h1>Comparing plants and apples</h1>
First, the most important difference between maven2 and ivy is that they aren't at all the same kind of tools. Maven2 is a software project management and comprehension tool, whereas Ivy is only a dependency management tool, highly integrated with ant, the popular build management tool. Maven2 offers dependency management facility, and that's why many ask how ivy compares to maven2. That's why we'll focus only on dependency management features of maven2 in this comparison.
So if you look for an out of the box software project management tool, you may skip the rest of this comparison and check what maven2 has to offer.

<h1>Different concepts</h1>
Ivy heavily relies on a unique concept called configuration. In ivy, a module configuration is a way to use or to see the module. For instance, you can have a test and runtime configuration in your module. But you can also have a mysql and an oracle configuration. Or an hibernate and a jdbc configuration. In each configuration you can declare what artifacts (jar, war, ...) are required. And in each configuration, you can declare your dependencies on other modules, and describe which configuration of the dependency you need. This is called configuration mapping, and it is a very flexible way to answer to a lot of problems we face very often in software development.

Maven2 on its side has something called the scope. You can declare a dependency as being part of the test scope, or the buildtime scope. Then depending on this scope you will get the dependency artifact (only one artifact per module in maven2) with its dependencies depending on their scope. Scopes are predefined in maven2 and you can't change that. No way to create an oracle scope. No way to indicate you need what as been declared to be needed in the runtime scope of your dependency in your compile one. Everything here is written in the marble.

And this leads to some kind of troubles... as Matt Raible stated in his <a href="http://raibledesigns.com/page/rd?anchor=maven_2_s_transitive_dependencies">blog</a> talking about maven2 dependencies:
[quote]
There are a *lot* of unnecessary dependencies downloaded for many libraries. For example, Hibernate downloads a bunch of JBoss JARs and the Display Tag downloads all the various web framework JARs. I found myself excluding almost as many dependencies as I added.
[/quote]
The problem is that hibernate can be used with several cache implementations, several connection pool implementation, ... And this can't be managed with scopes, wheres Ivy configurations offers an elegant solution to this kind of problem. For instance, in ivy, assuming hibernate as an ivy file like <a href="http://ivyrep.jayasoft.org/hibernate/hibernate/ivy-2.1.8.xml">this one</a>, then you can declare a dependency like that:
<code type="xml">
<dependency org="hibernate" name="hibernate" rev="2.1.8" conf="default->proxool,oscache"/>
</code>
to get hibernate with its proxool and oscache implemetations, and like that:
<code type="xml">
<dependency org="hibernate" name="hibernate" rev="2.1.8" conf="default->dbcp,swarmcache"/>
</code>
to get hibernate with dbcp and swarmcache.

<h1>Documentation</h1>
An important thing to be able to use a tool is its amount of documentation. With Ivy, even if they are written in broken english (would you have prefered well written french :-)), the printer friendly version of the documentation is now about 120 pages. 
With maven2, it's a bit difficult to clearly know what can be considered as dependency management documentation, but we didn't managed to find much: some small introductory guides, short entries in the pom reference guide, and not really much more.

<h1>Conflict management</h1>
Conflict management are an important part of dependency management, cause when dealing with transitive dependencies you often have to face conflicts. In this area, Ivy let you do whatever you want: use one conflict manager in one module, another one elsewhere, decide which revision you will get, ... You can even plug your own conflict manager if you need to.

With maven2, conflict management is quite simple: the principle is to get the nearest definition. So if your module depends on foo 1.0, none of your dependencies will ever manage to get foo 1.1 without a change in your own dependency declaration. It may be ok in some cases, it may not in others...

<h1>Flexibility</h1>
In ivy many things can be configured, and many others can be plugged in: dependency resolvers, conflict manager, module descriptor parser, latest revision strategy, ... Maven2 also offers repository pluggability, but not much more as far as we know. Moreover, repository configuration seems to be less flexible than with ivy.

<h1>Public Repositories</h1>
Maven2 comes out of the box configured to use ibiblio maven2 repository, which contains <strong>a lot</strong> of modules (both artifacts and module descriptors). The only problem some may face is that module descriptors are not always checked, so some are not really well written.
Ivy, on its side, is used out of the box with ivyrep, ivy official repository, which contains only a few modules, and is not updated frequently. But it is also compatible with maven1 ibiblio repository (for artifacts only, no module descriptors), can also be used with maven2 repository (with pom compatibility, you will here only face some naming problems that can be addressed using the namespace feature, and you won't benefit from ivy configurations with the module descriptors found there), and also has an ivyrep sandbox in which much more module descriptors can be found (not checked, as with ibiblio repository).]]>
</content>
</node>
<node id="node-49">
<nodeinfo  path='ivy/doc/comparison' md5_body='78c4f7785cfa96a4c96607fcc58238e9' weight='3' depth='3' type='book' author='admin' uid='1' created='1117614564' status='1' format='3' sticky='0' promote='1'/>
<title>Products Comparison</title>
<teaser>
<![CDATA[You can find an updated and detailed Ivy / Maven2 comparison <a href="/ivy/doc/m2comparison">here</a>.<br/><br/>

<i>Last updated: 2005-06-01</i><br/><br/>
We are frequently asked how Ivy can be compared to other dependency management tools. Here is a
short matrix summing up a comparison of the products handling dependency management that
we have heard about.<br/>
<br/>
Obviously, this comparison can not be objective and may be inacurrate for some
products, but we have tried to do it with as little subjective judgement as possible.<br/>
<br/>
<table class="comparison">
	<thead>
		<tr>]]>
</teaser>
<content>
<![CDATA[You can find an updated and detailed Ivy / Maven2 comparison <a href="/ivy/doc/m2comparison">here</a>.<br/><br/>

<i>Last updated: 2005-06-01</i><br/><br/>
We are frequently asked how Ivy can be compared to other dependency management tools. Here is a
short matrix summing up a comparison of the products handling dependency management that
we have heard about.<br/>
<br/>
Obviously, this comparison can not be objective and may be inacurrate for some
products, but we have tried to do it with as little subjective judgement as possible.<br/>
<br/>
<table class="comparison">
	<thead>
		<tr>
			<th>Product</th>
			<th>Maven ibiblio <br/>compatibility</th>
			<th>Ant <br/>integration</th>
			<th>Continuous <br/>integration</th>
			<th>Transitive <br/>dependencies</th>
			<th>Flexibility</th>
			<th>Maturity</th>
			<th>License</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><a href="http://ivy.jayasoft.org/">Ivy</a></td>
			<td>++</td>
			<td>++</td>
			<td>++</td>
			<td>+++</td>
			<td>++</td>
			<td>++</td>
			<td>BSD</td>
		</tr>
		<tr>
			<td><a href="http://maven.apache.org/">Maven</a></td>
			<td>+++</td>
			<td>--</td>
			<td>+</td>
			<td>--</td>
			<td>+</td>
			<td>+++</td>
			<td>Apache Software License</td>
		</tr>
		<tr>
			<td><a href="http://maven.apache.org/maven2/">Maven2</a></td>
			<td>++ *</td>
			<td>-</td>
			<td>++</td>
			<td>+</td>
			<td>+</td>
			<td>---</td>
			<td>Apache Software License</td>
		</tr>
		<tr>
			<td><a href="http://www.httpunit.org/doc/dependencies.html">HttpUnit Dependencies</a></td>
			<td>++</td>
			<td>++</td>
			<td>+</td>
			<td>--</td>
			<td>+</td>
			<td>-</td>
			<td>MIT License</td>
		</tr>
		<tr>
			<td><a href="http://www.inversoft.com/online/savant/savant.html">Savant</a></td>
			<td>--</td>
			<td>++</td>
			<td>--</td>
			<td>+</td>
			<td>++</td>
			<td>++</td>
			<td>Other</td>
		</tr>
	</tbody>
</table>
<h1>Some Explanations</h1>
<h2>Maven ibiblio compatiblity</h2>
The use of the maven ibiblio repository is interesting because it is already filled with many projects. 
Benefiting from this repository is thus a plus.<br/><br/>
On this feature, the best is obviously <b>maven</b> itself, since this repository has been built at the initiative
of the project. <b>Maven2</b> is a bit special, because it changes the layout of the repository compared to
maven1, and thus a new repository is available. But everything in the first repository seems to be synced in the second, and how could we say that maven is not 100% compatible with maven repository ;-).<br/>
The <b>dependencies task of http-unit</b> is also very good, one of the main aim of the project
being to bring this repository to ant users. <b>Savant</b> does not provide such a compatibility.<br/>
<b>Ivy</b>, since its version 0.6, can be considered almost as good as the dependencies task. It 
provides a built-in ibiblio repository compatibility, and the limitation of not being able to say that you depend on a 
particular jar of a module has been deleted by the 0.6+ feature of <a href="/ivyfile.@EXT@#dependency-artifact">artifacts restriction</a>. 
For sure, the use of ivy files for dependencies is still heavily recommended, the advantage of this technique being 
that once an ivy file has been written, you can reuse the module easier, and it's the aim of Ivy. 

<h2>Ant integration</h2>
Ant is the most used build tool in the java community. Being well integrated with it is a real plus.<br/><br/>
On this feature, <b>maven</b>, which is also a build tool by its own and not only a dependency management tool,
is the only one to distinguish itself (even if you can call ant tasks from maven, the opposite is not easily
the case). <b>Maven2</b> will propose ant tasks for its dependency management feature, so a good step is taken in this direction. But for the moment it's not publicly available.
For the others, integration is at the same level. The <b>dependencies task and Savant</b> could be claimed 
to be more integrated, since the dependencies are declared in the build file itself and they produce paths or
filesets of the dependencies. <br/>
<b>Ivy</b>, for its part, has taken the party to be less intrusive in the build file:<br/>
- The dependencies are described in a separate file. The advantage of being separated is that
this dependency file can be reused for dependency of dependency management, and that
it can have its own life in your source control management, in particular.<br/>
- It lets you build your filesets and paths by your own. The advantage is that if you already have a build file,
you can simply ask Ivy to put your dependencies at the place they used to be, and that's all, you have migrated to 
Ivy. Moreover, you can still benefit of all the power of ant filesets and paths declaration.<br/> 
- Since 0.8, it is able to build a path for you with the cachepath task.<br/>

<h2>Continuous integration</h2>
A dependency management tool is the most util when your dependencies change often, and this is especially 
the case in a continuous integration environment, where your dependencies can change of version very often.<br/><br/>
On this point, as far as I know, <b>Savant</b> do not allow to automatically change the version you
use when a new is released. <br/>
<b>Maven</b> provides a SNAPSHOT feature, which enables continuous integration
only if the component you depend on publishes SNAPSHOT versions. And you can by no way know which
was really that version, in order to get that particular version on a later time.<br/>
I have for the moment very few information on <b>Maven2</b> on this subject, but it will at least
do what maven did.<br/>
The <b>dependencies task</b> say you can tell that you depend on the latest version,
and that it is then the responsibility of the Repository to get it... but I haven't found more information
on their web site. Maybe it uses the same principle as Maven...<br/>
<b>Ivy</b> uses pluggable latest strategies to find the latest version, so that the component you depend on
has nothing special to do.
Moreover, it produces a report in which it tells which version has been retrieved, so that you can 
easily know the environment of the component you are building. Finally, it can even produce an ivy file
with all latest revisions resolved to a fixed one, so that you can use it to reproduce the same environment even later, when new versions of the 
dependencies will have been built.<br/>

<h2>Transitive dependencies</h2>
Transitive dependencies management, also known as dependencies of dependencies management,
let you reuse more easily complex components which have themselves 
dependencies, and help you manage conflicts between dependencies.<br/>
<b>Maven</b> and the <b>dependencies task</b> does not provide this feature at all.<br/>
<b>Maven2</b> will provide this feature, but few doc is avaialble for the moment. It seems that it will
be handled by declaring a dependency on the pom of another project. I have no information on how
filter will be applied to the transitive dependencies.<br/> 
<b>Savant</b> actually manage transitive dependencies, but you automatically
get all dependencies of your dependencies, not being able to filter them easily.<br/>
<b>Ivy</b> provides this feature, and, with its concept of configurations, let you choose the set of artifacts
of your dependencies you really need. You can even use fine graine filters (include/exclude) to adjust what
you want. Finally, its unique configurable conflict manager let you manage conflicts the way you want,
even if the default strategy works in most cases so that no special configuration is required.

<h2>Flexibility</h2>
Is the dependency management tool able to adapt to your environment, or have you to follow
its rules ? It's a matter of flexibility, and it's hard to evaluate.<br/>
As far as I know, <b>Maven</b> dependency management is based on a rigid structure of repository
you have to follow, unless you specify for each jar where it can be found, which does 
not really let you have a repository structure of your choice. <b>Maven2</b> will certainly follow the same philosophy. 
The <b>dependencies task</b> has the same
limitation, unless you create your own implementation of Repository. <b>Savant</b> seems to provide a lot of 
flexibility, but it also seems quite hard to configure.<br/>
<b>Ivy</b> is extremely flexible:<br/>
- comes out of the box with two main ways to find dependencies (filesystem based 
and url based)<br/>
- let you configure your repository layout with very simple
to define patterns<br/>
- let you use multiple repositories, chaining them or defining which repository to use
for which modules or group of modules<br/>
- let you choose where you artifacts are copied in your file system, with or without
version in the name, and structured the way you want, all with the same simple pattern
principle<br/>
- let you define reusable configurations of your component, since a same component
does not have the dependencies at build time or runtime, or when deployed in a server or as 
a standalone application, etc.<br/>

<h2>Maturity</h2>
On this point, two products are now quite old and can be considered mature: <b>Maven</b> and <b>Savant</b>.
On the other hand, the <b>dependencies task</b> has published its first version (0.1) on september 2004, and, at the time of this writing, no version has been published since their 0.4 in december 2004.<br/>
<b>Maven2</b> is still in alpha, with no public download and very few documentation.<br/>
Finally, <b>Ivy</b> as published its first public version (0.5) on january 2005 after several months of use in our company. After several months of user driven development and testing, and after several weeks
of release candidates cycles, it has reached its first stable release on april 2005: 1.0. 
<br/><br/><br/>
Feel free to comment the comparison on this page if you think that we have forgotten some points or missed 
features of the other products.]]>
</content>
</node>
</node>
</node>
